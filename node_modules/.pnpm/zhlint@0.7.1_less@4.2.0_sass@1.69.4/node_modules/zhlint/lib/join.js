"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const report_1 = require("./report");
const isInRange = (start, end, mark) => {
    return start <= mark.end && end >= mark.start;
};
const isIgnored = (token, marks = []) => {
    const result = {
        [report_1.ValidationTarget.CONTENT]: false,
        [report_1.ValidationTarget.SPACE_AFTER]: false,
        [report_1.ValidationTarget.START_CONTENT]: false,
        [report_1.ValidationTarget.END_CONTENT]: false,
        [report_1.ValidationTarget.INNER_SPACE_BEFORE]: false,
    };
    // - group: startContent, innerSpaceBefore, endContent, spaceAfter
    // - single: raw, spaceAfter
    marks.forEach((mark) => {
        if (Array.isArray(token)) {
            const { index, startContent, innerSpaceBefore, endIndex = 0, endContent, spaceAfter } = token;
            if (isInRange(index, index + (startContent || '').length, mark)) {
                result[report_1.ValidationTarget.SPACE_AFTER] = true;
            }
            if (isInRange(index + (startContent || '').length, index + (startContent || '').length + (innerSpaceBefore || '').length, mark)) {
                result[report_1.ValidationTarget.INNER_SPACE_BEFORE] = true;
            }
            if (isInRange(endIndex, endIndex + (endContent || '').length, mark)) {
                result[report_1.ValidationTarget.END_CONTENT] = true;
            }
            if (isInRange(endIndex + (endContent || '').length, endIndex + (endContent || '').length + (spaceAfter || '').length, mark)) {
                result[report_1.ValidationTarget.SPACE_AFTER] = true;
            }
        }
        else {
            const { index, content, spaceAfter } = token;
            if (isInRange(index, index + (content || '').length, mark)) {
                result[report_1.ValidationTarget.CONTENT] = true;
            }
            if (isInRange(index + (content || '').length, index + (content || '').length + (spaceAfter || '').length, mark)) {
                result[report_1.ValidationTarget.SPACE_AFTER] = true;
            }
        }
    });
    return result;
};
const recordValidations = (token, offset = 0, ignoredFlags, validations = []) => {
    token.validations.forEach((v) => {
        if (!ignoredFlags[v.target]) {
            validations.push(Object.assign(Object.assign({}, v), { index: v.index + offset }));
        }
    });
};
/**
 * Join tokens back into string
 * @param tokens the target group token, the index is relative to the block it belongs to
 * @param offset the index of the block, relative to the file it belongs to
 * @param ignoredMarks the ignored marks, the index is relative to the block it belongs to
 * @param validations the validation list result
 * @param isChild whether the group token is a child token of the block
 */
const join = (tokens, offset = 0, ignoredMarks = [], validations = [], isChild) => {
    const ignoredFlags = isIgnored(tokens, ignoredMarks);
    if (!isChild) {
        recordValidations(tokens, offset, ignoredFlags, validations);
    }
    return [
        ignoredFlags[report_1.ValidationTarget.START_CONTENT] ? tokens.startContent : tokens.modifiedStartContent,
        ignoredFlags[report_1.ValidationTarget.INNER_SPACE_BEFORE]
            ? tokens.innerSpaceBefore
            : tokens.modifiedInnerSpaceBefore,
        ...tokens.map((token) => {
            const subIgnoredFlags = isIgnored(token, ignoredMarks);
            recordValidations(token, offset, subIgnoredFlags, validations);
            if (!Array.isArray(token)) {
                return [
                    subIgnoredFlags[report_1.ValidationTarget.CONTENT] ? token.content : token.modifiedContent,
                    subIgnoredFlags[report_1.ValidationTarget.SPACE_AFTER]
                        ? token.spaceAfter
                        : token.modifiedSpaceAfter
                ]
                    .filter(Boolean)
                    .join('');
            }
            return join(token, offset, ignoredMarks, validations, true);
        }),
        ignoredFlags[report_1.ValidationTarget.END_CONTENT] ? tokens.endContent : tokens.modifiedEndContent,
        ignoredFlags[report_1.ValidationTarget.SPACE_AFTER] ? tokens.spaceAfter : tokens.modifiedSpaceAfter
    ]
        .filter(Boolean)
        .join('');
};
exports.default = join;
