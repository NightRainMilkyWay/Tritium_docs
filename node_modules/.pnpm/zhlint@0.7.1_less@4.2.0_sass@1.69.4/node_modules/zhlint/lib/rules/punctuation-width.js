"use strict";
/**
 * @fileoverview
 *
 * This rule will format each punctuation into the right width options.
 *
 * Options:
 * - halfWidthPunctuation: string = `()`
 * - fullWidthPunctuation: string = `，。：；？！“”‘’`
 * - adjustedFullWidthPunctuation: string = `“”‘’`
 *
 * Details:
 * - skip half-width punctuations between half-width content without space
 * - skip successive multiple half-width punctuations
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultConfig = void 0;
const parser_1 = require("../parser");
const messages_1 = require("./messages");
const util_1 = require("./util");
const widthPairList = [
    [`(`, `（`],
    [`)`, `）`],
    [`,`, `，`],
    [`.`, `。`],
    [`;`, `；`],
    [`:`, `：`],
    [`?`, `？`],
    [`!`, `！`]
];
const widthSidePairList = [
    [`"`, `“`, `”`],
    [`'`, `‘`, `’`]
];
const defaultHalfWidthOption = `()`;
const defaultFullWidthOption = `，。：；？！“”‘’`;
const defaultAdjustedFullWidthOption = `“”‘’`;
const checkAdjusted = (token, adjusted) => {
    if (adjusted.indexOf(token.modifiedContent) >= 0) {
        token.modifiedType = parser_1.CharType.PUNCTUATION_HALF;
    }
};
const parseOptions = (options) => {
    const halfWidthOption = (options === null || options === void 0 ? void 0 : options.halfWidthPunctuation) || '';
    const fullWidthOption = (options === null || options === void 0 ? void 0 : options.fullWidthPunctuation) || '';
    const adjustedFullWidthOption = (options === null || options === void 0 ? void 0 : options.adjustedFullWidthPunctuation) || '';
    const halfWidthMap = {};
    const fullWidthMap = {};
    const fullWidthPairMap = {};
    widthPairList.forEach(([halfWidth, fullWidth]) => {
        if (halfWidthOption.indexOf(halfWidth) >= 0) {
            halfWidthMap[fullWidth] = halfWidth;
        }
        if (fullWidthOption.indexOf(fullWidth) >= 0) {
            fullWidthMap[halfWidth] = fullWidth;
        }
    });
    widthSidePairList.forEach(([half, left, right]) => {
        if (halfWidthOption.indexOf(half) >= 0) {
            halfWidthMap[left] = half;
            halfWidthMap[right] = half;
        }
        if (fullWidthOption.indexOf(left) >= 0 ||
            fullWidthOption.indexOf(right) >= 0) {
            fullWidthPairMap[half] = [left, right];
        }
    });
    return {
        halfWidthMap,
        fullWidthMap,
        fullWidthPairMap,
        adjusted: adjustedFullWidthOption
    };
};
const generateHandler = (options) => {
    const { halfWidthMap, fullWidthMap, fullWidthPairMap, adjusted } = parseOptions(options);
    const handleHyperSpaceOption = (token, _, group) => {
        // skip non-punctuation/quote/bracket situations
        if (!(0, parser_1.isPunctuationType)(token.type) &&
            token.type !== parser_1.HyperTokenType.HYPER_WRAPPER_BRACKET &&
            token.type !== parser_1.GroupTokenType.GROUP) {
            return;
        }
        // skip half-width punctuations between half-width content without space
        if ((0, util_1.isHalfWidthPunctuationWithoutSpaceAround)(group, token)) {
            return;
        }
        // skip successive multiple half-width punctuations
        if ((0, util_1.isSuccessiveHalfWidthPunctuation)(group, token)) {
            return;
        }
        // 1. normal punctuations in the alter width map
        // 2. brackets in the alter width map
        if ((0, parser_1.isPunctuationType)(token.type) ||
            token.type === parser_1.HyperTokenType.HYPER_WRAPPER_BRACKET) {
            const content = token.modifiedContent;
            if (fullWidthMap[content]) {
                (0, util_1.checkContent)(token, fullWidthMap[content], parser_1.CharType.PUNCTUATION_FULL, messages_1.PUNCTUATION_FULL_WIDTH);
                checkAdjusted(token, adjusted);
            }
            else if (halfWidthMap[content]) {
                (0, util_1.checkContent)(token, halfWidthMap[content], parser_1.CharType.PUNCTUATION_HALF, messages_1.PUNCTUATION_HALF_WIDTH);
            }
            return;
        }
        // 3. quotes in the alter pair map
        const startContent = token.modifiedStartContent;
        const endContent = token.modifiedEndContent;
        if (fullWidthPairMap[startContent]) {
            (0, util_1.checkStartContent)(token, fullWidthPairMap[startContent][0], messages_1.PUNCTUATION_FULL_WIDTH);
        }
        else if (halfWidthMap[startContent]) {
            (0, util_1.checkStartContent)(token, halfWidthMap[startContent][0], messages_1.PUNCTUATION_HALF_WIDTH);
        }
        if (fullWidthPairMap[endContent]) {
            (0, util_1.checkEndContent)(token, fullWidthPairMap[endContent][1], messages_1.PUNCTUATION_FULL_WIDTH);
        }
        else if (halfWidthMap[endContent]) {
            (0, util_1.checkEndContent)(token, halfWidthMap[endContent][1], messages_1.PUNCTUATION_HALF_WIDTH);
        }
    };
    return handleHyperSpaceOption;
};
exports.defaultConfig = {
    halfWidthPunctuation: defaultHalfWidthOption,
    fullWidthPunctuation: defaultFullWidthOption,
    adjustedFullWidthPunctuation: defaultAdjustedFullWidthOption
};
exports.default = generateHandler;
