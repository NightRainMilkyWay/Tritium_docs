"use strict";
/**
 * @fileoverview
 *
 * This rule is checking spaces besides normal punctuations.
 * Usually, for full-width punctuations, we don't need any spaces around.
 * For half-width punctuations, we need a space after that.
 *
 * Options
 * - noSpaceBeforePunctuation: boolean | undefined
 *   - `true`: remove spaces before a half-width punctuation (default)
 *   - `false` or `undefined`: do nothing, just keep the original format
 * - spaceAfterHalfWidthPunctuation: boolean | undefined
 *   - `true`: ensure one space after a half-width punctuation (default)
 *   - `false` or `undefined`: do nothing, just keep the original format
 * - noSpaceAfterFullWidthPunctuation: boolean | undefined
 *   - `true`: remove spaces around a full-width punctuation (default)
 *   - `false` or `undefined`: do nothing, just keep the original format
 *
 * Details:
 * - noSpaceBeforePunctuation:
 *   content/right-quote/right-bracket/code x punctuation
 * - spaceAfterHalfWidthPunctuation:
 *   half x content/left-quote/left-bracket/code
 * - noSpaceAfterFullWidthPunctuation:
 *   full x content/left-quote/left-bracket/code
 *
 * - skip half-width punctuations between half-width content without space
 * - skip successive multiple half-width punctuations
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultConfig = void 0;
const parser_1 = require("../parser");
const util_1 = require("./util");
const messages_1 = require("./messages");
const normalPunctuationList = `,.;:?!，、。；：？！`.split('');
const isNormalPunctuation = (char) => normalPunctuationList.indexOf(char) >= 0;
const generateHandler = (options) => {
    const noBeforePunctuationOption = options === null || options === void 0 ? void 0 : options.noSpaceBeforePunctuation;
    const oneAfterHalfWidthPunctuationOption = options === null || options === void 0 ? void 0 : options.spaceAfterHalfWidthPunctuation;
    const noAfterFullWidthPunctuationOption = options === null || options === void 0 ? void 0 : options.noSpaceAfterFullWidthPunctuation;
    return (token, _, group) => {
        // skip non-punctuation tokens and non-normal punctuations
        if (!(0, parser_1.isPunctuationType)(token.type)) {
            return;
        }
        if (!isNormalPunctuation(token.content)) {
            return;
        }
        // skip half-width punctuations between half-width content without space
        if ((0, util_1.isHalfWidthPunctuationWithoutSpaceAround)(group, token)) {
            return;
        }
        // skip successive multiple half-width punctuations
        if ((0, util_1.isSuccessiveHalfWidthPunctuation)(group, token)) {
            return;
        }
        // 1. content/right-quote/right-bracket/code x punctuation
        if (noBeforePunctuationOption) {
            const contentTokenBefore = (0, util_1.findVisibleTokenBefore)(group, token);
            if (contentTokenBefore &&
                // content
                ((0, parser_1.isLettersType)(contentTokenBefore.type) ||
                    // right-quote
                    contentTokenBefore.type === parser_1.GroupTokenType.GROUP ||
                    // right-bracket
                    (contentTokenBefore.type === parser_1.HyperTokenType.HYPER_WRAPPER_BRACKET &&
                        contentTokenBefore.markSide === parser_1.MarkSideType.RIGHT) ||
                    // code
                    contentTokenBefore.type === parser_1.HyperTokenType.HYPER_CONTENT_CODE)) {
                const { spaceHost } = (0, util_1.findWrappersBetween)(group, contentTokenBefore, token);
                if (spaceHost) {
                    (0, util_1.checkSpaceAfter)(spaceHost, '', messages_1.PUNCTUATION_NOSPACE_BEFORE);
                }
            }
        }
        // 2. half/full x content/left-quote/left-bracket/code
        if ((token.modifiedType === parser_1.CharType.PUNCTUATION_FULL &&
            noAfterFullWidthPunctuationOption) ||
            (token.modifiedType === parser_1.CharType.PUNCTUATION_HALF &&
                oneAfterHalfWidthPunctuationOption)) {
            const spaceAfter = token.modifiedType === parser_1.CharType.PUNCTUATION_HALF ? ' ' : '';
            const message = token.modifiedType === parser_1.CharType.PUNCTUATION_HALF
                ? messages_1.PUNCTUATION_SPACE_AFTER
                : messages_1.PUNCTUATION_NOSPACE_AFTER;
            const contentTokenAfter = (0, util_1.findVisibleTokenAfter)(group, token);
            if (contentTokenAfter &&
                // content
                ((0, parser_1.isLettersType)(contentTokenAfter.type) ||
                    // left-quote
                    contentTokenAfter.type === parser_1.GroupTokenType.GROUP ||
                    // left-bracket
                    (contentTokenAfter.type === parser_1.HyperTokenType.HYPER_WRAPPER_BRACKET &&
                        contentTokenAfter.markSide === parser_1.MarkSideType.LEFT) ||
                    // code
                    contentTokenAfter.type === parser_1.HyperTokenType.HYPER_CONTENT_CODE)) {
                const { spaceHost } = (0, util_1.findWrappersBetween)(group, token, contentTokenAfter);
                if (spaceHost) {
                    (0, util_1.checkSpaceAfter)(spaceHost, spaceAfter, message);
                }
            }
        }
    };
};
exports.defaultConfig = {
    noSpaceBeforePunctuation: true,
    spaceAfterHalfWidthPunctuation: true,
    noSpaceAfterFullWidthPunctuation: true
};
exports.default = generateHandler;
