'use strict'
/**
 * @fileoverview
 *
 * This rule is used to check whether there should be a space between
 * content.
 *
 * Options:
 * - spaceBetweenHalfWidthContent: boolean | undefined
 *   - `true`: ensure one space between half-width content (default)
 *   - `false` or `undefined`: do nothing, just keep the original format
 * - noSpaceBetweenFullWidthContent: boolean | undefined
 *   - `true`: remove the space between full-width content (default)
 *   - `false` or `undefined`: do nothing, just keep the original format
 * - spaceBetweenMixedWidthContent: boolean | undefined
 *   - `true`: keep one space between width-mixed content (default)
 *   - `false`: no space between width-mixed content
 *   - `undefined`: do nothing, just keep the original format
 *
 * Examples (betweenMixedWidthContent = true):
 * - *a*啊 -> *a* 啊
 * - *a *啊 -> *a* 啊
 * - *啊*a -> *啊* a
 * - *啊 *a -> *啊* a
 *
 * Examples (betweenMixedWidthContent = false):
 * - *a* 啊 -> *a*啊
 * - *a *啊 -> *a*啊
 * - *啊* a -> *啊*a
 * - *啊 *a -> *啊*a
 */
Object.defineProperty(exports, '__esModule', { value: true })
exports.defaultConfig = void 0
const parser_1 = require('../parser')
const util_1 = require('./util')
const messages_1 = require('./messages')
const generateHandler = (options) => {
  const onlyOneBetweenHalfWidthContentOption =
    options === null || options === void 0
      ? void 0
      : options.spaceBetweenHalfWidthContent
  const noBetweenFullWidthContentOption =
    options === null || options === void 0
      ? void 0
      : options.noSpaceBetweenFullWidthContent
  const betweenMixedWidthContentOption =
    options === null || options === void 0
      ? void 0
      : options.spaceBetweenMixedWidthContent
  return (token, _, group) => {
    // skip non-content tokens
    if (!(0, parser_1.isContentType)(token.type)) {
      return
    }
    // skip non-content after-tokens
    const contentTokenAfter = (0, util_1.findExpectedVisibleTokenAfter)(
      group,
      token
    )
    if (
      !contentTokenAfter ||
      !(0, parser_1.isContentType)(contentTokenAfter.type)
    ) {
      return
    }
    // find the space host
    const { spaceHost, tokenSeq } = (0, util_1.findMarkSeqBetween)(
      group,
      token,
      contentTokenAfter
    )
    // skip if the space host is not found
    if (!spaceHost) {
      return
    }
    // 1. half x half, full x full
    // 2. half x full, full x half
    if (contentTokenAfter.type === token.type) {
      // skip without custom option
      if (token.type === parser_1.CharType.CONTENT_HALF) {
        if (!onlyOneBetweenHalfWidthContentOption) {
          return
        }
        // skip if half-content x marks x half-content
        if (
          tokenSeq.length > 1 &&
          tokenSeq.filter((token) => token.spaceAfter).length === 0
        ) {
          return
        }
      } else {
        if (!noBetweenFullWidthContentOption) {
          return
        }
      }
      const spaceAfter =
        token.type === parser_1.CharType.CONTENT_HALF ? ' ' : ''
      const message =
        token.type === parser_1.CharType.CONTENT_HALF
          ? messages_1.CONTENT_SPACE_HALF_WIDTH
          : messages_1.CONTENT_NOSPACE_FULL_WIDTH
      ;(0, util_1.checkSpaceAfter)(spaceHost, spaceAfter, message)
    } else {
      // skip without custom option
      if (typeof betweenMixedWidthContentOption === 'undefined') {
        return
      }
      const spaceAfter = betweenMixedWidthContentOption ? ' ' : ''
      const message = betweenMixedWidthContentOption
        ? messages_1.CONTENT_SPACE_MIXED_WIDTH
        : messages_1.CONTENT_NOSPACE_MIXED_WIDTH
      ;(0, util_1.checkSpaceAfter)(spaceHost, spaceAfter, message)
    }
  }
}
exports.defaultConfig = {
  spaceBetweenHalfWidthContent: true,
  noSpaceBetweenFullWidthContent: true,
  spaceBetweenMixedWidthContent: true
}
exports.default = generateHandler
