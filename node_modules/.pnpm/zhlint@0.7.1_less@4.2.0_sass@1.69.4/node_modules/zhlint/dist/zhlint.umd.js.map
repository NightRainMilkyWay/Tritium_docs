{"version":3,"file":"zhlint.umd.js","sources":["../src/hypers/ignore.ts","../src/hypers/hexo.ts","../src/hypers/vuepress.ts","../node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js","../node_modules/.pnpm/bail@1.0.5/node_modules/bail/index.js","../node_modules/.pnpm/unist-util-stringify-position@2.0.3/node_modules/unist-util-stringify-position/index.js","../node_modules/.pnpm/vfile-message@2.0.4/node_modules/vfile-message/index.js","../node_modules/.pnpm/vfile@4.2.1/node_modules/vfile/lib/minpath.browser.js","../node_modules/.pnpm/vfile@4.2.1/node_modules/vfile/lib/minproc.browser.js","../node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js","../node_modules/.pnpm/vfile@4.2.1/node_modules/vfile/lib/core.js","../node_modules/.pnpm/vfile@4.2.1/node_modules/vfile/lib/index.js","../node_modules/.pnpm/vfile@4.2.1/node_modules/vfile/index.js","../node_modules/.pnpm/trough@1.0.5/node_modules/trough/wrap.js","../node_modules/.pnpm/trough@1.0.5/node_modules/trough/index.js","../node_modules/.pnpm/is-plain-obj@2.1.0/node_modules/is-plain-obj/index.js","../node_modules/.pnpm/unified@8.4.2/node_modules/unified/index.js","../node_modules/.pnpm/xtend@4.0.2/node_modules/xtend/immutable.js","../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js","../node_modules/.pnpm/unherit@1.1.3/node_modules/unherit/index.js","../node_modules/.pnpm/state-toggle@1.0.3/node_modules/state-toggle/index.js","../node_modules/.pnpm/vfile-location@2.0.6/node_modules/vfile-location/index.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/unescape.js","../node_modules/.pnpm/is-decimal@1.0.4/node_modules/is-decimal/index.js","../node_modules/.pnpm/is-hexadecimal@1.0.4/node_modules/is-hexadecimal/index.js","../node_modules/.pnpm/is-alphabetical@1.0.4/node_modules/is-alphabetical/index.js","../node_modules/.pnpm/is-alphanumerical@1.0.4/node_modules/is-alphanumerical/index.js","../node_modules/.pnpm/parse-entities@1.2.2/node_modules/parse-entities/decode-entity.browser.js","../node_modules/.pnpm/parse-entities@1.2.2/node_modules/parse-entities/index.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/decode.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenizer.js","../node_modules/.pnpm/markdown-escapes@1.0.4/node_modules/markdown-escapes/index.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/block-elements.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/defaults.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/set-options.js","../node_modules/.pnpm/unist-util-is@3.0.0/node_modules/unist-util-is/convert.js","../node_modules/.pnpm/unist-util-visit-parents@2.1.2/node_modules/unist-util-visit-parents/index.js","../node_modules/.pnpm/unist-util-visit@1.4.1/node_modules/unist-util-visit/index.js","../node_modules/.pnpm/unist-util-remove-position@1.1.4/node_modules/unist-util-remove-position/index.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/parse.js","../node_modules/.pnpm/is-whitespace-character@1.0.4/node_modules/is-whitespace-character/index.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/newline.js","../node_modules/.pnpm/repeat-string@1.6.1/node_modules/repeat-string/index.js","../node_modules/.pnpm/trim-trailing-lines@1.1.4/node_modules/trim-trailing-lines/index.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/code-indented.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/code-fenced.js","../node_modules/.pnpm/trim@0.0.1/node_modules/trim/index.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/util/interrupt.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/blockquote.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/heading-atx.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/thematic-break.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/util/get-indentation.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/util/remove-indentation.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/list.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/heading-setext.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/util/html.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/html-block.js","../node_modules/.pnpm/collapse-white-space@1.0.6/node_modules/collapse-white-space/index.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/util/normalize.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/footnote-definition.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/definition.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/table.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/paragraph.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/locate/escape.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/escape.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/locate/tag.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/auto-link.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/locate/url.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/url.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/html-inline.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/locate/link.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/link.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/reference.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/locate/strong.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/strong.js","../node_modules/.pnpm/is-word-character@1.0.4/node_modules/is-word-character/index.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/locate/emphasis.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/emphasis.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/locate/delete.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/delete.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/locate/code-inline.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/code-inline.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/locate/break.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/break.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/tokenize/text.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/lib/parser.js","../node_modules/.pnpm/remark-parse@7.0.2/node_modules/remark-parse/index.js","../node_modules/.pnpm/format@0.2.2/node_modules/format/format.js","../node_modules/.pnpm/fault@1.0.4/node_modules/fault/index.js","../node_modules/.pnpm/remark-frontmatter@1.3.3/node_modules/remark-frontmatter/lib/matters.js","../node_modules/.pnpm/remark-frontmatter@1.3.3/node_modules/remark-frontmatter/lib/fence.js","../node_modules/.pnpm/remark-frontmatter@1.3.3/node_modules/remark-frontmatter/lib/parse.js","../node_modules/.pnpm/remark-frontmatter@1.3.3/node_modules/remark-frontmatter/lib/compile.js","../node_modules/.pnpm/remark-frontmatter@1.3.3/node_modules/remark-frontmatter/index.js","../src/parser/types.ts","../src/parser/char.ts","../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js","../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js","../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js","../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js","../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js","../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/browser.js","../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js","../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js","../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js","../src/report.ts","../src/parser/messages.ts","../src/parser/util.ts","../src/parser/parse.ts","../src/parser/travel.ts","../src/hypers/md.ts","../src/rules/messages.ts","../src/rules/util.ts","../src/rules/space-trim.ts","../src/rules/punctuation-width.ts","../src/rules/punctuation-unification.ts","../src/rules/case-abbrs.ts","../src/rules/space-wrapper.ts","../src/rules/space-code.ts","../src/rules/space-letters.ts","../src/rules/space-punctuation.ts","../src/rules/space-quote.ts","../src/rules/space-bracket.ts","../src/rules/case-linebreak.ts","../src/rules/case-zh-units.ts","../src/rules/case-html-entity.ts","../src/rules/index.ts","../src/options.ts","../src/ignore.ts","../src/join.ts","../src/replace-block.ts","../src/run.ts","../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js","../node_modules/.pnpm/node-stdlib-browser@1.2.0/node_modules/node-stdlib-browser/cjs/mock/empty.js","../src/rc/index.ts"],"sourcesContent":["import { IgnoredCase } from '../ignore'\nimport { ParsedStatus } from './types'\n\nconst ignoredCaseMatcher =\n  /^(?:(?<prefix>.+?)-,)?(?<textStart>.+?)(?:,(?<textEnd>.+?))?(?:,-(?<suffix>.+?))?$/\n\nexport const parseIngoredCase = (text: string): IgnoredCase | undefined => {\n  const matchResult = text.match(ignoredCaseMatcher)\n  if (matchResult) {\n    const { prefix, textStart, textEnd, suffix } =\n      matchResult.groups as IgnoredCase\n    return {\n      prefix,\n      textStart,\n      textEnd,\n      suffix\n    }\n  }\n}\n\nconst parser = (data: ParsedStatus): ParsedStatus => {\n  const { ignoredByRules, content: raw } = data\n  const matcher = /<!--\\s*zhlint\\s*ignore:\\s*(.+?)\\s*-->/g\n  let result: RegExpExecArray | null\n  while ((result = matcher.exec(raw)) !== null) {\n    const ignoredCase = parseIngoredCase(result[1])\n    if (ignoredCase) {\n      ignoredByRules.push(ignoredCase)\n    }\n  }\n  return data\n}\n\nexport default parser\n","import { ParsedStatus } from './types'\n\n// {% x y %}z{% endx %}\n// \\{\\% ([^ ]+?) [^\\%]*?\\%\\}    ([^ ]+?)        [^\\%]*?\n// (?:\\n|\\{(?!\\%)|[^\\{])*?      \\n              \\{(?!\\%)        [^\\{]\n// \\{\\% end(?:\\1) \\%\\}\nconst matcher = /\\{% ([^ ]+?) [^%]*?%\\}(?:\\n|\\{(?!%)|[^{])*?\\{% end(?:\\1) %\\}/g\n\nconst parser = (data: ParsedStatus): ParsedStatus => {\n  data.modifiedContent = data.modifiedContent.replace(\n    matcher,\n    (raw, name, index) => {\n      const { length } = raw\n      data.ignoredByParsers.push({\n        name,\n        meta: `hexo-${name}`,\n        index,\n        length,\n        originContent: raw\n      })\n      return '@'.repeat(length)\n    }\n  )\n  return data\n}\n\nexport default parser\n","import { ParsedStatus } from './types'\n\n// TODO: ::: tips 提示...\n//\n// ::: xxx\\nyyy\\nzzz\\n:::\\n\n// - `(?<=^|\\n)` + `(:::.*)`\n// - `\\n`\n// - `(.+)`\n// - `\\n`\n// - `(:::)` + `(?=\\n|$)`\nlet matcher: RegExp\n\ntry {\n  matcher = new RegExp('(?<=^|\\\\n)(:::.*)\\\\n([\\\\s\\\\S]+?)\\\\n(:::)(?=\\\\n|$)', 'g')\n} catch {\n  matcher = /(:::.*)\\n([\\s\\S]+?)\\n(:::)/g\n}\n\nconst parser = (data: ParsedStatus): ParsedStatus => {\n  data.modifiedContent = data.modifiedContent.replace(\n    matcher,\n    (\n      raw: string,\n      start: string,\n      content: string,\n      end: string,\n      index: number\n    ) => {\n      const { length } = raw\n      const name = start.substring(3).trim().split(' ')[0] || 'default'\n      data.ignoredByParsers.push({\n        name,\n        index,\n        length: start.length,\n        originContent: start,\n        meta: `vuepress-${name}-start`\n      })\n      data.ignoredByParsers.push({\n        name,\n        index: index + length - 3,\n        length: 3,\n        originContent: end,\n        meta: `vuepress-${name}-end`\n      })\n      return '@'.repeat(start.length) + '\\n' + content + '\\n' + '@'.repeat(3)\n    }\n  )\n  return data\n}\n\nexport default parser\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","'use strict'\n\nmodule.exports = bail\n\nfunction bail(err) {\n  if (err) {\n    throw err\n  }\n}\n","'use strict'\n\nvar own = {}.hasOwnProperty\n\nmodule.exports = stringify\n\nfunction stringify(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if (own.call(value, 'position') || own.call(value, 'type')) {\n    return position(value.position)\n  }\n\n  // Position.\n  if (own.call(value, 'start') || own.call(value, 'end')) {\n    return position(value)\n  }\n\n  // Point.\n  if (own.call(value, 'line') || own.call(value, 'column')) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\nfunction point(point) {\n  if (!point || typeof point !== 'object') {\n    point = {}\n  }\n\n  return index(point.line) + ':' + index(point.column)\n}\n\nfunction position(pos) {\n  if (!pos || typeof pos !== 'object') {\n    pos = {}\n  }\n\n  return point(pos.start) + '-' + point(pos.end)\n}\n\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","'use strict'\n\nvar stringify = require('unist-util-stringify-position')\n\nmodule.exports = VMessage\n\n// Inherit from `Error#`.\nfunction VMessagePrototype() {}\nVMessagePrototype.prototype = Error.prototype\nVMessage.prototype = new VMessagePrototype()\n\n// Message properties.\nvar proto = VMessage.prototype\n\nproto.file = ''\nproto.name = ''\nproto.reason = ''\nproto.message = ''\nproto.stack = ''\nproto.fatal = null\nproto.column = null\nproto.line = null\n\n// Construct a new VMessage.\n//\n// Note: We cannot invoke `Error` on the created context, as that adds readonly\n// `line` and `column` attributes on Safari 9, thus throwing and failing the\n// data.\nfunction VMessage(reason, position, origin) {\n  var parts\n  var range\n  var location\n\n  if (typeof position === 'string') {\n    origin = position\n    position = null\n  }\n\n  parts = parseOrigin(origin)\n  range = stringify(position) || '1:1'\n\n  location = {\n    start: {line: null, column: null},\n    end: {line: null, column: null}\n  }\n\n  // Node.\n  if (position && position.position) {\n    position = position.position\n  }\n\n  if (position) {\n    // Position.\n    if (position.start) {\n      location = position\n      position = position.start\n    } else {\n      // Point.\n      location.start = position\n    }\n  }\n\n  if (reason.stack) {\n    this.stack = reason.stack\n    reason = reason.message\n  }\n\n  this.message = reason\n  this.name = range\n  this.reason = reason\n  this.line = position ? position.line : null\n  this.column = position ? position.column : null\n  this.location = location\n  this.source = parts[0]\n  this.ruleId = parts[1]\n}\n\nfunction parseOrigin(origin) {\n  var result = [null, null]\n  var index\n\n  if (typeof origin === 'string') {\n    index = origin.indexOf(':')\n\n    if (index === -1) {\n      result[1] = origin\n    } else {\n      result[0] = origin.slice(0, index)\n      result[1] = origin.slice(index + 1)\n    }\n  }\n\n  return result\n}\n","'use strict'\n\n// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node’s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexports.basename = basename\nexports.dirname = dirname\nexports.extname = extname\nexports.join = join\nexports.sep = '/'\n\nfunction basename(path, ext) {\n  var start = 0\n  var end = -1\n  var index\n  var firstNonSlashEnd\n  var seenNonSlash\n  var extIndex\n\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  index = path.length\n\n  if (ext === undefined || !ext.length || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  firstNonSlashEnd = -1\n  extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\nfunction dirname(path) {\n  var end\n  var unmatchedSlash\n  var index\n\n  assertPath(path)\n\n  if (!path.length) {\n    return '.'\n  }\n\n  end = -1\n  index = path.length\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\nfunction extname(path) {\n  var startDot = -1\n  var startPart = 0\n  var end = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  var preDotState = 0\n  var unmatchedSlash\n  var code\n  var index\n\n  assertPath(path)\n\n  index = path.length\n\n  while (index--) {\n    code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\nfunction join() {\n  var index = -1\n  var joined\n\n  while (++index < arguments.length) {\n    assertPath(arguments[index])\n\n    if (arguments[index]) {\n      joined =\n        joined === undefined\n          ? arguments[index]\n          : joined + '/' + arguments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  var absolute\n  var value\n\n  assertPath(path)\n\n  absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  value = normalizeString(path, !absolute)\n\n  if (!value.length && !absolute) {\n    value = '.'\n  }\n\n  if (value.length && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n// Resolve `.` and `..` elements in a path with directory names.\nfunction normalizeString(path, allowAboveRoot) {\n  var result = ''\n  var lastSegmentLength = 0\n  var lastSlash = -1\n  var dots = 0\n  var index = -1\n  var code\n  var lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            /* istanbul ignore else - No clue how to cover it. */\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n","'use strict'\n\n// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I don’t think one tiny line of code can be copyrighted. 😅\nexports.cwd = cwd\n\nfunction cwd() {\n  return '/'\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","'use strict'\n\nvar p = require('./minpath')\nvar proc = require('./minproc')\nvar buffer = require('is-buffer')\n\nmodule.exports = VFile\n\nvar own = {}.hasOwnProperty\n\n// Order of setting (least specific to most), we need this because otherwise\n// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n// stem can be set.\nvar order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nVFile.prototype.toString = toString\n\n// Access full path (`~/index.min.js`).\nObject.defineProperty(VFile.prototype, 'path', {get: getPath, set: setPath})\n\n// Access parent path (`~`).\nObject.defineProperty(VFile.prototype, 'dirname', {\n  get: getDirname,\n  set: setDirname\n})\n\n// Access basename (`index.min.js`).\nObject.defineProperty(VFile.prototype, 'basename', {\n  get: getBasename,\n  set: setBasename\n})\n\n// Access extname (`.js`).\nObject.defineProperty(VFile.prototype, 'extname', {\n  get: getExtname,\n  set: setExtname\n})\n\n// Access stem (`index.min`).\nObject.defineProperty(VFile.prototype, 'stem', {get: getStem, set: setStem})\n\n// Construct a new file.\nfunction VFile(options) {\n  var prop\n  var index\n\n  if (!options) {\n    options = {}\n  } else if (typeof options === 'string' || buffer(options)) {\n    options = {contents: options}\n  } else if ('message' in options && 'messages' in options) {\n    return options\n  }\n\n  if (!(this instanceof VFile)) {\n    return new VFile(options)\n  }\n\n  this.data = {}\n  this.messages = []\n  this.history = []\n  this.cwd = proc.cwd()\n\n  // Set path related properties in the correct order.\n  index = -1\n\n  while (++index < order.length) {\n    prop = order[index]\n\n    if (own.call(options, prop)) {\n      this[prop] = options[prop]\n    }\n  }\n\n  // Set non-path related properties.\n  for (prop in options) {\n    if (order.indexOf(prop) < 0) {\n      this[prop] = options[prop]\n    }\n  }\n}\n\nfunction getPath() {\n  return this.history[this.history.length - 1]\n}\n\nfunction setPath(path) {\n  assertNonEmpty(path, 'path')\n\n  if (this.path !== path) {\n    this.history.push(path)\n  }\n}\n\nfunction getDirname() {\n  return typeof this.path === 'string' ? p.dirname(this.path) : undefined\n}\n\nfunction setDirname(dirname) {\n  assertPath(this.path, 'dirname')\n  this.path = p.join(dirname || '', this.basename)\n}\n\nfunction getBasename() {\n  return typeof this.path === 'string' ? p.basename(this.path) : undefined\n}\n\nfunction setBasename(basename) {\n  assertNonEmpty(basename, 'basename')\n  assertPart(basename, 'basename')\n  this.path = p.join(this.dirname || '', basename)\n}\n\nfunction getExtname() {\n  return typeof this.path === 'string' ? p.extname(this.path) : undefined\n}\n\nfunction setExtname(extname) {\n  assertPart(extname, 'extname')\n  assertPath(this.path, 'extname')\n\n  if (extname) {\n    if (extname.charCodeAt(0) !== 46 /* `.` */) {\n      throw new Error('`extname` must start with `.`')\n    }\n\n    if (extname.indexOf('.', 1) > -1) {\n      throw new Error('`extname` cannot contain multiple dots')\n    }\n  }\n\n  this.path = p.join(this.dirname, this.stem + (extname || ''))\n}\n\nfunction getStem() {\n  return typeof this.path === 'string'\n    ? p.basename(this.path, this.extname)\n    : undefined\n}\n\nfunction setStem(stem) {\n  assertNonEmpty(stem, 'stem')\n  assertPart(stem, 'stem')\n  this.path = p.join(this.dirname || '', stem + (this.extname || ''))\n}\n\n// Get the value of the file.\nfunction toString(encoding) {\n  return (this.contents || '').toString(encoding)\n}\n\n// Assert that `part` is not a path (i.e., does not contain `p.sep`).\nfunction assertPart(part, name) {\n  if (part && part.indexOf(p.sep) > -1) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + p.sep + '`'\n    )\n  }\n}\n\n// Assert that `part` is not empty.\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n// Assert `path` exists.\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n","'use strict'\n\nvar VMessage = require('vfile-message')\nvar VFile = require('./core.js')\n\nmodule.exports = VFile\n\nVFile.prototype.message = message\nVFile.prototype.info = info\nVFile.prototype.fail = fail\n\n// Create a message with `reason` at `position`.\n// When an error is passed in as `reason`, copies the stack.\nfunction message(reason, position, origin) {\n  var message = new VMessage(reason, position, origin)\n\n  if (this.path) {\n    message.name = this.path + ':' + message.name\n    message.file = this.path\n  }\n\n  message.fatal = false\n\n  this.messages.push(message)\n\n  return message\n}\n\n// Fail: creates a vmessage, associates it with the file, and throws it.\nfunction fail() {\n  var message = this.message.apply(this, arguments)\n\n  message.fatal = true\n\n  throw message\n}\n\n// Info: creates a vmessage, associates it with the file, and marks the fatality\n// as null.\nfunction info() {\n  var message = this.message.apply(this, arguments)\n\n  message.fatal = null\n\n  return message\n}\n","'use strict'\n\nmodule.exports = require('./lib')\n","'use strict'\n\nvar slice = [].slice\n\nmodule.exports = wrap\n\n// Wrap `fn`.\n// Can be sync or async; return a promise, receive a completion handler, return\n// new values and errors.\nfunction wrap(fn, callback) {\n  var invoked\n\n  return wrapped\n\n  function wrapped() {\n    var params = slice.call(arguments, 0)\n    var callback = fn.length > params.length\n    var result\n\n    if (callback) {\n      params.push(done)\n    }\n\n    try {\n      result = fn.apply(null, params)\n    } catch (error) {\n      // Well, this is quite the pickle.\n      // `fn` received a callback and invoked it (thus continuing the pipeline),\n      // but later also threw an error.\n      // We’re not about to restart the pipeline again, so the only thing left\n      // to do is to throw the thing instead.\n      if (callback && invoked) {\n        throw error\n      }\n\n      return done(error)\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  // Invoke `next`, only once.\n  function done() {\n    if (!invoked) {\n      invoked = true\n\n      callback.apply(null, arguments)\n    }\n  }\n\n  // Invoke `done` with one value.\n  // Tracks if an error is passed, too.\n  function then(value) {\n    done(null, value)\n  }\n}\n","'use strict'\n\nvar wrap = require('./wrap.js')\n\nmodule.exports = trough\n\ntrough.wrap = wrap\n\nvar slice = [].slice\n\n// Create new middleware.\nfunction trough() {\n  var fns = []\n  var middleware = {}\n\n  middleware.run = run\n  middleware.use = use\n\n  return middleware\n\n  // Run `fns`.  Last argument must be a completion handler.\n  function run() {\n    var index = -1\n    var input = slice.call(arguments, 0, -1)\n    var done = arguments[arguments.length - 1]\n\n    if (typeof done !== 'function') {\n      throw new Error('Expected function as last argument, not ' + done)\n    }\n\n    next.apply(null, [null].concat(input))\n\n    // Run the next `fn`, if any.\n    function next(err) {\n      var fn = fns[++index]\n      var params = slice.call(arguments, 0)\n      var values = params.slice(1)\n      var length = input.length\n      var pos = -1\n\n      if (err) {\n        done(err)\n        return\n      }\n\n      // Copy non-nully input into values.\n      while (++pos < length) {\n        if (values[pos] === null || values[pos] === undefined) {\n          values[pos] = input[pos]\n        }\n      }\n\n      input = values\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next).apply(null, input)\n      } else {\n        done.apply(null, [null].concat(input))\n      }\n    }\n  }\n\n  // Add `fn` to the list.\n  function use(fn) {\n    if (typeof fn !== 'function') {\n      throw new Error('Expected `fn` to be a function, not ' + fn)\n    }\n\n    fns.push(fn)\n\n    return middleware\n  }\n}\n","'use strict';\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n","'use strict'\n\nvar extend = require('extend')\nvar bail = require('bail')\nvar vfile = require('vfile')\nvar trough = require('trough')\nvar plain = require('is-plain-obj')\n\n// Expose a frozen processor.\nmodule.exports = unified().freeze()\n\nvar slice = [].slice\nvar own = {}.hasOwnProperty\n\n// Process pipeline.\nvar pipeline = trough()\n  .use(pipelineParse)\n  .use(pipelineRun)\n  .use(pipelineStringify)\n\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file)\n}\n\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done)\n\n  function done(err, tree, file) {\n    if (err) {\n      next(err)\n    } else {\n      ctx.tree = tree\n      ctx.file = file\n      next()\n    }\n  }\n}\n\nfunction pipelineStringify(p, ctx) {\n  ctx.file.contents = p.stringify(ctx.tree, ctx.file)\n}\n\n// Function to create the first processor.\nfunction unified() {\n  var attachers = []\n  var transformers = trough()\n  var namespace = {}\n  var frozen = false\n  var freezeIndex = -1\n\n  // Data management.\n  processor.data = data\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  processor.run = run\n  processor.runSync = runSync\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  function processor() {\n    var destination = unified()\n    var length = attachers.length\n    var index = -1\n\n    while (++index < length) {\n      destination.use.apply(null, attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  // Freeze: used to signal a processor that has finished configuration.\n  //\n  // For example, take unified itself: it’s frozen.\n  // Plugins should not be added to it.\n  // Rather, it should be extended, by invoking it, before modifying it.\n  //\n  // In essence, always invoke this when exporting a processor.\n  function freeze() {\n    var values\n    var plugin\n    var options\n    var transformer\n\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex]\n      plugin = values[0]\n      options = values[1]\n      transformer = null\n\n      if (options === false) {\n        continue\n      }\n\n      if (options === true) {\n        values[1] = undefined\n      }\n\n      transformer = plugin.apply(processor, values.slice(1))\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Infinity\n\n    return processor\n  }\n\n  // Data management.\n  // Getter / setter for processor-specific informtion.\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n\n        namespace[key] = value\n\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  // Plugin management.\n  //\n  // Pass it:\n  // *   an attacher and options,\n  // *   a preset,\n  // *   a list of presets, attachers, and arguments (list of attachers and\n  //     options).\n  function use(value) {\n    var settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments)\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings)\n      }\n    }\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    function addList(plugins) {\n      var length\n      var index\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        length = plugins.length\n        index = -1\n\n        while (++index < length) {\n          add(plugins[index])\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    function addPlugin(plugin, value) {\n      var entry = find(plugin)\n\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        attachers.push(slice.call(arguments))\n      }\n    }\n  }\n\n  function find(plugin) {\n    var length = attachers.length\n    var index = -1\n    var entry\n\n    while (++index < length) {\n      entry = attachers[index]\n\n      if (entry[0] === plugin) {\n        return entry\n      }\n    }\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor.\n  function parse(doc) {\n    var file = vfile(doc)\n    var Parser\n\n    freeze()\n    Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      return new Parser(String(file), file).parse()\n    }\n\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), async.\n  function run(node, file, cb) {\n    assertNode(node)\n    freeze()\n\n    if (!cb && typeof file === 'function') {\n      cb = file\n      file = null\n    }\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done)\n\n      function done(err, tree, file) {\n        tree = tree || node\n        if (err) {\n          reject(err)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          cb(null, tree, file)\n        }\n      }\n    }\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), sync.\n  function runSync(node, file) {\n    var complete = false\n    var result\n\n    run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    return result\n\n    function done(err, tree) {\n      complete = true\n      bail(err)\n      result = tree\n    }\n  }\n\n  // Stringify a unist node representation of a file (in string or vfile\n  // representation) into a string using the `Compiler` on the processor.\n  function stringify(node, doc) {\n    var file = vfile(doc)\n    var Compiler\n\n    freeze()\n    Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      return new Compiler(node, file).compile()\n    }\n\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor, then run transforms on that node, and\n  // compile the resulting node using the `Compiler` on the processor, and\n  // store that result on the vfile.\n  function process(doc, cb) {\n    freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      var file = vfile(doc)\n\n      pipeline.run(processor, {file: file}, done)\n\n      function done(err) {\n        if (err) {\n          reject(err)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          cb(null, file)\n        }\n      }\n    }\n  }\n\n  // Process the given document (in string or vfile representation), sync.\n  function processSync(doc) {\n    var complete = false\n    var file\n\n    freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n    file = vfile(doc)\n\n    process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    function done(err) {\n      complete = true\n      bail(err)\n    }\n  }\n}\n\n// Check if `value` is a constructor.\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n// Check if `value` is an object with keys.\nfunction keys(value) {\n  var key\n  for (key in value) {\n    return true\n  }\n\n  return false\n}\n\n// Assert a parser is available.\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n// Assert a compiler is available.\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n// Assert the processor is not frozen.\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot invoke `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n// Assert `node` is a unist node.\nfunction assertNode(node) {\n  if (!node || typeof node.type !== 'string') {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n}\n\n// Assert that `complete` is `true`.\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict'\n\nvar xtend = require('xtend')\nvar inherits = require('inherits')\n\nmodule.exports = unherit\n\n// Create a custom constructor which can be modified without affecting the\n// original class.\nfunction unherit(Super) {\n  var result\n  var key\n  var value\n\n  inherits(Of, Super)\n  inherits(From, Of)\n\n  // Clone values.\n  result = Of.prototype\n\n  for (key in result) {\n    value = result[key]\n\n    if (value && typeof value === 'object') {\n      result[key] = 'concat' in value ? value.concat() : xtend(value)\n    }\n  }\n\n  return Of\n\n  // Constructor accepting a single argument, which itself is an `arguments`\n  // object.\n  function From(parameters) {\n    return Super.apply(this, parameters)\n  }\n\n  // Constructor accepting variadic arguments.\n  function Of() {\n    if (!(this instanceof Of)) {\n      return new From(arguments)\n    }\n\n    return Super.apply(this, arguments)\n  }\n}\n","'use strict'\n\nmodule.exports = factory\n\n// Construct a state `toggler`: a function which inverses `property` in context\n// based on its current value.\n// The by `toggler` returned function restores that value.\nfunction factory(key, state, ctx) {\n  return enter\n\n  function enter() {\n    var context = ctx || this\n    var current = context[key]\n\n    context[key] = !state\n\n    return exit\n\n    function exit() {\n      context[key] = current\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = factory\n\nfunction factory(file) {\n  var contents = indices(String(file))\n\n  return {\n    toPosition: offsetToPositionFactory(contents),\n    toOffset: positionToOffsetFactory(contents)\n  }\n}\n\n// Factory to get the line and column-based `position` for `offset` in the bound\n// indices.\nfunction offsetToPositionFactory(indices) {\n  return offsetToPosition\n\n  // Get the line and column-based `position` for `offset` in the bound indices.\n  function offsetToPosition(offset) {\n    var index = -1\n    var length = indices.length\n\n    if (offset < 0) {\n      return {}\n    }\n\n    while (++index < length) {\n      if (indices[index] > offset) {\n        return {\n          line: index + 1,\n          column: offset - (indices[index - 1] || 0) + 1,\n          offset: offset\n        }\n      }\n    }\n\n    return {}\n  }\n}\n\n// Factory to get the `offset` for a line and column-based `position` in the\n// bound indices.\nfunction positionToOffsetFactory(indices) {\n  return positionToOffset\n\n  // Get the `offset` for a line and column-based `position` in the bound\n  // indices.\n  function positionToOffset(position) {\n    var line = position && position.line\n    var column = position && position.column\n\n    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {\n      return (indices[line - 2] || 0) + column - 1 || 0\n    }\n\n    return -1\n  }\n}\n\n// Get indices of line-breaks in `value`.\nfunction indices(value) {\n  var result = []\n  var index = value.indexOf('\\n')\n\n  while (index !== -1) {\n    result.push(index + 1)\n    index = value.indexOf('\\n', index + 1)\n  }\n\n  result.push(value.length + 1)\n\n  return result\n}\n","'use strict'\n\nmodule.exports = factory\n\nvar backslash = '\\\\'\n\n// Factory to de-escape a value, based on a list at `key` in `ctx`.\nfunction factory(ctx, key) {\n  return unescape\n\n  // De-escape a string using the expression at `key` in `ctx`.\n  function unescape(value) {\n    var prev = 0\n    var index = value.indexOf(backslash)\n    var escape = ctx[key]\n    var queue = []\n    var character\n\n    while (index !== -1) {\n      queue.push(value.slice(prev, index))\n      prev = index + 1\n      character = value.charAt(prev)\n\n      // If the following character is not a valid escape, add the slash.\n      if (!character || escape.indexOf(character) === -1) {\n        queue.push(backslash)\n      }\n\n      index = value.indexOf(backslash, prev + 1)\n    }\n\n    queue.push(value.slice(prev))\n\n    return queue.join('')\n  }\n}\n","'use strict'\n\nmodule.exports = decimal\n\n// Check if the given character code, or the character code at the first\n// character, is decimal.\nfunction decimal(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return code >= 48 && code <= 57 /* 0-9 */\n}\n","'use strict'\n\nmodule.exports = hexadecimal\n\n// Check if the given character code, or the character code at the first\n// character, is hexadecimal.\nfunction hexadecimal(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 /* a */ && code <= 102) /* z */ ||\n    (code >= 65 /* A */ && code <= 70) /* Z */ ||\n    (code >= 48 /* A */ && code <= 57) /* Z */\n  )\n}\n","'use strict'\n\nmodule.exports = alphabetical\n\n// Check if the given character code, or the character code at the first\n// character, is alphabetical.\nfunction alphabetical(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 && code <= 122) /* a-z */ ||\n    (code >= 65 && code <= 90) /* A-Z */\n  )\n}\n","'use strict'\n\nvar alphabetical = require('is-alphabetical')\nvar decimal = require('is-decimal')\n\nmodule.exports = alphanumerical\n\n// Check if the given character code, or the character code at the first\n// character, is alphanumerical.\nfunction alphanumerical(character) {\n  return alphabetical(character) || decimal(character)\n}\n","'use strict'\n\n/* eslint-env browser */\n\nvar el\n\nvar semicolon = 59 //  ';'\n\nmodule.exports = decodeEntity\n\nfunction decodeEntity(characters) {\n  var entity = '&' + characters + ';'\n  var char\n\n  el = el || document.createElement('i')\n  el.innerHTML = entity\n  char = el.textContent\n\n  // Some entities do not require the closing semicolon (`&not` - for instance),\n  // which leads to situations where parsing the assumed entity of &notit; will\n  // result in the string `¬it;`.  When we encounter a trailing semicolon after\n  // parsing and the entity to decode was not a semicolon (`&semi;`), we can\n  // assume that the matching was incomplete\n  if (char.charCodeAt(char.length - 1) === semicolon && characters !== 'semi') {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the entity was not valid\n  return char === entity ? false : char\n}\n","'use strict'\n\nvar legacy = require('character-entities-legacy')\nvar invalid = require('character-reference-invalid')\nvar decimal = require('is-decimal')\nvar hexadecimal = require('is-hexadecimal')\nvar alphanumerical = require('is-alphanumerical')\nvar decodeEntity = require('./decode-entity')\n\nmodule.exports = parseEntities\n\nvar own = {}.hasOwnProperty\nvar fromCharCode = String.fromCharCode\nvar noop = Function.prototype\n\n// Default settings.\nvar defaults = {\n  warning: null,\n  reference: null,\n  text: null,\n  warningContext: null,\n  referenceContext: null,\n  textContext: null,\n  position: {},\n  additional: null,\n  attribute: false,\n  nonTerminated: true\n}\n\n// Characters.\nvar tab = 9 // '\\t'\nvar lineFeed = 10 // '\\n'\nvar formFeed = 12 //  '\\f'\nvar space = 32 // ' '\nvar ampersand = 38 //  '&'\nvar semicolon = 59 //  ';'\nvar lessThan = 60 //  '<'\nvar equalsTo = 61 //  '='\nvar numberSign = 35 //  '#'\nvar uppercaseX = 88 //  'X'\nvar lowercaseX = 120 //  'x'\nvar replacementCharacter = 65533 // '�'\n\n// Reference types.\nvar name = 'named'\nvar hexa = 'hexadecimal'\nvar deci = 'decimal'\n\n// Map of bases.\nvar bases = {}\n\nbases[hexa] = 16\nbases[deci] = 10\n\n// Map of types to tests.\n// Each type of character reference accepts different characters.\n// This test is used to detect whether a reference has ended (as the semicolon\n// is not strictly needed).\nvar tests = {}\n\ntests[name] = alphanumerical\ntests[deci] = decimal\ntests[hexa] = hexadecimal\n\n// Warning types.\nvar namedNotTerminated = 1\nvar numericNotTerminated = 2\nvar namedEmpty = 3\nvar numericEmpty = 4\nvar namedUnknown = 5\nvar numericDisallowed = 6\nvar numericProhibited = 7\n\n// Warning messages.\nvar messages = {}\n\nmessages[namedNotTerminated] =\n  'Named character references must be terminated by a semicolon'\nmessages[numericNotTerminated] =\n  'Numeric character references must be terminated by a semicolon'\nmessages[namedEmpty] = 'Named character references cannot be empty'\nmessages[numericEmpty] = 'Numeric character references cannot be empty'\nmessages[namedUnknown] = 'Named character references must be known'\nmessages[numericDisallowed] =\n  'Numeric character references cannot be disallowed'\nmessages[numericProhibited] =\n  'Numeric character references cannot be outside the permissible Unicode range'\n\n// Wrap to ensure clean parameters are given to `parse`.\nfunction parseEntities(value, options) {\n  var settings = {}\n  var option\n  var key\n\n  if (!options) {\n    options = {}\n  }\n\n  for (key in defaults) {\n    option = options[key]\n    settings[key] =\n      option === null || option === undefined ? defaults[key] : option\n  }\n\n  if (settings.position.indent || settings.position.start) {\n    settings.indent = settings.position.indent || []\n    settings.position = settings.position.start\n  }\n\n  return parse(value, settings)\n}\n\n// Parse entities.\n// eslint-disable-next-line complexity\nfunction parse(value, settings) {\n  var additional = settings.additional\n  var nonTerminated = settings.nonTerminated\n  var handleText = settings.text\n  var handleReference = settings.reference\n  var handleWarning = settings.warning\n  var textContext = settings.textContext\n  var referenceContext = settings.referenceContext\n  var warningContext = settings.warningContext\n  var pos = settings.position\n  var indent = settings.indent || []\n  var length = value.length\n  var index = 0\n  var lines = -1\n  var column = pos.column || 1\n  var line = pos.line || 1\n  var queue = ''\n  var result = []\n  var entityCharacters\n  var namedEntity\n  var terminated\n  var characters\n  var character\n  var reference\n  var following\n  var warning\n  var reason\n  var output\n  var entity\n  var begin\n  var start\n  var type\n  var test\n  var prev\n  var next\n  var diff\n  var end\n\n  if (typeof additional === 'string') {\n    additional = additional.charCodeAt(0)\n  }\n\n  // Cache the current point.\n  prev = now()\n\n  // Wrap `handleWarning`.\n  warning = handleWarning ? parseError : noop\n\n  // Ensure the algorithm walks over the first character and the end (inclusive).\n  index--\n  length++\n\n  while (++index < length) {\n    // If the previous character was a newline.\n    if (character === lineFeed) {\n      column = indent[lines] || 1\n    }\n\n    character = value.charCodeAt(index)\n\n    if (character === ampersand) {\n      following = value.charCodeAt(index + 1)\n\n      // The behaviour depends on the identity of the next character.\n      if (\n        following === tab ||\n        following === lineFeed ||\n        following === formFeed ||\n        following === space ||\n        following === ampersand ||\n        following === lessThan ||\n        following !== following ||\n        (additional && following === additional)\n      ) {\n        // Not a character reference.\n        // No characters are consumed, and nothing is returned.\n        // This is not an error, either.\n        queue += fromCharCode(character)\n        column++\n\n        continue\n      }\n\n      start = index + 1\n      begin = start\n      end = start\n\n      if (following === numberSign) {\n        // Numerical entity.\n        end = ++begin\n\n        // The behaviour further depends on the next character.\n        following = value.charCodeAt(end)\n\n        if (following === uppercaseX || following === lowercaseX) {\n          // ASCII hex digits.\n          type = hexa\n          end = ++begin\n        } else {\n          // ASCII digits.\n          type = deci\n        }\n      } else {\n        // Named entity.\n        type = name\n      }\n\n      entityCharacters = ''\n      entity = ''\n      characters = ''\n      test = tests[type]\n      end--\n\n      while (++end < length) {\n        following = value.charCodeAt(end)\n\n        if (!test(following)) {\n          break\n        }\n\n        characters += fromCharCode(following)\n\n        // Check if we can match a legacy named reference.\n        // If so, we cache that as the last viable named reference.\n        // This ensures we do not need to walk backwards later.\n        if (type === name && own.call(legacy, characters)) {\n          entityCharacters = characters\n          entity = legacy[characters]\n        }\n      }\n\n      terminated = value.charCodeAt(end) === semicolon\n\n      if (terminated) {\n        end++\n\n        namedEntity = type === name ? decodeEntity(characters) : false\n\n        if (namedEntity) {\n          entityCharacters = characters\n          entity = namedEntity\n        }\n      }\n\n      diff = 1 + end - start\n\n      if (!terminated && !nonTerminated) {\n        // Empty.\n      } else if (!characters) {\n        // An empty (possible) entity is valid, unless it’s numeric (thus an\n        // ampersand followed by an octothorp).\n        if (type !== name) {\n          warning(numericEmpty, diff)\n        }\n      } else if (type === name) {\n        // An ampersand followed by anything unknown, and not terminated, is\n        // invalid.\n        if (terminated && !entity) {\n          warning(namedUnknown, 1)\n        } else {\n          // If theres something after an entity name which is not known, cap\n          // the reference.\n          if (entityCharacters !== characters) {\n            end = begin + entityCharacters.length\n            diff = 1 + end - begin\n            terminated = false\n          }\n\n          // If the reference is not terminated, warn.\n          if (!terminated) {\n            reason = entityCharacters ? namedNotTerminated : namedEmpty\n\n            if (settings.attribute) {\n              following = value.charCodeAt(end)\n\n              if (following === equalsTo) {\n                warning(reason, diff)\n                entity = null\n              } else if (alphanumerical(following)) {\n                entity = null\n              } else {\n                warning(reason, diff)\n              }\n            } else {\n              warning(reason, diff)\n            }\n          }\n        }\n\n        reference = entity\n      } else {\n        if (!terminated) {\n          // All non-terminated numeric entities are not rendered, and trigger a\n          // warning.\n          warning(numericNotTerminated, diff)\n        }\n\n        // When terminated and number, parse as either hexadecimal or decimal.\n        reference = parseInt(characters, bases[type])\n\n        // Trigger a warning when the parsed number is prohibited, and replace\n        // with replacement character.\n        if (prohibited(reference)) {\n          warning(numericProhibited, diff)\n          reference = fromCharCode(replacementCharacter)\n        } else if (reference in invalid) {\n          // Trigger a warning when the parsed number is disallowed, and replace\n          // by an alternative.\n          warning(numericDisallowed, diff)\n          reference = invalid[reference]\n        } else {\n          // Parse the number.\n          output = ''\n\n          // Trigger a warning when the parsed number should not be used.\n          if (disallowed(reference)) {\n            warning(numericDisallowed, diff)\n          }\n\n          // Stringify the number.\n          if (reference > 0xffff) {\n            reference -= 0x10000\n            output += fromCharCode((reference >>> (10 & 0x3ff)) | 0xd800)\n            reference = 0xdc00 | (reference & 0x3ff)\n          }\n\n          reference = output + fromCharCode(reference)\n        }\n      }\n\n      // Found it!\n      // First eat the queued characters as normal text, then eat an entity.\n      if (reference) {\n        flush()\n\n        prev = now()\n        index = end - 1\n        column += end - start + 1\n        result.push(reference)\n        next = now()\n        next.offset++\n\n        if (handleReference) {\n          handleReference.call(\n            referenceContext,\n            reference,\n            {start: prev, end: next},\n            value.slice(start - 1, end)\n          )\n        }\n\n        prev = next\n      } else {\n        // If we could not find a reference, queue the checked characters (as\n        // normal characters), and move the pointer to their end.\n        // This is possible because we can be certain neither newlines nor\n        // ampersands are included.\n        characters = value.slice(start - 1, end)\n        queue += characters\n        column += characters.length\n        index = end - 1\n      }\n    } else {\n      // Handle anything other than an ampersand, including newlines and EOF.\n      if (\n        character === 10 // Line feed\n      ) {\n        line++\n        lines++\n        column = 0\n      }\n\n      if (character === character) {\n        queue += fromCharCode(character)\n        column++\n      } else {\n        flush()\n      }\n    }\n  }\n\n  // Return the reduced nodes, and any possible warnings.\n  return result.join('')\n\n  // Get current position.\n  function now() {\n    return {\n      line: line,\n      column: column,\n      offset: index + (pos.offset || 0)\n    }\n  }\n\n  // “Throw” a parse-error: a warning.\n  function parseError(code, offset) {\n    var position = now()\n\n    position.column += offset\n    position.offset += offset\n\n    handleWarning.call(warningContext, messages[code], position, code)\n  }\n\n  // Flush `queue` (normal text).\n  // Macro invoked before each entity and at the end of `value`.\n  // Does nothing when `queue` is empty.\n  function flush() {\n    if (queue) {\n      result.push(queue)\n\n      if (handleText) {\n        handleText.call(textContext, queue, {start: prev, end: now()})\n      }\n\n      queue = ''\n    }\n  }\n}\n\n// Check if `character` is outside the permissible unicode range.\nfunction prohibited(code) {\n  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff\n}\n\n// Check if `character` is disallowed.\nfunction disallowed(code) {\n  return (\n    (code >= 0x0001 && code <= 0x0008) ||\n    code === 0x000b ||\n    (code >= 0x000d && code <= 0x001f) ||\n    (code >= 0x007f && code <= 0x009f) ||\n    (code >= 0xfdd0 && code <= 0xfdef) ||\n    (code & 0xffff) === 0xffff ||\n    (code & 0xffff) === 0xfffe\n  )\n}\n","'use strict'\n\nvar xtend = require('xtend')\nvar entities = require('parse-entities')\n\nmodule.exports = factory\n\n// Factory to create an entity decoder.\nfunction factory(ctx) {\n  decoder.raw = decodeRaw\n\n  return decoder\n\n  // Normalize `position` to add an `indent`.\n  function normalize(position) {\n    var offsets = ctx.offset\n    var line = position.line\n    var result = []\n\n    while (++line) {\n      if (!(line in offsets)) {\n        break\n      }\n\n      result.push((offsets[line] || 0) + 1)\n    }\n\n    return {start: position, indent: result}\n  }\n\n  // Decode `value` (at `position`) into text-nodes.\n  function decoder(value, position, handler) {\n    entities(value, {\n      position: normalize(position),\n      warning: handleWarning,\n      text: handler,\n      reference: handler,\n      textContext: ctx,\n      referenceContext: ctx\n    })\n  }\n\n  // Decode `value` (at `position`) into a string.\n  function decodeRaw(value, position, options) {\n    return entities(\n      value,\n      xtend(options, {position: normalize(position), warning: handleWarning})\n    )\n  }\n\n  // Handle a warning.\n  // See <https://github.com/wooorm/parse-entities> for the warnings.\n  function handleWarning(reason, position, code) {\n    if (code !== 3) {\n      ctx.file.message(reason, position)\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = factory\n\n// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.\nfunction factory(type) {\n  return tokenize\n\n  // Tokenizer for a bound `type`.\n  function tokenize(value, location) {\n    var self = this\n    var offset = self.offset\n    var tokens = []\n    var methods = self[type + 'Methods']\n    var tokenizers = self[type + 'Tokenizers']\n    var line = location.line\n    var column = location.column\n    var index\n    var length\n    var method\n    var name\n    var matched\n    var valueLength\n\n    // Trim white space only lines.\n    if (!value) {\n      return tokens\n    }\n\n    // Expose on `eat`.\n    eat.now = now\n    eat.file = self.file\n\n    // Sync initial offset.\n    updatePosition('')\n\n    // Iterate over `value`, and iterate over all tokenizers.  When one eats\n    // something, re-iterate with the remaining value.  If no tokenizer eats,\n    // something failed (should not happen) and an exception is thrown.\n    while (value) {\n      index = -1\n      length = methods.length\n      matched = false\n\n      while (++index < length) {\n        name = methods[index]\n        method = tokenizers[name]\n\n        if (\n          method &&\n          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&\n          (!method.notInList || !self.inList) &&\n          (!method.notInBlock || !self.inBlock) &&\n          (!method.notInLink || !self.inLink)\n        ) {\n          valueLength = value.length\n\n          method.apply(self, [eat, value])\n\n          matched = valueLength !== value.length\n\n          if (matched) {\n            break\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now())\n      }\n    }\n\n    self.eof = now()\n\n    return tokens\n\n    // Update line, column, and offset based on `value`.\n    function updatePosition(subvalue) {\n      var lastIndex = -1\n      var index = subvalue.indexOf('\\n')\n\n      while (index !== -1) {\n        line++\n        lastIndex = index\n        index = subvalue.indexOf('\\n', index + 1)\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length\n      } else {\n        column = subvalue.length - lastIndex\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line]\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1\n        }\n      }\n    }\n\n    // Get offset.  Called before the first character is eaten to retrieve the\n    // range’s offsets.\n    function getOffset() {\n      var indentation = []\n      var pos = line + 1\n\n      // Done.  Called when the last character is eaten to retrieve the range’s\n      // offsets.\n      return function() {\n        var last = line + 1\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1)\n\n          pos++\n        }\n\n        return indentation\n      }\n    }\n\n    // Get the current position.\n    function now() {\n      var pos = {line: line, column: column}\n\n      pos.offset = self.toOffset(pos)\n\n      return pos\n    }\n\n    // Store position information for a node.\n    function Position(start) {\n      this.start = start\n      this.end = now()\n    }\n\n    // Throw when a value is incorrectly eaten.  This shouldn’t happen but will\n    // throw on new, incorrect rules.\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.slice(0, subvalue.length) !== subvalue) {\n        // Capture stack-trace.\n        self.file.fail(\n          new Error(\n            'Incorrectly eaten value: please report this warning on https://git.io/vg5Ft'\n          ),\n          now()\n        )\n      }\n    }\n\n    // Mark position and patch `node.position`.\n    function position() {\n      var before = now()\n\n      return update\n\n      // Add the position to a node.\n      function update(node, indent) {\n        var prev = node.position\n        var start = prev ? prev.start : before\n        var combined = []\n        var n = prev && prev.end.line\n        var l = before.line\n\n        node.position = new Position(start)\n\n        // If there was already a `position`, this node was merged.  Fixing\n        // `start` wasn’t hard, but the indent is different.  Especially\n        // because some information, the indent between `n` and `l` wasn’t\n        // tracked.  Luckily, that space is (should be?) empty, so we can\n        // safely check for it now.\n        if (prev && indent && prev.indent) {\n          combined = prev.indent\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1)\n            }\n\n            combined.push(before.column)\n          }\n\n          indent = combined.concat(indent)\n        }\n\n        node.position.indent = indent || []\n\n        return node\n      }\n    }\n\n    // Add `node` to `parent`s children or to `tokens`.  Performs merges where\n    // possible.\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens\n      var prev = children[children.length - 1]\n      var fn\n\n      if (\n        prev &&\n        node.type === prev.type &&\n        (node.type === 'text' || node.type === 'blockquote') &&\n        mergeable(prev) &&\n        mergeable(node)\n      ) {\n        fn = node.type === 'text' ? mergeText : mergeBlockquote\n        node = fn.call(self, prev, node)\n      }\n\n      if (node !== prev) {\n        children.push(node)\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart()\n      }\n\n      return node\n    }\n\n    // Remove `subvalue` from `value`.  `subvalue` must be at the start of\n    // `value`.\n    function eat(subvalue) {\n      var indent = getOffset()\n      var pos = position()\n      var current = now()\n\n      validateEat(subvalue)\n\n      apply.reset = reset\n      reset.test = test\n      apply.test = test\n\n      value = value.slice(subvalue.length)\n\n      updatePosition(subvalue)\n\n      indent = indent()\n\n      return apply\n\n      // Add the given arguments, add `position` to the returned node, and\n      // return the node.\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent)\n      }\n\n      // Functions just like apply, but resets the content: the line and\n      // column are reversed, and the eaten value is re-added.   This is\n      // useful for nodes with a single type of content, such as lists and\n      // tables.  See `apply` above for what parameters are expected.\n      function reset() {\n        var node = apply.apply(null, arguments)\n\n        line = current.line\n        column = current.column\n        value = subvalue + value\n\n        return node\n      }\n\n      // Test the position, after eating, and reverse to a not-eaten state.\n      function test() {\n        var result = pos({})\n\n        line = current.line\n        column = current.column\n        value = subvalue + value\n\n        return result.position\n      }\n    }\n  }\n}\n\n// Check whether a node is mergeable with adjacent nodes.\nfunction mergeable(node) {\n  var start\n  var end\n\n  if (node.type !== 'text' || !node.position) {\n    return true\n  }\n\n  start = node.position.start\n  end = node.position.end\n\n  // Only merge nodes which occupy the same size as their `value`.\n  return (\n    start.line !== end.line || end.column - start.column === node.value.length\n  )\n}\n\n// Merge two text nodes: `node` into `prev`.\nfunction mergeText(prev, node) {\n  prev.value += node.value\n\n  return prev\n}\n\n// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.\nfunction mergeBlockquote(prev, node) {\n  if (this.options.commonmark || this.options.gfm) {\n    return node\n  }\n\n  prev.children = prev.children.concat(node.children)\n\n  return prev\n}\n","'use strict'\n\nmodule.exports = escapes\n\nvar defaults = [\n  '\\\\',\n  '`',\n  '*',\n  '{',\n  '}',\n  '[',\n  ']',\n  '(',\n  ')',\n  '#',\n  '+',\n  '-',\n  '.',\n  '!',\n  '_',\n  '>'\n]\n\nvar gfm = defaults.concat(['~', '|'])\n\nvar commonmark = gfm.concat([\n  '\\n',\n  '\"',\n  '$',\n  '%',\n  '&',\n  \"'\",\n  ',',\n  '/',\n  ':',\n  ';',\n  '<',\n  '=',\n  '?',\n  '@',\n  '^'\n])\n\nescapes.default = defaults\nescapes.gfm = gfm\nescapes.commonmark = commonmark\n\n// Get markdown escapes.\nfunction escapes(options) {\n  var settings = options || {}\n\n  if (settings.commonmark) {\n    return commonmark\n  }\n\n  return settings.gfm ? gfm : defaults\n}\n","'use strict'\n\nmodule.exports = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'meta',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'pre',\n  'section',\n  'source',\n  'title',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n]\n","'use strict'\n\nmodule.exports = {\n  position: true,\n  gfm: true,\n  commonmark: false,\n  footnotes: false,\n  pedantic: false,\n  blocks: require('./block-elements')\n}\n","'use strict'\n\nvar xtend = require('xtend')\nvar escapes = require('markdown-escapes')\nvar defaults = require('./defaults')\n\nmodule.exports = setOptions\n\nfunction setOptions(options) {\n  var self = this\n  var current = self.options\n  var key\n  var value\n\n  if (options == null) {\n    options = {}\n  } else if (typeof options === 'object') {\n    options = xtend(options)\n  } else {\n    throw new Error('Invalid value `' + options + '` for setting `options`')\n  }\n\n  for (key in defaults) {\n    value = options[key]\n\n    if (value == null) {\n      value = current[key]\n    }\n\n    if (\n      (key !== 'blocks' && typeof value !== 'boolean') ||\n      (key === 'blocks' && typeof value !== 'object')\n    ) {\n      throw new Error(\n        'Invalid value `' + value + '` for setting `options.' + key + '`'\n      )\n    }\n\n    options[key] = value\n  }\n\n  self.options = options\n  self.escape = escapes(options)\n\n  return self\n}\n","'use strict'\n\nmodule.exports = convert\n\nfunction convert(test) {\n  if (typeof test === 'string') {\n    return typeFactory(test)\n  }\n\n  if (test === null || test === undefined) {\n    return ok\n  }\n\n  if (typeof test === 'object') {\n    return ('length' in test ? anyFactory : matchesFactory)(test)\n  }\n\n  if (typeof test === 'function') {\n    return test\n  }\n\n  throw new Error('Expected function, string, or object as test')\n}\n\nfunction convertAll(tests) {\n  var results = []\n  var length = tests.length\n  var index = -1\n\n  while (++index < length) {\n    results[index] = convert(tests[index])\n  }\n\n  return results\n}\n\n// Utility assert each property in `test` is represented in `node`, and each\n// values are strictly equal.\nfunction matchesFactory(test) {\n  return matches\n\n  function matches(node) {\n    var key\n\n    for (key in test) {\n      if (node[key] !== test[key]) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nfunction anyFactory(tests) {\n  var checks = convertAll(tests)\n  var length = checks.length\n\n  return matches\n\n  function matches() {\n    var index = -1\n\n    while (++index < length) {\n      if (checks[index].apply(this, arguments)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n// Utility to convert a string into a function which checks a given node’s type\n// for said string.\nfunction typeFactory(test) {\n  return type\n\n  function type(node) {\n    return Boolean(node && node.type === test)\n  }\n}\n\n// Utility to return true.\nfunction ok() {\n  return true\n}\n","'use strict'\n\nmodule.exports = visitParents\n\nvar convert = require('unist-util-is/convert')\n\nvar CONTINUE = true\nvar SKIP = 'skip'\nvar EXIT = false\n\nvisitParents.CONTINUE = CONTINUE\nvisitParents.SKIP = SKIP\nvisitParents.EXIT = EXIT\n\nfunction visitParents(tree, test, visitor, reverse) {\n  var is\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    visitor = test\n    test = null\n  }\n\n  is = convert(test)\n\n  one(tree, null, [])\n\n  // Visit a single node.\n  function one(node, index, parents) {\n    var result = []\n    var subresult\n\n    if (!test || is(node, index, parents[parents.length - 1] || null)) {\n      result = toResult(visitor(node, parents))\n\n      if (result[0] === EXIT) {\n        return result\n      }\n    }\n\n    if (node.children && result[0] !== SKIP) {\n      subresult = toResult(all(node.children, parents.concat(node)))\n      return subresult[0] === EXIT ? subresult : result\n    }\n\n    return result\n  }\n\n  // Visit children in `parent`.\n  function all(children, parents) {\n    var min = -1\n    var step = reverse ? -1 : 1\n    var index = (reverse ? children.length : min) + step\n    var result\n\n    while (index > min && index < children.length) {\n      result = one(children[index], index, parents)\n\n      if (result[0] === EXIT) {\n        return result\n      }\n\n      index = typeof result[1] === 'number' ? result[1] : index + step\n    }\n  }\n}\n\nfunction toResult(value) {\n  if (value !== null && typeof value === 'object' && 'length' in value) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","'use strict'\n\nmodule.exports = visit\n\nvar visitParents = require('unist-util-visit-parents')\n\nvar CONTINUE = visitParents.CONTINUE\nvar SKIP = visitParents.SKIP\nvar EXIT = visitParents.EXIT\n\nvisit.CONTINUE = CONTINUE\nvisit.SKIP = SKIP\nvisit.EXIT = EXIT\n\nfunction visit(tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    visitor = test\n    test = null\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  function overload(node, parents) {\n    var parent = parents[parents.length - 1]\n    var index = parent ? parent.children.indexOf(node) : null\n    return visitor(node, index, parent)\n  }\n}\n","'use strict'\n\nvar visit = require('unist-util-visit')\n\nmodule.exports = removePosition\n\nfunction removePosition(node, force) {\n  visit(node, force ? hard : soft)\n  return node\n}\n\nfunction hard(node) {\n  delete node.position\n}\n\nfunction soft(node) {\n  node.position = undefined\n}\n","'use strict'\n\nvar xtend = require('xtend')\nvar removePosition = require('unist-util-remove-position')\n\nmodule.exports = parse\n\nvar lineFeed = '\\n'\nvar lineBreaksExpression = /\\r\\n|\\r/g\n\n// Parse the bound file.\nfunction parse() {\n  var self = this\n  var value = String(self.file)\n  var start = {line: 1, column: 1, offset: 0}\n  var content = xtend(start)\n  var node\n\n  // Clean non-unix newlines: `\\r\\n` and `\\r` are all changed to `\\n`.\n  // This should not affect positional information.\n  value = value.replace(lineBreaksExpression, lineFeed)\n\n  // BOM.\n  if (value.charCodeAt(0) === 0xfeff) {\n    value = value.slice(1)\n\n    content.column++\n    content.offset++\n  }\n\n  node = {\n    type: 'root',\n    children: self.tokenizeBlock(value, content),\n    position: {start: start, end: self.eof || xtend(start)}\n  }\n\n  if (!self.options.position) {\n    removePosition(node, true)\n  }\n\n  return node\n}\n","'use strict'\n\nmodule.exports = whitespace\n\nvar fromCode = String.fromCharCode\nvar re = /\\s/\n\n// Check if the given character code, or the character code at the first\n// character, is a whitespace character.\nfunction whitespace(character) {\n  return re.test(\n    typeof character === 'number' ? fromCode(character) : character.charAt(0)\n  )\n}\n","'use strict'\n\nvar whitespace = require('is-whitespace-character')\n\nmodule.exports = newline\n\nvar lineFeed = '\\n'\n\nfunction newline(eat, value, silent) {\n  var character = value.charAt(0)\n  var length\n  var subvalue\n  var queue\n  var index\n\n  if (character !== lineFeed) {\n    return\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  index = 1\n  length = value.length\n  subvalue = character\n  queue = ''\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (!whitespace(character)) {\n      break\n    }\n\n    queue += character\n\n    if (character === lineFeed) {\n      subvalue += queue\n      queue = ''\n    }\n\n    index++\n  }\n\n  eat(subvalue)\n}\n","/*!\n * repeat-string <https://github.com/jonschlinkert/repeat-string>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Results cache\n */\n\nvar res = '';\nvar cache;\n\n/**\n * Expose `repeat`\n */\n\nmodule.exports = repeat;\n\n/**\n * Repeat the given `string` the specified `number`\n * of times.\n *\n * **Example:**\n *\n * ```js\n * var repeat = require('repeat-string');\n * repeat('A', 5);\n * //=> AAAAA\n * ```\n *\n * @param {String} `string` The string to repeat\n * @param {Number} `number` The number of times to repeat the string\n * @return {String} Repeated string\n * @api public\n */\n\nfunction repeat(str, num) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  // cover common, quick use cases\n  if (num === 1) return str;\n  if (num === 2) return str + str;\n\n  var max = str.length * num;\n  if (cache !== str || typeof cache === 'undefined') {\n    cache = str;\n    res = '';\n  } else if (res.length >= max) {\n    return res.substr(0, max);\n  }\n\n  while (max > res.length && num > 1) {\n    if (num & 1) {\n      res += str;\n    }\n\n    num >>= 1;\n    str += str;\n  }\n\n  res += str;\n  res = res.substr(0, max);\n  return res;\n}\n","'use strict'\n\nmodule.exports = trimTrailingLines\n\n// Remove final newline characters from `value`.\nfunction trimTrailingLines(value) {\n  return String(value).replace(/\\n+$/, '')\n}\n","'use strict'\n\nvar repeat = require('repeat-string')\nvar trim = require('trim-trailing-lines')\n\nmodule.exports = indentedCode\n\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar space = ' '\n\nvar tabSize = 4\nvar codeIndent = repeat(space, tabSize)\n\nfunction indentedCode(eat, value, silent) {\n  var index = -1\n  var length = value.length\n  var subvalue = ''\n  var content = ''\n  var subvalueQueue = ''\n  var contentQueue = ''\n  var character\n  var blankQueue\n  var indent\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (indent) {\n      indent = false\n\n      subvalue += subvalueQueue\n      content += contentQueue\n      subvalueQueue = ''\n      contentQueue = ''\n\n      if (character === lineFeed) {\n        subvalueQueue = character\n        contentQueue = character\n      } else {\n        subvalue += character\n        content += character\n\n        while (++index < length) {\n          character = value.charAt(index)\n\n          if (!character || character === lineFeed) {\n            contentQueue = character\n            subvalueQueue = character\n            break\n          }\n\n          subvalue += character\n          content += character\n        }\n      }\n    } else if (\n      character === space &&\n      value.charAt(index + 1) === character &&\n      value.charAt(index + 2) === character &&\n      value.charAt(index + 3) === character\n    ) {\n      subvalueQueue += codeIndent\n      index += 3\n      indent = true\n    } else if (character === tab) {\n      subvalueQueue += character\n      indent = true\n    } else {\n      blankQueue = ''\n\n      while (character === tab || character === space) {\n        blankQueue += character\n        character = value.charAt(++index)\n      }\n\n      if (character !== lineFeed) {\n        break\n      }\n\n      subvalueQueue += blankQueue + character\n      contentQueue += character\n    }\n  }\n\n  if (content) {\n    if (silent) {\n      return true\n    }\n\n    return eat(subvalue)({\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: trim(content)\n    })\n  }\n}\n","'use strict'\n\nmodule.exports = fencedCode\n\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar space = ' '\nvar tilde = '~'\nvar graveAccent = '`'\n\nvar minFenceCount = 3\nvar tabSize = 4\n\nfunction fencedCode(eat, value, silent) {\n  var self = this\n  var gfm = self.options.gfm\n  var length = value.length + 1\n  var index = 0\n  var subvalue = ''\n  var fenceCount\n  var marker\n  var character\n  var flag\n  var lang\n  var meta\n  var queue\n  var content\n  var exdentedContent\n  var closing\n  var exdentedClosing\n  var indent\n  var now\n\n  if (!gfm) {\n    return\n  }\n\n  // Eat initial spacing.\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  indent = index\n\n  // Eat the fence.\n  character = value.charAt(index)\n\n  if (character !== tilde && character !== graveAccent) {\n    return\n  }\n\n  index++\n  marker = character\n  fenceCount = 1\n  subvalue += character\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== marker) {\n      break\n    }\n\n    subvalue += character\n    fenceCount++\n    index++\n  }\n\n  if (fenceCount < minFenceCount) {\n    return\n  }\n\n  // Eat spacing before flag.\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  // Eat flag.\n  flag = ''\n  queue = ''\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (\n      character === lineFeed ||\n      (marker === graveAccent && character === marker)\n    ) {\n      break\n    }\n\n    if (character === space || character === tab) {\n      queue += character\n    } else {\n      flag += queue + character\n      queue = ''\n    }\n\n    index++\n  }\n\n  character = value.charAt(index)\n\n  if (character && character !== lineFeed) {\n    return\n  }\n\n  if (silent) {\n    return true\n  }\n\n  now = eat.now()\n  now.column += subvalue.length\n  now.offset += subvalue.length\n\n  subvalue += flag\n  flag = self.decode.raw(self.unescape(flag), now)\n\n  if (queue) {\n    subvalue += queue\n  }\n\n  queue = ''\n  closing = ''\n  exdentedClosing = ''\n  content = ''\n  exdentedContent = ''\n  var skip = true\n\n  // Eat content.\n  while (index < length) {\n    character = value.charAt(index)\n    content += closing\n    exdentedContent += exdentedClosing\n    closing = ''\n    exdentedClosing = ''\n\n    if (character !== lineFeed) {\n      content += character\n      exdentedClosing += character\n      index++\n      continue\n    }\n\n    // The first line feed is ignored. Others aren’t.\n    if (skip) {\n      subvalue += character\n      skip = false\n    } else {\n      closing += character\n      exdentedClosing += character\n    }\n\n    queue = ''\n    index++\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character !== space) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n\n    closing += queue\n    exdentedClosing += queue.slice(indent)\n\n    if (queue.length >= tabSize) {\n      continue\n    }\n\n    queue = ''\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character !== marker) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n\n    closing += queue\n    exdentedClosing += queue\n\n    if (queue.length < fenceCount) {\n      continue\n    }\n\n    queue = ''\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character !== space && character !== tab) {\n        break\n      }\n\n      closing += character\n      exdentedClosing += character\n      index++\n    }\n\n    if (!character || character === lineFeed) {\n      break\n    }\n  }\n\n  subvalue += content + closing\n\n  // Get lang and meta from the flag.\n  index = -1\n  length = flag.length\n\n  while (++index < length) {\n    character = flag.charAt(index)\n\n    if (character === space || character === tab) {\n      if (!lang) {\n        lang = flag.slice(0, index)\n      }\n    } else if (lang) {\n      meta = flag.slice(index)\n      break\n    }\n  }\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: lang || flag || null,\n    meta: meta || null,\n    value: exdentedContent\n  })\n}\n","\nexports = module.exports = trim;\n\nfunction trim(str){\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function(str){\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function(str){\n  return str.replace(/\\s*$/, '');\n};\n","'use strict'\n\nmodule.exports = interrupt\n\nfunction interrupt(interruptors, tokenizers, ctx, params) {\n  var length = interruptors.length\n  var index = -1\n  var interruptor\n  var config\n\n  while (++index < length) {\n    interruptor = interruptors[index]\n    config = interruptor[1] || {}\n\n    if (\n      config.pedantic !== undefined &&\n      config.pedantic !== ctx.options.pedantic\n    ) {\n      continue\n    }\n\n    if (\n      config.commonmark !== undefined &&\n      config.commonmark !== ctx.options.commonmark\n    ) {\n      continue\n    }\n\n    if (tokenizers[interruptor[0]].apply(ctx, params)) {\n      return true\n    }\n  }\n\n  return false\n}\n","'use strict'\n\nvar trim = require('trim')\nvar interrupt = require('../util/interrupt')\n\nmodule.exports = blockquote\n\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar space = ' '\nvar greaterThan = '>'\n\nfunction blockquote(eat, value, silent) {\n  var self = this\n  var offsets = self.offset\n  var tokenizers = self.blockTokenizers\n  var interruptors = self.interruptBlockquote\n  var now = eat.now()\n  var currentLine = now.line\n  var length = value.length\n  var values = []\n  var contents = []\n  var indents = []\n  var add\n  var index = 0\n  var character\n  var rest\n  var nextIndex\n  var content\n  var line\n  var startIndex\n  var prefixed\n  var exit\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      break\n    }\n\n    index++\n  }\n\n  if (value.charAt(index) !== greaterThan) {\n    return\n  }\n\n  if (silent) {\n    return true\n  }\n\n  index = 0\n\n  while (index < length) {\n    nextIndex = value.indexOf(lineFeed, index)\n    startIndex = index\n    prefixed = false\n\n    if (nextIndex === -1) {\n      nextIndex = length\n    }\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character !== space && character !== tab) {\n        break\n      }\n\n      index++\n    }\n\n    if (value.charAt(index) === greaterThan) {\n      index++\n      prefixed = true\n\n      if (value.charAt(index) === space) {\n        index++\n      }\n    } else {\n      index = startIndex\n    }\n\n    content = value.slice(index, nextIndex)\n\n    if (!prefixed && !trim(content)) {\n      index = startIndex\n      break\n    }\n\n    if (!prefixed) {\n      rest = value.slice(index)\n\n      // Check if the following code contains a possible block.\n      if (interrupt(interruptors, tokenizers, self, [eat, rest, true])) {\n        break\n      }\n    }\n\n    line = startIndex === index ? content : value.slice(startIndex, nextIndex)\n\n    indents.push(index - startIndex)\n    values.push(line)\n    contents.push(content)\n\n    index = nextIndex + 1\n  }\n\n  index = -1\n  length = indents.length\n  add = eat(values.join(lineFeed))\n\n  while (++index < length) {\n    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index]\n    currentLine++\n  }\n\n  exit = self.enterBlock()\n  contents = self.tokenizeBlock(contents.join(lineFeed), now)\n  exit()\n\n  return add({type: 'blockquote', children: contents})\n}\n","'use strict'\n\nmodule.exports = atxHeading\n\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar space = ' '\nvar numberSign = '#'\n\nvar maxFenceCount = 6\n\nfunction atxHeading(eat, value, silent) {\n  var self = this\n  var pedantic = self.options.pedantic\n  var length = value.length + 1\n  var index = -1\n  var now = eat.now()\n  var subvalue = ''\n  var content = ''\n  var character\n  var queue\n  var depth\n\n  // Eat initial spacing.\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      index--\n      break\n    }\n\n    subvalue += character\n  }\n\n  // Eat hashes.\n  depth = 0\n\n  while (++index <= length) {\n    character = value.charAt(index)\n\n    if (character !== numberSign) {\n      index--\n      break\n    }\n\n    subvalue += character\n    depth++\n  }\n\n  if (depth > maxFenceCount) {\n    return\n  }\n\n  if (!depth || (!pedantic && value.charAt(index + 1) === numberSign)) {\n    return\n  }\n\n  length = value.length + 1\n\n  // Eat intermediate white-space.\n  queue = ''\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      index--\n      break\n    }\n\n    queue += character\n  }\n\n  // Exit when not in pedantic mode without spacing.\n  if (!pedantic && queue.length === 0 && character && character !== lineFeed) {\n    return\n  }\n\n  if (silent) {\n    return true\n  }\n\n  // Eat content.\n  subvalue += queue\n  queue = ''\n  content = ''\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (!character || character === lineFeed) {\n      break\n    }\n\n    if (character !== space && character !== tab && character !== numberSign) {\n      content += queue + character\n      queue = ''\n      continue\n    }\n\n    while (character === space || character === tab) {\n      queue += character\n      character = value.charAt(++index)\n    }\n\n    // `#` without a queue is part of the content.\n    if (!pedantic && content && !queue && character === numberSign) {\n      content += character\n      continue\n    }\n\n    while (character === numberSign) {\n      queue += character\n      character = value.charAt(++index)\n    }\n\n    while (character === space || character === tab) {\n      queue += character\n      character = value.charAt(++index)\n    }\n\n    index--\n  }\n\n  now.column += subvalue.length\n  now.offset += subvalue.length\n  subvalue += content + queue\n\n  return eat(subvalue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  })\n}\n","'use strict'\n\nmodule.exports = thematicBreak\n\nvar tab = '\\t'\nvar lineFeed = '\\n'\nvar space = ' '\nvar asterisk = '*'\nvar dash = '-'\nvar underscore = '_'\n\nvar maxCount = 3\n\nfunction thematicBreak(eat, value, silent) {\n  var index = -1\n  var length = value.length + 1\n  var subvalue = ''\n  var character\n  var marker\n  var markerCount\n  var queue\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (character !== tab && character !== space) {\n      break\n    }\n\n    subvalue += character\n  }\n\n  if (\n    character !== asterisk &&\n    character !== dash &&\n    character !== underscore\n  ) {\n    return\n  }\n\n  marker = character\n  subvalue += character\n  markerCount = 1\n  queue = ''\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (character === marker) {\n      markerCount++\n      subvalue += queue + marker\n      queue = ''\n    } else if (character === space) {\n      queue += character\n    } else if (\n      markerCount >= maxCount &&\n      (!character || character === lineFeed)\n    ) {\n      subvalue += queue\n\n      if (silent) {\n        return true\n      }\n\n      return eat(subvalue)({type: 'thematicBreak'})\n    } else {\n      return\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = indentation\n\nvar tab = '\\t'\nvar space = ' '\n\nvar spaceSize = 1\nvar tabSize = 4\n\n// Gets indentation information for a line.\nfunction indentation(value) {\n  var index = 0\n  var indent = 0\n  var character = value.charAt(index)\n  var stops = {}\n  var size\n\n  while (character === tab || character === space) {\n    size = character === tab ? tabSize : spaceSize\n\n    indent += size\n\n    if (size > 1) {\n      indent = Math.floor(indent / size) * size\n    }\n\n    stops[indent] = index\n    character = value.charAt(++index)\n  }\n\n  return {indent: indent, stops: stops}\n}\n","'use strict'\n\nvar trim = require('trim')\nvar repeat = require('repeat-string')\nvar getIndent = require('./get-indentation')\n\nmodule.exports = indentation\n\nvar tab = '\\t'\nvar lineFeed = '\\n'\nvar space = ' '\nvar exclamationMark = '!'\n\n// Remove the minimum indent from every line in `value`.  Supports both tab,\n// spaced, and mixed indentation (as well as possible).\nfunction indentation(value, maximum) {\n  var values = value.split(lineFeed)\n  var position = values.length + 1\n  var minIndent = Infinity\n  var matrix = []\n  var index\n  var indentation\n  var stops\n  var padding\n\n  values.unshift(repeat(space, maximum) + exclamationMark)\n\n  while (position--) {\n    indentation = getIndent(values[position])\n\n    matrix[position] = indentation.stops\n\n    if (trim(values[position]).length === 0) {\n      continue\n    }\n\n    if (indentation.indent) {\n      if (indentation.indent > 0 && indentation.indent < minIndent) {\n        minIndent = indentation.indent\n      }\n    } else {\n      minIndent = Infinity\n\n      break\n    }\n  }\n\n  if (minIndent !== Infinity) {\n    position = values.length\n\n    while (position--) {\n      stops = matrix[position]\n      index = minIndent\n\n      while (index && !(index in stops)) {\n        index--\n      }\n\n      if (\n        trim(values[position]).length !== 0 &&\n        minIndent &&\n        index !== minIndent\n      ) {\n        padding = tab\n      } else {\n        padding = ''\n      }\n\n      values[position] =\n        padding + values[position].slice(index in stops ? stops[index] + 1 : 0)\n    }\n  }\n\n  values.shift()\n\n  return values.join(lineFeed)\n}\n","'use strict'\n\nvar trim = require('trim')\nvar repeat = require('repeat-string')\nvar decimal = require('is-decimal')\nvar getIndent = require('../util/get-indentation')\nvar removeIndent = require('../util/remove-indentation')\nvar interrupt = require('../util/interrupt')\n\nmodule.exports = list\n\nvar asterisk = '*'\nvar underscore = '_'\nvar plusSign = '+'\nvar dash = '-'\nvar dot = '.'\nvar space = ' '\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar rightParenthesis = ')'\nvar lowercaseX = 'x'\n\nvar tabSize = 4\nvar looseListItemExpression = /\\n\\n(?!\\s*$)/\nvar taskItemExpression = /^\\[([ \\t]|x|X)][ \\t]/\nvar bulletExpression = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/\nvar pedanticBulletExpression = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/\nvar initialIndentExpression = /^( {1,4}|\\t)?/gm\n\nfunction list(eat, value, silent) {\n  var self = this\n  var commonmark = self.options.commonmark\n  var pedantic = self.options.pedantic\n  var tokenizers = self.blockTokenizers\n  var interuptors = self.interruptList\n  var index = 0\n  var length = value.length\n  var start = null\n  var size = 0\n  var queue\n  var ordered\n  var character\n  var marker\n  var nextIndex\n  var startIndex\n  var prefixed\n  var currentMarker\n  var content\n  var line\n  var prevEmpty\n  var empty\n  var items\n  var allLines\n  var emptyLines\n  var item\n  var enterTop\n  var exitBlockquote\n  var spread = false\n  var node\n  var now\n  var end\n  var indented\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character === tab) {\n      size += tabSize - (size % tabSize)\n    } else if (character === space) {\n      size++\n    } else {\n      break\n    }\n\n    index++\n  }\n\n  if (size >= tabSize) {\n    return\n  }\n\n  character = value.charAt(index)\n\n  if (character === asterisk || character === plusSign || character === dash) {\n    marker = character\n    ordered = false\n  } else {\n    ordered = true\n    queue = ''\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (!decimal(character)) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n\n    character = value.charAt(index)\n\n    if (\n      !queue ||\n      !(character === dot || (commonmark && character === rightParenthesis))\n    ) {\n      return\n    }\n\n    start = parseInt(queue, 10)\n    marker = character\n  }\n\n  character = value.charAt(++index)\n\n  if (\n    character !== space &&\n    character !== tab &&\n    (pedantic || (character !== lineFeed && character !== ''))\n  ) {\n    return\n  }\n\n  if (silent) {\n    return true\n  }\n\n  index = 0\n  items = []\n  allLines = []\n  emptyLines = []\n\n  while (index < length) {\n    nextIndex = value.indexOf(lineFeed, index)\n    startIndex = index\n    prefixed = false\n    indented = false\n\n    if (nextIndex === -1) {\n      nextIndex = length\n    }\n\n    end = index + tabSize\n    size = 0\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character === tab) {\n        size += tabSize - (size % tabSize)\n      } else if (character === space) {\n        size++\n      } else {\n        break\n      }\n\n      index++\n    }\n\n    if (size >= tabSize) {\n      indented = true\n    }\n\n    if (item && size >= item.indent) {\n      indented = true\n    }\n\n    character = value.charAt(index)\n    currentMarker = null\n\n    if (!indented) {\n      if (\n        character === asterisk ||\n        character === plusSign ||\n        character === dash\n      ) {\n        currentMarker = character\n        index++\n        size++\n      } else {\n        queue = ''\n\n        while (index < length) {\n          character = value.charAt(index)\n\n          if (!decimal(character)) {\n            break\n          }\n\n          queue += character\n          index++\n        }\n\n        character = value.charAt(index)\n        index++\n\n        if (\n          queue &&\n          (character === dot || (commonmark && character === rightParenthesis))\n        ) {\n          currentMarker = character\n          size += queue.length + 1\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index)\n\n        if (character === tab) {\n          size += tabSize - (size % tabSize)\n          index++\n        } else if (character === space) {\n          end = index + tabSize\n\n          while (index < end) {\n            if (value.charAt(index) !== space) {\n              break\n            }\n\n            index++\n            size++\n          }\n\n          if (index === end && value.charAt(index) === space) {\n            index -= tabSize - 1\n            size -= tabSize - 1\n          }\n        } else if (character !== lineFeed && character !== '') {\n          currentMarker = null\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break\n      }\n\n      prefixed = true\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === space) {\n        indented = true\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > tabSize\n      }\n\n      prefixed = false\n      index = startIndex\n    }\n\n    line = value.slice(startIndex, nextIndex)\n    content = startIndex === index ? line : value.slice(index, nextIndex)\n\n    if (\n      currentMarker === asterisk ||\n      currentMarker === underscore ||\n      currentMarker === dash\n    ) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break\n      }\n    }\n\n    prevEmpty = empty\n    empty = !prefixed && !trim(content).length\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line)\n      allLines = allLines.concat(emptyLines, line)\n      emptyLines = []\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        spread = true\n        item.value.push('')\n        item.trail = emptyLines.concat()\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      }\n\n      items.push(item)\n      allLines = allLines.concat(emptyLines, line)\n      emptyLines = []\n    } else if (empty) {\n      if (prevEmpty && !commonmark) {\n        break\n      }\n\n      emptyLines.push(line)\n    } else {\n      if (prevEmpty) {\n        break\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break\n      }\n\n      item.value = item.value.concat(emptyLines, line)\n      allLines = allLines.concat(emptyLines, line)\n      emptyLines = []\n    }\n\n    index = nextIndex + 1\n  }\n\n  node = eat(allLines.join(lineFeed)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    spread: spread,\n    children: []\n  })\n\n  enterTop = self.enterList()\n  exitBlockquote = self.enterBlock()\n  index = -1\n  length = items.length\n\n  while (++index < length) {\n    item = items[index].value.join(lineFeed)\n    now = eat.now()\n\n    eat(item)(listItem(self, item, now), node)\n\n    item = items[index].trail.join(lineFeed)\n\n    if (index !== length - 1) {\n      item += lineFeed\n    }\n\n    eat(item)\n  }\n\n  enterTop()\n  exitBlockquote()\n\n  return node\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem\n  var checked = null\n  var task\n  var indent\n\n  value = fn.apply(null, arguments)\n\n  if (ctx.options.gfm) {\n    task = value.match(taskItemExpression)\n\n    if (task) {\n      indent = task[0].length\n      checked = task[1].toLowerCase() === lowercaseX\n      offsets[position.line] += indent\n      value = value.slice(indent)\n    }\n  }\n\n  return {\n    type: 'listItem',\n    spread: looseListItemExpression.test(value),\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  }\n}\n\n// Create a list-item using overly simple mechanics.\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset\n  var line = position.line\n\n  // Remove the list-item’s bullet.\n  value = value.replace(pedanticBulletExpression, replacer)\n\n  // The initial line was also matched by the below, so we reset the `line`.\n  line = position.line\n\n  return value.replace(initialIndentExpression, replacer)\n\n  // A simple replacer which removed all matches, and adds their length to\n  // `offset`.\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length\n    line++\n\n    return ''\n  }\n}\n\n// Create a list-item using sane mechanics.\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset\n  var line = position.line\n  var max\n  var bullet\n  var rest\n  var lines\n  var trimmedLines\n  var index\n  var length\n\n  // Remove the list-item’s bullet.\n  value = value.replace(bulletExpression, replacer)\n\n  lines = value.split(lineFeed)\n\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(lineFeed)\n\n  // We replaced the initial bullet with something else above, which was used\n  // to trick `removeIndentation` into removing some more characters when\n  // possible.  However, that could result in the initial line to be stripped\n  // more than it should be.\n  trimmedLines[0] = rest\n\n  offsets[line] = (offsets[line] || 0) + bullet.length\n  line++\n\n  index = 0\n  length = lines.length\n\n  while (++index < length) {\n    offsets[line] =\n      (offsets[line] || 0) + lines[index].length - trimmedLines[index].length\n    line++\n  }\n\n  return trimmedLines.join(lineFeed)\n\n  /* eslint-disable-next-line max-params */\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3\n    rest = $4\n\n    // Make sure that the first nine numbered list items can indent with an\n    // extra space.  That is, when the bullet did not receive an extra final\n    // space.\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = space + $2\n    }\n\n    max = $1 + repeat(space, $2.length) + $3\n\n    return max + rest\n  }\n}\n","'use strict'\n\nmodule.exports = setextHeading\n\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar space = ' '\nvar equalsTo = '='\nvar dash = '-'\n\nvar maxIndent = 3\n\nvar equalsToDepth = 1\nvar dashDepth = 2\n\nfunction setextHeading(eat, value, silent) {\n  var self = this\n  var now = eat.now()\n  var length = value.length\n  var index = -1\n  var subvalue = ''\n  var content\n  var queue\n  var character\n  var marker\n  var depth\n\n  // Eat initial indentation.\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (character !== space || index >= maxIndent) {\n      index--\n      break\n    }\n\n    subvalue += character\n  }\n\n  // Eat content.\n  content = ''\n  queue = ''\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (character === lineFeed) {\n      index--\n      break\n    }\n\n    if (character === space || character === tab) {\n      queue += character\n    } else {\n      content += queue + character\n      queue = ''\n    }\n  }\n\n  now.column += subvalue.length\n  now.offset += subvalue.length\n  subvalue += content + queue\n\n  // Ensure the content is followed by a newline and a valid marker.\n  character = value.charAt(++index)\n  marker = value.charAt(++index)\n\n  if (character !== lineFeed || (marker !== equalsTo && marker !== dash)) {\n    return\n  }\n\n  subvalue += character\n\n  // Eat Setext-line.\n  queue = marker\n  depth = marker === equalsTo ? equalsToDepth : dashDepth\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (character !== marker) {\n      if (character !== lineFeed) {\n        return\n      }\n\n      index--\n      break\n    }\n\n    queue += character\n  }\n\n  if (silent) {\n    return true\n  }\n\n  return eat(subvalue + queue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  })\n}\n","'use strict'\n\nvar attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*'\nvar unquoted = '[^\"\\'=<>`\\\\u0000-\\\\u0020]+'\nvar singleQuoted = \"'[^']*'\"\nvar doubleQuoted = '\"[^\"]*\"'\nvar attributeValue =\n  '(?:' + unquoted + '|' + singleQuoted + '|' + doubleQuoted + ')'\nvar attribute =\n  '(?:\\\\s+' + attributeName + '(?:\\\\s*=\\\\s*' + attributeValue + ')?)'\nvar openTag = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>'\nvar closeTag = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>'\nvar comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->'\nvar processing = '<[?].*?[?]>'\nvar declaration = '<![A-Za-z]+\\\\s+[^>]*>'\nvar cdata = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>'\n\nexports.openCloseTag = new RegExp('^(?:' + openTag + '|' + closeTag + ')')\n\nexports.tag = new RegExp(\n  '^(?:' +\n    openTag +\n    '|' +\n    closeTag +\n    '|' +\n    comment +\n    '|' +\n    processing +\n    '|' +\n    declaration +\n    '|' +\n    cdata +\n    ')'\n)\n","'use strict'\n\nvar openCloseTag = require('../util/html').openCloseTag\n\nmodule.exports = blockHtml\n\nvar tab = '\\t'\nvar space = ' '\nvar lineFeed = '\\n'\nvar lessThan = '<'\n\nvar rawOpenExpression = /^<(script|pre|style)(?=(\\s|>|$))/i\nvar rawCloseExpression = /<\\/(script|pre|style)>/i\nvar commentOpenExpression = /^<!--/\nvar commentCloseExpression = /-->/\nvar instructionOpenExpression = /^<\\?/\nvar instructionCloseExpression = /\\?>/\nvar directiveOpenExpression = /^<![A-Za-z]/\nvar directiveCloseExpression = />/\nvar cdataOpenExpression = /^<!\\[CDATA\\[/\nvar cdataCloseExpression = /\\]\\]>/\nvar elementCloseExpression = /^$/\nvar otherElementOpenExpression = new RegExp(openCloseTag.source + '\\\\s*$')\n\nfunction blockHtml(eat, value, silent) {\n  var self = this\n  var blocks = self.options.blocks.join('|')\n  var elementOpenExpression = new RegExp(\n    '^</?(' + blocks + ')(?=(\\\\s|/?>|$))',\n    'i'\n  )\n  var length = value.length\n  var index = 0\n  var next\n  var line\n  var offset\n  var character\n  var count\n  var sequence\n  var subvalue\n\n  var sequences = [\n    [rawOpenExpression, rawCloseExpression, true],\n    [commentOpenExpression, commentCloseExpression, true],\n    [instructionOpenExpression, instructionCloseExpression, true],\n    [directiveOpenExpression, directiveCloseExpression, true],\n    [cdataOpenExpression, cdataCloseExpression, true],\n    [elementOpenExpression, elementCloseExpression, true],\n    [otherElementOpenExpression, elementCloseExpression, false]\n  ]\n\n  // Eat initial spacing.\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== tab && character !== space) {\n      break\n    }\n\n    index++\n  }\n\n  if (value.charAt(index) !== lessThan) {\n    return\n  }\n\n  next = value.indexOf(lineFeed, index + 1)\n  next = next === -1 ? length : next\n  line = value.slice(index, next)\n  offset = -1\n  count = sequences.length\n\n  while (++offset < count) {\n    if (sequences[offset][0].test(line)) {\n      sequence = sequences[offset]\n      break\n    }\n  }\n\n  if (!sequence) {\n    return\n  }\n\n  if (silent) {\n    return sequence[2]\n  }\n\n  index = next\n\n  if (!sequence[1].test(line)) {\n    while (index < length) {\n      next = value.indexOf(lineFeed, index + 1)\n      next = next === -1 ? length : next\n      line = value.slice(index + 1, next)\n\n      if (sequence[1].test(line)) {\n        if (line) {\n          index = next\n        }\n\n        break\n      }\n\n      index = next\n    }\n  }\n\n  subvalue = value.slice(0, index)\n\n  return eat(subvalue)({type: 'html', value: subvalue})\n}\n","'use strict'\n\nmodule.exports = collapse\n\n// `collapse(' \\t\\nbar \\nbaz\\t') // ' bar baz '`\nfunction collapse(value) {\n  return String(value).replace(/\\s+/g, ' ')\n}\n","'use strict'\n\nvar collapseWhiteSpace = require('collapse-white-space')\n\nmodule.exports = normalize\n\n// Normalize an identifier.  Collapses multiple white space characters into a\n// single space, and removes casing.\nfunction normalize(value) {\n  return collapseWhiteSpace(value).toLowerCase()\n}\n","'use strict'\n\nvar whitespace = require('is-whitespace-character')\nvar normalize = require('../util/normalize')\n\nmodule.exports = footnoteDefinition\nfootnoteDefinition.notInList = true\nfootnoteDefinition.notInBlock = true\n\nvar backslash = '\\\\'\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar space = ' '\nvar leftSquareBracket = '['\nvar rightSquareBracket = ']'\nvar caret = '^'\nvar colon = ':'\n\nvar EXPRESSION_INITIAL_TAB = /^( {4}|\\t)?/gm\n\nfunction footnoteDefinition(eat, value, silent) {\n  var self = this\n  var offsets = self.offset\n  var index\n  var length\n  var subvalue\n  var now\n  var currentLine\n  var content\n  var queue\n  var subqueue\n  var character\n  var identifier\n  var add\n  var exit\n\n  if (!self.options.footnotes) {\n    return\n  }\n\n  index = 0\n  length = value.length\n  subvalue = ''\n  now = eat.now()\n  currentLine = now.line\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (!whitespace(character)) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  if (\n    value.charAt(index) !== leftSquareBracket ||\n    value.charAt(index + 1) !== caret\n  ) {\n    return\n  }\n\n  subvalue += leftSquareBracket + caret\n  index = subvalue.length\n  queue = ''\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character === rightSquareBracket) {\n      break\n    } else if (character === backslash) {\n      queue += character\n      index++\n      character = value.charAt(index)\n    }\n\n    queue += character\n    index++\n  }\n\n  if (\n    !queue ||\n    value.charAt(index) !== rightSquareBracket ||\n    value.charAt(index + 1) !== colon\n  ) {\n    return\n  }\n\n  if (silent) {\n    return true\n  }\n\n  identifier = queue\n  subvalue += queue + rightSquareBracket + colon\n  index = subvalue.length\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== tab && character !== space) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  now.column += subvalue.length\n  now.offset += subvalue.length\n  queue = ''\n  content = ''\n  subqueue = ''\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character === lineFeed) {\n      subqueue = character\n      index++\n\n      while (index < length) {\n        character = value.charAt(index)\n\n        if (character !== lineFeed) {\n          break\n        }\n\n        subqueue += character\n        index++\n      }\n\n      queue += subqueue\n      subqueue = ''\n\n      while (index < length) {\n        character = value.charAt(index)\n\n        if (character !== space) {\n          break\n        }\n\n        subqueue += character\n        index++\n      }\n\n      if (subqueue.length === 0) {\n        break\n      }\n\n      queue += subqueue\n    }\n\n    if (queue) {\n      content += queue\n      queue = ''\n    }\n\n    content += character\n    index++\n  }\n\n  subvalue += content\n\n  content = content.replace(EXPRESSION_INITIAL_TAB, function(line) {\n    offsets[currentLine] = (offsets[currentLine] || 0) + line.length\n    currentLine++\n\n    return ''\n  })\n\n  add = eat(subvalue)\n\n  exit = self.enterBlock()\n  content = self.tokenizeBlock(content, now)\n  exit()\n\n  return add({\n    type: 'footnoteDefinition',\n    identifier: normalize(identifier),\n    label: identifier,\n    children: content\n  })\n}\n","'use strict'\n\nvar whitespace = require('is-whitespace-character')\nvar normalize = require('../util/normalize')\n\nmodule.exports = definition\n\nvar quotationMark = '\"'\nvar apostrophe = \"'\"\nvar backslash = '\\\\'\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar space = ' '\nvar leftSquareBracket = '['\nvar rightSquareBracket = ']'\nvar leftParenthesis = '('\nvar rightParenthesis = ')'\nvar colon = ':'\nvar lessThan = '<'\nvar greaterThan = '>'\n\nfunction definition(eat, value, silent) {\n  var self = this\n  var commonmark = self.options.commonmark\n  var index = 0\n  var length = value.length\n  var subvalue = ''\n  var beforeURL\n  var beforeTitle\n  var queue\n  var character\n  var test\n  var identifier\n  var url\n  var title\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  character = value.charAt(index)\n\n  if (character !== leftSquareBracket) {\n    return\n  }\n\n  index++\n  subvalue += character\n  queue = ''\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character === rightSquareBracket) {\n      break\n    } else if (character === backslash) {\n      queue += character\n      index++\n      character = value.charAt(index)\n    }\n\n    queue += character\n    index++\n  }\n\n  if (\n    !queue ||\n    value.charAt(index) !== rightSquareBracket ||\n    value.charAt(index + 1) !== colon\n  ) {\n    return\n  }\n\n  identifier = queue\n  subvalue += queue + rightSquareBracket + colon\n  index = subvalue.length\n  queue = ''\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== tab && character !== space && character !== lineFeed) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  character = value.charAt(index)\n  queue = ''\n  beforeURL = subvalue\n\n  if (character === lessThan) {\n    index++\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (!isEnclosedURLCharacter(character)) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n\n    character = value.charAt(index)\n\n    if (character === isEnclosedURLCharacter.delimiter) {\n      subvalue += lessThan + queue + character\n      index++\n    } else {\n      if (commonmark) {\n        return\n      }\n\n      index -= queue.length + 1\n      queue = ''\n    }\n  }\n\n  if (!queue) {\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (!isUnclosedURLCharacter(character)) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n\n    subvalue += queue\n  }\n\n  if (!queue) {\n    return\n  }\n\n  url = queue\n  queue = ''\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== tab && character !== space && character !== lineFeed) {\n      break\n    }\n\n    queue += character\n    index++\n  }\n\n  character = value.charAt(index)\n  test = null\n\n  if (character === quotationMark) {\n    test = quotationMark\n  } else if (character === apostrophe) {\n    test = apostrophe\n  } else if (character === leftParenthesis) {\n    test = rightParenthesis\n  }\n\n  if (!test) {\n    queue = ''\n    index = subvalue.length\n  } else if (queue) {\n    subvalue += queue + character\n    index = subvalue.length\n    queue = ''\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character === test) {\n        break\n      }\n\n      if (character === lineFeed) {\n        index++\n        character = value.charAt(index)\n\n        if (character === lineFeed || character === test) {\n          return\n        }\n\n        queue += lineFeed\n      }\n\n      queue += character\n      index++\n    }\n\n    character = value.charAt(index)\n\n    if (character !== test) {\n      return\n    }\n\n    beforeTitle = subvalue\n    subvalue += queue + character\n    index++\n    title = queue\n    queue = ''\n  } else {\n    return\n  }\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== tab && character !== space) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  character = value.charAt(index)\n\n  if (!character || character === lineFeed) {\n    if (silent) {\n      return true\n    }\n\n    beforeURL = eat(beforeURL).test().end\n    url = self.decode.raw(self.unescape(url), beforeURL, {nonTerminated: false})\n\n    if (title) {\n      beforeTitle = eat(beforeTitle).test().end\n      title = self.decode.raw(self.unescape(title), beforeTitle)\n    }\n\n    return eat(subvalue)({\n      type: 'definition',\n      identifier: normalize(identifier),\n      label: identifier,\n      title: title || null,\n      url: url\n    })\n  }\n}\n\n// Check if `character` can be inside an enclosed URI.\nfunction isEnclosedURLCharacter(character) {\n  return (\n    character !== greaterThan &&\n    character !== leftSquareBracket &&\n    character !== rightSquareBracket\n  )\n}\n\nisEnclosedURLCharacter.delimiter = greaterThan\n\n// Check if `character` can be inside an unclosed URI.\nfunction isUnclosedURLCharacter(character) {\n  return (\n    character !== leftSquareBracket &&\n    character !== rightSquareBracket &&\n    !whitespace(character)\n  )\n}\n","'use strict'\n\nvar whitespace = require('is-whitespace-character')\n\nmodule.exports = table\n\nvar tab = '\\t'\nvar lineFeed = '\\n'\nvar space = ' '\nvar dash = '-'\nvar colon = ':'\nvar backslash = '\\\\'\nvar verticalBar = '|'\n\nvar minColumns = 1\nvar minRows = 2\n\nvar left = 'left'\nvar center = 'center'\nvar right = 'right'\n\nfunction table(eat, value, silent) {\n  var self = this\n  var index\n  var alignments\n  var alignment\n  var subvalue\n  var row\n  var length\n  var lines\n  var queue\n  var character\n  var hasDash\n  var align\n  var cell\n  var preamble\n  var now\n  var position\n  var lineCount\n  var line\n  var rows\n  var table\n  var lineIndex\n  var pipeIndex\n  var first\n\n  // Exit when not in gfm-mode.\n  if (!self.options.gfm) {\n    return\n  }\n\n  // Get the rows.\n  // Detecting tables soon is hard, so there are some checks for performance\n  // here, such as the minimum number of rows, and allowed characters in the\n  // alignment row.\n  index = 0\n  lineCount = 0\n  length = value.length + 1\n  lines = []\n\n  while (index < length) {\n    lineIndex = value.indexOf(lineFeed, index)\n    pipeIndex = value.indexOf(verticalBar, index + 1)\n\n    if (lineIndex === -1) {\n      lineIndex = value.length\n    }\n\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < minRows) {\n        return\n      }\n\n      break\n    }\n\n    lines.push(value.slice(index, lineIndex))\n    lineCount++\n    index = lineIndex + 1\n  }\n\n  // Parse the alignment row.\n  subvalue = lines.join(lineFeed)\n  alignments = lines.splice(1, 1)[0] || []\n  index = 0\n  length = alignments.length\n  lineCount--\n  alignment = false\n  align = []\n\n  while (index < length) {\n    character = alignments.charAt(index)\n\n    if (character === verticalBar) {\n      hasDash = null\n\n      if (alignment === false) {\n        if (first === false) {\n          return\n        }\n      } else {\n        align.push(alignment)\n        alignment = false\n      }\n\n      first = false\n    } else if (character === dash) {\n      hasDash = true\n      alignment = alignment || null\n    } else if (character === colon) {\n      if (alignment === left) {\n        alignment = center\n      } else if (hasDash && alignment === null) {\n        alignment = right\n      } else {\n        alignment = left\n      }\n    } else if (!whitespace(character)) {\n      return\n    }\n\n    index++\n  }\n\n  if (alignment !== false) {\n    align.push(alignment)\n  }\n\n  // Exit when without enough columns.\n  if (align.length < minColumns) {\n    return\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  // Parse the rows.\n  position = -1\n  rows = []\n\n  table = eat(subvalue).reset({type: 'table', align: align, children: rows})\n\n  while (++position < lineCount) {\n    line = lines[position]\n    row = {type: 'tableRow', children: []}\n\n    // Eat a newline character when this is not the first row.\n    if (position) {\n      eat(lineFeed)\n    }\n\n    // Eat the row.\n    eat(line).reset(row, table)\n\n    length = line.length + 1\n    index = 0\n    queue = ''\n    cell = ''\n    preamble = true\n\n    while (index < length) {\n      character = line.charAt(index)\n\n      if (character === tab || character === space) {\n        if (cell) {\n          queue += character\n        } else {\n          eat(character)\n        }\n\n        index++\n        continue\n      }\n\n      if (character === '' || character === verticalBar) {\n        if (preamble) {\n          eat(character)\n        } else {\n          if ((cell || character) && !preamble) {\n            subvalue = cell\n\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, queue.length - 1)\n                queue = queue.charAt(queue.length - 1)\n              } else {\n                subvalue += queue\n                queue = ''\n              }\n            }\n\n            now = eat.now()\n\n            eat(subvalue)(\n              {type: 'tableCell', children: self.tokenizeInline(cell, now)},\n              row\n            )\n          }\n\n          eat(queue + character)\n\n          queue = ''\n          cell = ''\n        }\n      } else {\n        if (queue) {\n          cell += queue\n          queue = ''\n        }\n\n        cell += character\n\n        if (character === backslash && index !== length - 2) {\n          cell += line.charAt(index + 1)\n          index++\n        }\n      }\n\n      preamble = false\n      index++\n    }\n\n    // Eat the alignment row.\n    if (!position) {\n      eat(lineFeed + alignments)\n    }\n  }\n\n  return table\n}\n","'use strict'\n\nvar trim = require('trim')\nvar decimal = require('is-decimal')\nvar trimTrailingLines = require('trim-trailing-lines')\nvar interrupt = require('../util/interrupt')\n\nmodule.exports = paragraph\n\nvar tab = '\\t'\nvar lineFeed = '\\n'\nvar space = ' '\n\nvar tabSize = 4\n\n// Tokenise paragraph.\nfunction paragraph(eat, value, silent) {\n  var self = this\n  var settings = self.options\n  var commonmark = settings.commonmark\n  var gfm = settings.gfm\n  var tokenizers = self.blockTokenizers\n  var interruptors = self.interruptParagraph\n  var index = value.indexOf(lineFeed)\n  var length = value.length\n  var position\n  var subvalue\n  var character\n  var size\n  var now\n\n  while (index < length) {\n    // Eat everything if there’s no following newline.\n    if (index === -1) {\n      index = length\n      break\n    }\n\n    // Stop if the next character is NEWLINE.\n    if (value.charAt(index + 1) === lineFeed) {\n      break\n    }\n\n    // In commonmark-mode, following indented lines are part of the paragraph.\n    if (commonmark) {\n      size = 0\n      position = index + 1\n\n      while (position < length) {\n        character = value.charAt(position)\n\n        if (character === tab) {\n          size = tabSize\n          break\n        } else if (character === space) {\n          size++\n        } else {\n          break\n        }\n\n        position++\n      }\n\n      if (size >= tabSize && character !== lineFeed) {\n        index = value.indexOf(lineFeed, index + 1)\n        continue\n      }\n    }\n\n    subvalue = value.slice(index + 1)\n\n    // Check if the following code contains a possible block.\n    if (interrupt(interruptors, tokenizers, self, [eat, subvalue, true])) {\n      break\n    }\n\n    // Break if the following line starts a list, when already in a list, or\n    // when in commonmark, or when in gfm mode and the bullet is *not* numeric.\n    if (\n      tokenizers.list.call(self, eat, subvalue, true) &&\n      (self.inList ||\n        commonmark ||\n        (gfm && !decimal(trim.left(subvalue).charAt(0))))\n    ) {\n      break\n    }\n\n    position = index\n    index = value.indexOf(lineFeed, index + 1)\n\n    if (index !== -1 && trim(value.slice(position, index)) === '') {\n      index = position\n      break\n    }\n  }\n\n  subvalue = value.slice(0, index)\n\n  if (trim(subvalue) === '') {\n    eat(subvalue)\n\n    return null\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  now = eat.now()\n  subvalue = trimTrailingLines(subvalue)\n\n  return eat(subvalue)({\n    type: 'paragraph',\n    children: self.tokenizeInline(subvalue, now)\n  })\n}\n","'use strict'\n\nmodule.exports = locate\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('\\\\', fromIndex)\n}\n","'use strict'\n\nvar locate = require('../locate/escape')\n\nmodule.exports = escape\nescape.locator = locate\n\nvar lineFeed = '\\n'\nvar backslash = '\\\\'\n\nfunction escape(eat, value, silent) {\n  var self = this\n  var character\n  var node\n\n  if (value.charAt(0) === backslash) {\n    character = value.charAt(1)\n\n    if (self.escape.indexOf(character) !== -1) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true\n      }\n\n      if (character === lineFeed) {\n        node = {type: 'break'}\n      } else {\n        node = {type: 'text', value: character}\n      }\n\n      return eat(backslash + character)(node)\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = locate\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('<', fromIndex)\n}\n","'use strict'\n\nvar whitespace = require('is-whitespace-character')\nvar decode = require('parse-entities')\nvar locate = require('../locate/tag')\n\nmodule.exports = autoLink\nautoLink.locator = locate\nautoLink.notInLink = true\n\nvar lessThan = '<'\nvar greaterThan = '>'\nvar atSign = '@'\nvar slash = '/'\nvar mailto = 'mailto:'\nvar mailtoLength = mailto.length\n\nfunction autoLink(eat, value, silent) {\n  var self = this\n  var subvalue = ''\n  var length = value.length\n  var index = 0\n  var queue = ''\n  var hasAtCharacter = false\n  var link = ''\n  var character\n  var now\n  var content\n  var tokenizers\n  var exit\n\n  if (value.charAt(0) !== lessThan) {\n    return\n  }\n\n  index++\n  subvalue = lessThan\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (\n      whitespace(character) ||\n      character === greaterThan ||\n      character === atSign ||\n      (character === ':' && value.charAt(index + 1) === slash)\n    ) {\n      break\n    }\n\n    queue += character\n    index++\n  }\n\n  if (!queue) {\n    return\n  }\n\n  link += queue\n  queue = ''\n\n  character = value.charAt(index)\n  link += character\n  index++\n\n  if (character === atSign) {\n    hasAtCharacter = true\n  } else {\n    if (character !== ':' || value.charAt(index + 1) !== slash) {\n      return\n    }\n\n    link += slash\n    index++\n  }\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (whitespace(character) || character === greaterThan) {\n      break\n    }\n\n    queue += character\n    index++\n  }\n\n  character = value.charAt(index)\n\n  if (!queue || character !== greaterThan) {\n    return\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  link += queue\n  content = link\n  subvalue += link + character\n  now = eat.now()\n  now.column++\n  now.offset++\n\n  if (hasAtCharacter) {\n    if (link.slice(0, mailtoLength).toLowerCase() === mailto) {\n      content = content.slice(mailtoLength)\n      now.column += mailtoLength\n      now.offset += mailtoLength\n    } else {\n      link = mailto + link\n    }\n  }\n\n  // Temporarily remove all tokenizers except text in autolinks.\n  tokenizers = self.inlineTokenizers\n  self.inlineTokenizers = {text: tokenizers.text}\n\n  exit = self.enterLink()\n\n  content = self.tokenizeInline(content, now)\n\n  self.inlineTokenizers = tokenizers\n  exit()\n\n  return eat(subvalue)({\n    type: 'link',\n    title: null,\n    url: decode(link, {nonTerminated: false}),\n    children: content\n  })\n}\n","'use strict'\n\nmodule.exports = locate\n\nvar protocols = ['https://', 'http://', 'mailto:']\n\nfunction locate(value, fromIndex) {\n  var length = protocols.length\n  var index = -1\n  var min = -1\n  var position\n\n  if (!this.options.gfm) {\n    return -1\n  }\n\n  while (++index < length) {\n    position = value.indexOf(protocols[index], fromIndex)\n\n    if (position !== -1 && (position < min || min === -1)) {\n      min = position\n    }\n  }\n\n  return min\n}\n","'use strict'\n\nvar decode = require('parse-entities')\nvar whitespace = require('is-whitespace-character')\nvar locate = require('../locate/url')\n\nmodule.exports = url\nurl.locator = locate\nurl.notInLink = true\n\nvar quotationMark = '\"'\nvar apostrophe = \"'\"\nvar leftParenthesis = '('\nvar rightParenthesis = ')'\nvar comma = ','\nvar dot = '.'\nvar colon = ':'\nvar semicolon = ';'\nvar lessThan = '<'\nvar atSign = '@'\nvar leftSquareBracket = '['\nvar rightSquareBracket = ']'\n\nvar http = 'http://'\nvar https = 'https://'\nvar mailto = 'mailto:'\n\nvar protocols = [http, https, mailto]\n\nvar protocolsLength = protocols.length\n\nfunction url(eat, value, silent) {\n  var self = this\n  var subvalue\n  var content\n  var character\n  var index\n  var position\n  var protocol\n  var match\n  var length\n  var queue\n  var parenCount\n  var nextCharacter\n  var tokenizers\n  var exit\n\n  if (!self.options.gfm) {\n    return\n  }\n\n  subvalue = ''\n  index = -1\n\n  while (++index < protocolsLength) {\n    protocol = protocols[index]\n    match = value.slice(0, protocol.length)\n\n    if (match.toLowerCase() === protocol) {\n      subvalue = match\n      break\n    }\n  }\n\n  if (!subvalue) {\n    return\n  }\n\n  index = subvalue.length\n  length = value.length\n  queue = ''\n  parenCount = 0\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (whitespace(character) || character === lessThan) {\n      break\n    }\n\n    if (\n      character === dot ||\n      character === comma ||\n      character === colon ||\n      character === semicolon ||\n      character === quotationMark ||\n      character === apostrophe ||\n      character === rightParenthesis ||\n      character === rightSquareBracket\n    ) {\n      nextCharacter = value.charAt(index + 1)\n\n      if (!nextCharacter || whitespace(nextCharacter)) {\n        break\n      }\n    }\n\n    if (character === leftParenthesis || character === leftSquareBracket) {\n      parenCount++\n    }\n\n    if (character === rightParenthesis || character === rightSquareBracket) {\n      parenCount--\n\n      if (parenCount < 0) {\n        break\n      }\n    }\n\n    queue += character\n    index++\n  }\n\n  if (!queue) {\n    return\n  }\n\n  subvalue += queue\n  content = subvalue\n\n  if (protocol === mailto) {\n    position = queue.indexOf(atSign)\n\n    if (position === -1 || position === length - 1) {\n      return\n    }\n\n    content = content.slice(mailto.length)\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  exit = self.enterLink()\n\n  // Temporarily remove all tokenizers except text in url.\n  tokenizers = self.inlineTokenizers\n  self.inlineTokenizers = {text: tokenizers.text}\n\n  content = self.tokenizeInline(content, eat.now())\n\n  self.inlineTokenizers = tokenizers\n  exit()\n\n  return eat(subvalue)({\n    type: 'link',\n    title: null,\n    url: decode(subvalue, {nonTerminated: false}),\n    children: content\n  })\n}\n","'use strict'\n\nvar alphabetical = require('is-alphabetical')\nvar locate = require('../locate/tag')\nvar tag = require('../util/html').tag\n\nmodule.exports = inlineHTML\ninlineHTML.locator = locate\n\nvar lessThan = '<'\nvar questionMark = '?'\nvar exclamationMark = '!'\nvar slash = '/'\n\nvar htmlLinkOpenExpression = /^<a /i\nvar htmlLinkCloseExpression = /^<\\/a>/i\n\nfunction inlineHTML(eat, value, silent) {\n  var self = this\n  var length = value.length\n  var character\n  var subvalue\n\n  if (value.charAt(0) !== lessThan || length < 3) {\n    return\n  }\n\n  character = value.charAt(1)\n\n  if (\n    !alphabetical(character) &&\n    character !== questionMark &&\n    character !== exclamationMark &&\n    character !== slash\n  ) {\n    return\n  }\n\n  subvalue = value.match(tag)\n\n  if (!subvalue) {\n    return\n  }\n\n  /* istanbul ignore if - not used yet. */\n  if (silent) {\n    return true\n  }\n\n  subvalue = subvalue[0]\n\n  if (!self.inLink && htmlLinkOpenExpression.test(subvalue)) {\n    self.inLink = true\n  } else if (self.inLink && htmlLinkCloseExpression.test(subvalue)) {\n    self.inLink = false\n  }\n\n  return eat(subvalue)({type: 'html', value: subvalue})\n}\n","'use strict'\n\nmodule.exports = locate\n\nfunction locate(value, fromIndex) {\n  var link = value.indexOf('[', fromIndex)\n  var image = value.indexOf('![', fromIndex)\n\n  if (image === -1) {\n    return link\n  }\n\n  // Link can never be `-1` if an image is found, so we don’t need to check\n  // for that :)\n  return link < image ? link : image\n}\n","'use strict'\n\nvar whitespace = require('is-whitespace-character')\nvar locate = require('../locate/link')\n\nmodule.exports = link\nlink.locator = locate\n\nvar lineFeed = '\\n'\nvar exclamationMark = '!'\nvar quotationMark = '\"'\nvar apostrophe = \"'\"\nvar leftParenthesis = '('\nvar rightParenthesis = ')'\nvar lessThan = '<'\nvar greaterThan = '>'\nvar leftSquareBracket = '['\nvar backslash = '\\\\'\nvar rightSquareBracket = ']'\nvar graveAccent = '`'\n\nfunction link(eat, value, silent) {\n  var self = this\n  var subvalue = ''\n  var index = 0\n  var character = value.charAt(0)\n  var pedantic = self.options.pedantic\n  var commonmark = self.options.commonmark\n  var gfm = self.options.gfm\n  var closed\n  var count\n  var opening\n  var beforeURL\n  var beforeTitle\n  var subqueue\n  var hasMarker\n  var isImage\n  var content\n  var marker\n  var length\n  var title\n  var depth\n  var queue\n  var url\n  var now\n  var exit\n  var node\n\n  // Detect whether this is an image.\n  if (character === exclamationMark) {\n    isImage = true\n    subvalue = character\n    character = value.charAt(++index)\n  }\n\n  // Eat the opening.\n  if (character !== leftSquareBracket) {\n    return\n  }\n\n  // Exit when this is a link and we’re already inside a link.\n  if (!isImage && self.inLink) {\n    return\n  }\n\n  subvalue += character\n  queue = ''\n  index++\n\n  // Eat the content.\n  length = value.length\n  now = eat.now()\n  depth = 0\n\n  now.column += index\n  now.offset += index\n\n  while (index < length) {\n    character = value.charAt(index)\n    subqueue = character\n\n    if (character === graveAccent) {\n      // Inline-code in link content.\n      count = 1\n\n      while (value.charAt(index + 1) === graveAccent) {\n        subqueue += character\n        index++\n        count++\n      }\n\n      if (!opening) {\n        opening = count\n      } else if (count >= opening) {\n        opening = 0\n      }\n    } else if (character === backslash) {\n      // Allow brackets to be escaped.\n      index++\n      subqueue += value.charAt(index)\n    } else if ((!opening || gfm) && character === leftSquareBracket) {\n      // In GFM mode, brackets in code still count.  In all other modes,\n      // they don’t.\n      depth++\n    } else if ((!opening || gfm) && character === rightSquareBracket) {\n      if (depth) {\n        depth--\n      } else {\n        // Allow white-space between content and url in GFM mode.\n        if (!pedantic) {\n          while (index < length) {\n            character = value.charAt(index + 1)\n\n            if (!whitespace(character)) {\n              break\n            }\n\n            subqueue += character\n            index++\n          }\n        }\n\n        if (value.charAt(index + 1) !== leftParenthesis) {\n          return\n        }\n\n        subqueue += leftParenthesis\n        closed = true\n        index++\n\n        break\n      }\n    }\n\n    queue += subqueue\n    subqueue = ''\n    index++\n  }\n\n  // Eat the content closing.\n  if (!closed) {\n    return\n  }\n\n  content = queue\n  subvalue += queue + subqueue\n  index++\n\n  // Eat white-space.\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (!whitespace(character)) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  // Eat the URL.\n  character = value.charAt(index)\n  queue = ''\n  beforeURL = subvalue\n\n  if (character === lessThan) {\n    index++\n    beforeURL += lessThan\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character === greaterThan) {\n        break\n      }\n\n      if (commonmark && character === lineFeed) {\n        return\n      }\n\n      queue += character\n      index++\n    }\n\n    if (value.charAt(index) !== greaterThan) {\n      return\n    }\n\n    subvalue += lessThan + queue + greaterThan\n    url = queue\n    index++\n  } else {\n    character = null\n    subqueue = ''\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (\n        subqueue &&\n        (character === quotationMark ||\n          character === apostrophe ||\n          (commonmark && character === leftParenthesis))\n      ) {\n        break\n      }\n\n      if (whitespace(character)) {\n        if (!pedantic) {\n          break\n        }\n\n        subqueue += character\n      } else {\n        if (character === leftParenthesis) {\n          depth++\n        } else if (character === rightParenthesis) {\n          if (depth === 0) {\n            break\n          }\n\n          depth--\n        }\n\n        queue += subqueue\n        subqueue = ''\n\n        if (character === backslash) {\n          queue += backslash\n          character = value.charAt(++index)\n        }\n\n        queue += character\n      }\n\n      index++\n    }\n\n    subvalue += queue\n    url = queue\n    index = subvalue.length\n  }\n\n  // Eat white-space.\n  queue = ''\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (!whitespace(character)) {\n      break\n    }\n\n    queue += character\n    index++\n  }\n\n  character = value.charAt(index)\n  subvalue += queue\n\n  // Eat the title.\n  if (\n    queue &&\n    (character === quotationMark ||\n      character === apostrophe ||\n      (commonmark && character === leftParenthesis))\n  ) {\n    index++\n    subvalue += character\n    queue = ''\n    marker = character === leftParenthesis ? rightParenthesis : character\n    beforeTitle = subvalue\n\n    // In commonmark-mode, things are pretty easy: the marker cannot occur\n    // inside the title.  Non-commonmark does, however, support nested\n    // delimiters.\n    if (commonmark) {\n      while (index < length) {\n        character = value.charAt(index)\n\n        if (character === marker) {\n          break\n        }\n\n        if (character === backslash) {\n          queue += backslash\n          character = value.charAt(++index)\n        }\n\n        index++\n        queue += character\n      }\n\n      character = value.charAt(index)\n\n      if (character !== marker) {\n        return\n      }\n\n      title = queue\n      subvalue += queue + character\n      index++\n\n      while (index < length) {\n        character = value.charAt(index)\n\n        if (!whitespace(character)) {\n          break\n        }\n\n        subvalue += character\n        index++\n      }\n    } else {\n      subqueue = ''\n\n      while (index < length) {\n        character = value.charAt(index)\n\n        if (character === marker) {\n          if (hasMarker) {\n            queue += marker + subqueue\n            subqueue = ''\n          }\n\n          hasMarker = true\n        } else if (!hasMarker) {\n          queue += character\n        } else if (character === rightParenthesis) {\n          subvalue += queue + marker + subqueue\n          title = queue\n          break\n        } else if (whitespace(character)) {\n          subqueue += character\n        } else {\n          queue += marker + subqueue + character\n          subqueue = ''\n          hasMarker = false\n        }\n\n        index++\n      }\n    }\n  }\n\n  if (value.charAt(index) !== rightParenthesis) {\n    return\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  subvalue += rightParenthesis\n\n  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {\n    nonTerminated: false\n  })\n\n  if (title) {\n    beforeTitle = eat(beforeTitle).test().end\n    title = self.decode.raw(self.unescape(title), beforeTitle)\n  }\n\n  node = {\n    type: isImage ? 'image' : 'link',\n    title: title || null,\n    url: url\n  }\n\n  if (isImage) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null\n  } else {\n    exit = self.enterLink()\n    node.children = self.tokenizeInline(content, now)\n    exit()\n  }\n\n  return eat(subvalue)(node)\n}\n","'use strict'\n\nvar whitespace = require('is-whitespace-character')\nvar locate = require('../locate/link')\nvar normalize = require('../util/normalize')\n\nmodule.exports = reference\nreference.locator = locate\n\nvar link = 'link'\nvar image = 'image'\nvar footnote = 'footnote'\nvar shortcut = 'shortcut'\nvar collapsed = 'collapsed'\nvar full = 'full'\nvar space = ' '\nvar exclamationMark = '!'\nvar leftSquareBracket = '['\nvar backslash = '\\\\'\nvar rightSquareBracket = ']'\nvar caret = '^'\n\nfunction reference(eat, value, silent) {\n  var self = this\n  var commonmark = self.options.commonmark\n  var footnotes = self.options.footnotes\n  var character = value.charAt(0)\n  var index = 0\n  var length = value.length\n  var subvalue = ''\n  var intro = ''\n  var type = link\n  var referenceType = shortcut\n  var content\n  var identifier\n  var now\n  var node\n  var exit\n  var queue\n  var bracketed\n  var depth\n\n  // Check whether we’re eating an image.\n  if (character === exclamationMark) {\n    type = image\n    intro = character\n    character = value.charAt(++index)\n  }\n\n  if (character !== leftSquareBracket) {\n    return\n  }\n\n  index++\n  intro += character\n  queue = ''\n\n  // Check whether we’re eating a footnote.\n  if (footnotes && value.charAt(index) === caret) {\n    // Exit if `![^` is found, so the `!` will be seen as text after this,\n    // and we’ll enter this function again when `[^` is found.\n    if (type === image) {\n      return\n    }\n\n    intro += caret\n    index++\n    type = footnote\n  }\n\n  // Eat the text.\n  depth = 0\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character === leftSquareBracket) {\n      bracketed = true\n      depth++\n    } else if (character === rightSquareBracket) {\n      if (!depth) {\n        break\n      }\n\n      depth--\n    }\n\n    if (character === backslash) {\n      queue += backslash\n      character = value.charAt(++index)\n    }\n\n    queue += character\n    index++\n  }\n\n  subvalue = queue\n  content = queue\n  character = value.charAt(index)\n\n  if (character !== rightSquareBracket) {\n    return\n  }\n\n  index++\n  subvalue += character\n  queue = ''\n\n  if (!commonmark) {\n    // The original markdown syntax definition explicitly allows for whitespace\n    // between the link text and link label; commonmark departs from this, in\n    // part to improve support for shortcut reference links\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (!whitespace(character)) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n  }\n\n  character = value.charAt(index)\n\n  // Inline footnotes cannot have a label.\n  // If footnotes are enabled, link labels cannot start with a caret.\n  if (\n    type !== footnote &&\n    character === leftSquareBracket &&\n    (!footnotes || value.charAt(index + 1) !== caret)\n  ) {\n    identifier = ''\n    queue += character\n    index++\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character === leftSquareBracket || character === rightSquareBracket) {\n        break\n      }\n\n      if (character === backslash) {\n        identifier += backslash\n        character = value.charAt(++index)\n      }\n\n      identifier += character\n      index++\n    }\n\n    character = value.charAt(index)\n\n    if (character === rightSquareBracket) {\n      referenceType = identifier ? full : collapsed\n      queue += identifier + character\n      index++\n    } else {\n      identifier = ''\n    }\n\n    subvalue += queue\n    queue = ''\n  } else {\n    if (!content) {\n      return\n    }\n\n    identifier = content\n  }\n\n  // Brackets cannot be inside the identifier.\n  if (referenceType !== full && bracketed) {\n    return\n  }\n\n  subvalue = intro + subvalue\n\n  if (type === link && self.inLink) {\n    return null\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  if (type === footnote && content.indexOf(space) !== -1) {\n    return eat(subvalue)({\n      type: footnote,\n      children: this.tokenizeInline(content, eat.now())\n    })\n  }\n\n  now = eat.now()\n  now.column += intro.length\n  now.offset += intro.length\n  identifier = referenceType === full ? identifier : content\n\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier),\n    label: identifier\n  }\n\n  if (type === link || type === image) {\n    node.referenceType = referenceType\n  }\n\n  if (type === link) {\n    exit = self.enterLink()\n    node.children = self.tokenizeInline(content, now)\n    exit()\n  } else if (type === image) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null\n  }\n\n  return eat(subvalue)(node)\n}\n","'use strict'\n\nmodule.exports = locate\n\nfunction locate(value, fromIndex) {\n  var asterisk = value.indexOf('**', fromIndex)\n  var underscore = value.indexOf('__', fromIndex)\n\n  if (underscore === -1) {\n    return asterisk\n  }\n\n  if (asterisk === -1) {\n    return underscore\n  }\n\n  return underscore < asterisk ? underscore : asterisk\n}\n","'use strict'\n\nvar trim = require('trim')\nvar whitespace = require('is-whitespace-character')\nvar locate = require('../locate/strong')\n\nmodule.exports = strong\nstrong.locator = locate\n\nvar backslash = '\\\\'\nvar asterisk = '*'\nvar underscore = '_'\n\nfunction strong(eat, value, silent) {\n  var self = this\n  var index = 0\n  var character = value.charAt(index)\n  var now\n  var pedantic\n  var marker\n  var queue\n  var subvalue\n  var length\n  var prev\n\n  if (\n    (character !== asterisk && character !== underscore) ||\n    value.charAt(++index) !== character\n  ) {\n    return\n  }\n\n  pedantic = self.options.pedantic\n  marker = character\n  subvalue = marker + marker\n  length = value.length\n  index++\n  queue = ''\n  character = ''\n\n  if (pedantic && whitespace(value.charAt(index))) {\n    return\n  }\n\n  while (index < length) {\n    prev = character\n    character = value.charAt(index)\n\n    if (\n      character === marker &&\n      value.charAt(index + 1) === marker &&\n      (!pedantic || !whitespace(prev))\n    ) {\n      character = value.charAt(index + 2)\n\n      if (character !== marker) {\n        if (!trim(queue)) {\n          return\n        }\n\n        /* istanbul ignore if - never used (yet) */\n        if (silent) {\n          return true\n        }\n\n        now = eat.now()\n        now.column += 2\n        now.offset += 2\n\n        return eat(subvalue + queue + subvalue)({\n          type: 'strong',\n          children: self.tokenizeInline(queue, now)\n        })\n      }\n    }\n\n    if (!pedantic && character === backslash) {\n      queue += character\n      character = value.charAt(++index)\n    }\n\n    queue += character\n    index++\n  }\n}\n","'use strict'\n\nmodule.exports = wordCharacter\n\nvar fromCode = String.fromCharCode\nvar re = /\\w/\n\n// Check if the given character code, or the character code at the first\n// character, is a word character.\nfunction wordCharacter(character) {\n  return re.test(\n    typeof character === 'number' ? fromCode(character) : character.charAt(0)\n  )\n}\n","'use strict'\n\nmodule.exports = locate\n\nfunction locate(value, fromIndex) {\n  var asterisk = value.indexOf('*', fromIndex)\n  var underscore = value.indexOf('_', fromIndex)\n\n  if (underscore === -1) {\n    return asterisk\n  }\n\n  if (asterisk === -1) {\n    return underscore\n  }\n\n  return underscore < asterisk ? underscore : asterisk\n}\n","'use strict'\n\nvar trim = require('trim')\nvar word = require('is-word-character')\nvar whitespace = require('is-whitespace-character')\nvar locate = require('../locate/emphasis')\n\nmodule.exports = emphasis\nemphasis.locator = locate\n\nvar asterisk = '*'\nvar underscore = '_'\nvar backslash = '\\\\'\n\nfunction emphasis(eat, value, silent) {\n  var self = this\n  var index = 0\n  var character = value.charAt(index)\n  var now\n  var pedantic\n  var marker\n  var queue\n  var subvalue\n  var length\n  var prev\n\n  if (character !== asterisk && character !== underscore) {\n    return\n  }\n\n  pedantic = self.options.pedantic\n  subvalue = character\n  marker = character\n  length = value.length\n  index++\n  queue = ''\n  character = ''\n\n  if (pedantic && whitespace(value.charAt(index))) {\n    return\n  }\n\n  while (index < length) {\n    prev = character\n    character = value.charAt(index)\n\n    if (character === marker && (!pedantic || !whitespace(prev))) {\n      character = value.charAt(++index)\n\n      if (character !== marker) {\n        if (!trim(queue) || prev === marker) {\n          return\n        }\n\n        if (!pedantic && marker === underscore && word(character)) {\n          queue += marker\n          continue\n        }\n\n        /* istanbul ignore if - never used (yet) */\n        if (silent) {\n          return true\n        }\n\n        now = eat.now()\n        now.column++\n        now.offset++\n\n        return eat(subvalue + queue + marker)({\n          type: 'emphasis',\n          children: self.tokenizeInline(queue, now)\n        })\n      }\n\n      queue += marker\n    }\n\n    if (!pedantic && character === backslash) {\n      queue += character\n      character = value.charAt(++index)\n    }\n\n    queue += character\n    index++\n  }\n}\n","'use strict'\n\nmodule.exports = locate\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('~~', fromIndex)\n}\n","'use strict'\n\nvar whitespace = require('is-whitespace-character')\nvar locate = require('../locate/delete')\n\nmodule.exports = strikethrough\nstrikethrough.locator = locate\n\nvar tilde = '~'\nvar fence = '~~'\n\nfunction strikethrough(eat, value, silent) {\n  var self = this\n  var character = ''\n  var previous = ''\n  var preceding = ''\n  var subvalue = ''\n  var index\n  var length\n  var now\n\n  if (\n    !self.options.gfm ||\n    value.charAt(0) !== tilde ||\n    value.charAt(1) !== tilde ||\n    whitespace(value.charAt(2))\n  ) {\n    return\n  }\n\n  index = 1\n  length = value.length\n  now = eat.now()\n  now.column += 2\n  now.offset += 2\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (\n      character === tilde &&\n      previous === tilde &&\n      (!preceding || !whitespace(preceding))\n    ) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true\n      }\n\n      return eat(fence + subvalue + fence)({\n        type: 'delete',\n        children: self.tokenizeInline(subvalue, now)\n      })\n    }\n\n    subvalue += previous\n    preceding = previous\n    previous = character\n  }\n}\n","'use strict'\n\nmodule.exports = locate\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('`', fromIndex)\n}\n","'use strict'\n\nvar locate = require('../locate/code-inline')\n\nmodule.exports = inlineCode\ninlineCode.locator = locate\n\nvar lineFeed = 10 //  '\\n'\nvar space = 32 // ' '\nvar graveAccent = 96 //  '`'\n\nfunction inlineCode(eat, value, silent) {\n  var length = value.length\n  var index = 0\n  var openingFenceEnd\n  var closingFenceStart\n  var closingFenceEnd\n  var code\n  var next\n  var found\n\n  while (index < length) {\n    if (value.charCodeAt(index) !== graveAccent) {\n      break\n    }\n\n    index++\n  }\n\n  if (index === 0 || index === length) {\n    return\n  }\n\n  openingFenceEnd = index\n  next = value.charCodeAt(index)\n\n  while (index < length) {\n    code = next\n    next = value.charCodeAt(index + 1)\n\n    if (code === graveAccent) {\n      if (closingFenceStart === undefined) {\n        closingFenceStart = index\n      }\n\n      closingFenceEnd = index + 1\n\n      if (\n        next !== graveAccent &&\n        closingFenceEnd - closingFenceStart === openingFenceEnd\n      ) {\n        found = true\n        break\n      }\n    } else if (closingFenceStart !== undefined) {\n      closingFenceStart = undefined\n      closingFenceEnd = undefined\n    }\n\n    index++\n  }\n\n  if (!found) {\n    return\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  // Remove the initial and final space (or line feed), iff they exist and there\n  // are non-space characters in the content.\n  index = openingFenceEnd\n  length = closingFenceStart\n  code = value.charCodeAt(index)\n  next = value.charCodeAt(length - 1)\n  found = false\n\n  if (\n    length - index > 2 &&\n    (code === space || code === lineFeed) &&\n    (next === space || next === lineFeed)\n  ) {\n    index++\n    length--\n\n    while (index < length) {\n      code = value.charCodeAt(index)\n\n      if (code !== space && code !== lineFeed) {\n        found = true\n        break\n      }\n\n      index++\n    }\n\n    if (found === true) {\n      openingFenceEnd++\n      closingFenceStart--\n    }\n  }\n\n  return eat(value.slice(0, closingFenceEnd))({\n    type: 'inlineCode',\n    value: value.slice(openingFenceEnd, closingFenceStart)\n  })\n}\n","'use strict'\n\nmodule.exports = locate\n\nfunction locate(value, fromIndex) {\n  var index = value.indexOf('\\n', fromIndex)\n\n  while (index > fromIndex) {\n    if (value.charAt(index - 1) !== ' ') {\n      break\n    }\n\n    index--\n  }\n\n  return index\n}\n","'use strict'\n\nvar locate = require('../locate/break')\n\nmodule.exports = hardBreak\nhardBreak.locator = locate\n\nvar space = ' '\nvar lineFeed = '\\n'\nvar minBreakLength = 2\n\nfunction hardBreak(eat, value, silent) {\n  var length = value.length\n  var index = -1\n  var queue = ''\n  var character\n\n  while (++index < length) {\n    character = value.charAt(index)\n\n    if (character === lineFeed) {\n      if (index < minBreakLength) {\n        return\n      }\n\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true\n      }\n\n      queue += character\n\n      return eat(queue)({type: 'break'})\n    }\n\n    if (character !== space) {\n      return\n    }\n\n    queue += character\n  }\n}\n","'use strict'\n\nmodule.exports = text\n\nfunction text(eat, value, silent) {\n  var self = this\n  var methods\n  var tokenizers\n  var index\n  var length\n  var subvalue\n  var position\n  var tokenizer\n  var name\n  var min\n  var now\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  methods = self.inlineMethods\n  length = methods.length\n  tokenizers = self.inlineTokenizers\n  index = -1\n  min = value.length\n\n  while (++index < length) {\n    name = methods[index]\n\n    if (name === 'text' || !tokenizers[name]) {\n      continue\n    }\n\n    tokenizer = tokenizers[name].locator\n\n    if (!tokenizer) {\n      eat.file.fail('Missing locator: `' + name + '`')\n    }\n\n    position = tokenizer.call(self, value, 1)\n\n    if (position !== -1 && position < min) {\n      min = position\n    }\n  }\n\n  subvalue = value.slice(0, min)\n  now = eat.now()\n\n  self.decode(subvalue, now, handler)\n\n  function handler(content, position, source) {\n    eat(source || content)({type: 'text', value: content})\n  }\n}\n","'use strict'\n\nvar xtend = require('xtend')\nvar toggle = require('state-toggle')\nvar vfileLocation = require('vfile-location')\nvar unescape = require('./unescape')\nvar decode = require('./decode')\nvar tokenizer = require('./tokenizer')\n\nmodule.exports = Parser\n\nfunction Parser(doc, file) {\n  this.file = file\n  this.offset = {}\n  this.options = xtend(this.options)\n  this.setOptions({})\n\n  this.inList = false\n  this.inBlock = false\n  this.inLink = false\n  this.atStart = true\n\n  this.toOffset = vfileLocation(file).toOffset\n  this.unescape = unescape(this, 'escape')\n  this.decode = decode(this)\n}\n\nvar proto = Parser.prototype\n\n// Expose core.\nproto.setOptions = require('./set-options')\nproto.parse = require('./parse')\n\n// Expose `defaults`.\nproto.options = require('./defaults')\n\n// Enter and exit helpers.\nproto.exitStart = toggle('atStart', true)\nproto.enterList = toggle('inList', false)\nproto.enterLink = toggle('inLink', false)\nproto.enterBlock = toggle('inBlock', false)\n\n// Nodes that can interupt a paragraph:\n//\n// ```markdown\n// A paragraph, followed by a thematic break.\n// ___\n// ```\n//\n// In the above example, the thematic break “interupts” the paragraph.\nproto.interruptParagraph = [\n  ['thematicBreak'],\n  ['atxHeading'],\n  ['fencedCode'],\n  ['blockquote'],\n  ['html'],\n  ['setextHeading', {commonmark: false}],\n  ['definition', {commonmark: false}],\n  ['footnote', {commonmark: false}]\n]\n\n// Nodes that can interupt a list:\n//\n// ```markdown\n// - One\n// ___\n// ```\n//\n// In the above example, the thematic break “interupts” the list.\nproto.interruptList = [\n  ['atxHeading', {pedantic: false}],\n  ['fencedCode', {pedantic: false}],\n  ['thematicBreak', {pedantic: false}],\n  ['definition', {commonmark: false}],\n  ['footnote', {commonmark: false}]\n]\n\n// Nodes that can interupt a blockquote:\n//\n// ```markdown\n// > A paragraph.\n// ___\n// ```\n//\n// In the above example, the thematic break “interupts” the blockquote.\nproto.interruptBlockquote = [\n  ['indentedCode', {commonmark: true}],\n  ['fencedCode', {commonmark: true}],\n  ['atxHeading', {commonmark: true}],\n  ['setextHeading', {commonmark: true}],\n  ['thematicBreak', {commonmark: true}],\n  ['html', {commonmark: true}],\n  ['list', {commonmark: true}],\n  ['definition', {commonmark: false}],\n  ['footnote', {commonmark: false}]\n]\n\n// Handlers.\nproto.blockTokenizers = {\n  newline: require('./tokenize/newline'),\n  indentedCode: require('./tokenize/code-indented'),\n  fencedCode: require('./tokenize/code-fenced'),\n  blockquote: require('./tokenize/blockquote'),\n  atxHeading: require('./tokenize/heading-atx'),\n  thematicBreak: require('./tokenize/thematic-break'),\n  list: require('./tokenize/list'),\n  setextHeading: require('./tokenize/heading-setext'),\n  html: require('./tokenize/html-block'),\n  footnote: require('./tokenize/footnote-definition'),\n  definition: require('./tokenize/definition'),\n  table: require('./tokenize/table'),\n  paragraph: require('./tokenize/paragraph')\n}\n\nproto.inlineTokenizers = {\n  escape: require('./tokenize/escape'),\n  autoLink: require('./tokenize/auto-link'),\n  url: require('./tokenize/url'),\n  html: require('./tokenize/html-inline'),\n  link: require('./tokenize/link'),\n  reference: require('./tokenize/reference'),\n  strong: require('./tokenize/strong'),\n  emphasis: require('./tokenize/emphasis'),\n  deletion: require('./tokenize/delete'),\n  code: require('./tokenize/code-inline'),\n  break: require('./tokenize/break'),\n  text: require('./tokenize/text')\n}\n\n// Expose precedence.\nproto.blockMethods = keys(proto.blockTokenizers)\nproto.inlineMethods = keys(proto.inlineTokenizers)\n\n// Tokenizers.\nproto.tokenizeBlock = tokenizer('block')\nproto.tokenizeInline = tokenizer('inline')\nproto.tokenizeFactory = tokenizer\n\n// Get all keys in `value`.\nfunction keys(value) {\n  var result = []\n  var key\n\n  for (key in value) {\n    result.push(key)\n  }\n\n  return result\n}\n","'use strict'\n\nvar unherit = require('unherit')\nvar xtend = require('xtend')\nvar Parser = require('./lib/parser.js')\n\nmodule.exports = parse\nparse.Parser = Parser\n\nfunction parse(options) {\n  var settings = this.data('settings')\n  var Local = unherit(Parser)\n\n  Local.prototype.options = xtend(Local.prototype.options, settings, options)\n\n  this.Parser = Local\n}\n","//\n// format - printf-like string formatting for JavaScript\n// github.com/samsonjs/format\n// @_sjs\n//\n// Copyright 2010 - 2013 Sami Samhuri <sami@samhuri.net>\n//\n// MIT License\n// http://sjs.mit-license.org\n//\n\n;(function() {\n\n  //// Export the API\n  var namespace;\n\n  // CommonJS / Node module\n  if (typeof module !== 'undefined') {\n    namespace = module.exports = format;\n  }\n\n  // Browsers and other environments\n  else {\n    // Get the global object. Works in ES3, ES5, and ES5 strict mode.\n    namespace = (function(){ return this || (1,eval)('this') }());\n  }\n\n  namespace.format = format;\n  namespace.vsprintf = vsprintf;\n\n  if (typeof console !== 'undefined' && typeof console.log === 'function') {\n    namespace.printf = printf;\n  }\n\n  function printf(/* ... */) {\n    console.log(format.apply(null, arguments));\n  }\n\n  function vsprintf(fmt, replacements) {\n    return format.apply(null, [fmt].concat(replacements));\n  }\n\n  function format(fmt) {\n    var argIndex = 1 // skip initial format argument\n      , args = [].slice.call(arguments)\n      , i = 0\n      , n = fmt.length\n      , result = ''\n      , c\n      , escaped = false\n      , arg\n      , tmp\n      , leadingZero = false\n      , precision\n      , nextArg = function() { return args[argIndex++]; }\n      , slurpNumber = function() {\n          var digits = '';\n          while (/\\d/.test(fmt[i])) {\n            digits += fmt[i++];\n            c = fmt[i];\n          }\n          return digits.length > 0 ? parseInt(digits) : null;\n        }\n      ;\n    for (; i < n; ++i) {\n      c = fmt[i];\n      if (escaped) {\n        escaped = false;\n        if (c == '.') {\n          leadingZero = false;\n          c = fmt[++i];\n        }\n        else if (c == '0' && fmt[i + 1] == '.') {\n          leadingZero = true;\n          i += 2;\n          c = fmt[i];\n        }\n        else {\n          leadingZero = true;\n        }\n        precision = slurpNumber();\n        switch (c) {\n        case 'b': // number in binary\n          result += parseInt(nextArg(), 10).toString(2);\n          break;\n        case 'c': // character\n          arg = nextArg();\n          if (typeof arg === 'string' || arg instanceof String)\n            result += arg;\n          else\n            result += String.fromCharCode(parseInt(arg, 10));\n          break;\n        case 'd': // number in decimal\n          result += parseInt(nextArg(), 10);\n          break;\n        case 'f': // floating point number\n          tmp = String(parseFloat(nextArg()).toFixed(precision || 6));\n          result += leadingZero ? tmp : tmp.replace(/^0/, '');\n          break;\n        case 'j': // JSON\n          result += JSON.stringify(nextArg());\n          break;\n        case 'o': // number in octal\n          result += '0' + parseInt(nextArg(), 10).toString(8);\n          break;\n        case 's': // string\n          result += nextArg();\n          break;\n        case 'x': // lowercase hexadecimal\n          result += '0x' + parseInt(nextArg(), 10).toString(16);\n          break;\n        case 'X': // uppercase hexadecimal\n          result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();\n          break;\n        default:\n          result += c;\n          break;\n        }\n      } else if (c === '%') {\n        escaped = true;\n      } else {\n        result += c;\n      }\n    }\n    return result;\n  }\n\n}());\n","'use strict'\n\nvar formatter = require('format')\n\nvar fault = create(Error)\n\nmodule.exports = fault\n\nfault.eval = create(EvalError)\nfault.range = create(RangeError)\nfault.reference = create(ReferenceError)\nfault.syntax = create(SyntaxError)\nfault.type = create(TypeError)\nfault.uri = create(URIError)\n\nfault.create = create\n\n// Create a new `EConstructor`, with the formatted `format` as a first argument.\nfunction create(EConstructor) {\n  FormattedError.displayName = EConstructor.displayName || EConstructor.name\n\n  return FormattedError\n\n  function FormattedError(format) {\n    if (format) {\n      format = formatter.apply(null, arguments)\n    }\n\n    return new EConstructor(format)\n  }\n}\n","'use strict'\n\nvar fault = require('fault')\n\nmodule.exports = matters\n\nvar own = {}.hasOwnProperty\n\nvar markers = {\n  yaml: '-',\n  toml: '+'\n}\n\nfunction matters(options) {\n  var results = []\n  var index = -1\n  var length\n\n  // One preset or matter.\n  if (typeof options === 'string' || !('length' in options)) {\n    options = [options]\n  }\n\n  length = options.length\n\n  while (++index < length) {\n    results[index] = matter(options[index])\n  }\n\n  return results\n}\n\nfunction matter(option) {\n  var result = option\n\n  if (typeof result === 'string') {\n    if (!own.call(markers, result)) {\n      throw fault('Missing matter definition for `%s`', result)\n    }\n\n    result = {type: result, marker: markers[result]}\n  } else if (typeof result !== 'object') {\n    throw fault('Expected matter to be an object, not `%j`', result)\n  }\n\n  if (!own.call(result, 'type')) {\n    throw fault('Missing `type` in matter `%j`', result)\n  }\n\n  if (!own.call(result, 'fence') && !own.call(result, 'marker')) {\n    throw fault('Missing `marker` or `fence` in matter `%j`', result)\n  }\n\n  return result\n}\n","'use strict'\n\nmodule.exports = fence\n\nfunction fence(matter, prop) {\n  var marker\n\n  if (matter.marker) {\n    marker = pick(matter.marker, prop)\n    return marker + marker + marker\n  }\n\n  return pick(matter.fence, prop)\n}\n\nfunction pick(schema, prop) {\n  return typeof schema === 'string' ? schema : schema[prop]\n}\n","'use strict'\n\nvar fence = require('./fence')\n\nmodule.exports = create\n\nfunction create(matter) {\n  var name = matter.type + 'FrontMatter'\n  var open = fence(matter, 'open')\n  var close = fence(matter, 'close')\n  var newline = '\\n'\n  var anywhere = matter.anywhere\n\n  frontmatter.displayName = name\n  frontmatter.onlyAtStart = typeof anywhere === 'boolean' ? !anywhere : true\n\n  return [name, frontmatter]\n\n  function frontmatter(eat, value, silent) {\n    var index = open.length\n    var offset\n\n    if (value.slice(0, index) !== open || value.charAt(index) !== newline) {\n      return\n    }\n\n    offset = value.indexOf(close, index)\n\n    while (offset !== -1 && value.charAt(offset - 1) !== newline) {\n      index = offset + close.length\n      offset = value.indexOf(close, index)\n    }\n\n    if (offset !== -1) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true\n      }\n\n      return eat(value.slice(0, offset + close.length))({\n        type: matter.type,\n        value: value.slice(open.length + 1, offset - 1)\n      })\n    }\n  }\n}\n","'use strict'\n\nvar fence = require('./fence')\n\nmodule.exports = create\n\nfunction create(matter) {\n  var type = matter.type\n  var open = fence(matter, 'open')\n  var close = fence(matter, 'close')\n\n  frontmatter.displayName = type + 'FrontMatter'\n\n  return [type, frontmatter]\n\n  function frontmatter(node) {\n    return open + (node.value ? '\\n' + node.value : '') + '\\n' + close\n  }\n}\n","'use strict'\n\nvar xtend = require('xtend')\nvar matters = require('./lib/matters')\nvar parse = require('./lib/parse')\nvar compile = require('./lib/compile')\n\nmodule.exports = frontmatter\n\nfunction frontmatter(options) {\n  var parser = this.Parser\n  var compiler = this.Compiler\n  var config = matters(options || ['yaml'])\n\n  if (isRemarkParser(parser)) {\n    attachParser(parser, config)\n  }\n\n  if (isRemarkCompiler(compiler)) {\n    attachCompiler(compiler, config)\n  }\n}\n\nfunction attachParser(parser, matters) {\n  var proto = parser.prototype\n  var tokenizers = wrap(parse, matters)\n  var names = []\n  var key\n\n  for (key in tokenizers) {\n    names.push(key)\n  }\n\n  proto.blockMethods = names.concat(proto.blockMethods)\n  proto.blockTokenizers = xtend(tokenizers, proto.blockTokenizers)\n}\n\nfunction attachCompiler(compiler, matters) {\n  var proto = compiler.prototype\n  proto.visitors = xtend(wrap(compile, matters), proto.visitors)\n}\n\nfunction wrap(func, matters) {\n  var result = {}\n  var length = matters.length\n  var index = -1\n  var tuple\n\n  while (++index < length) {\n    tuple = func(matters[index])\n    result[tuple[0]] = tuple[1]\n  }\n\n  return result\n}\n\nfunction isRemarkParser(parser) {\n  return Boolean(parser && parser.prototype && parser.prototype.blockTokenizers)\n}\n\nfunction isRemarkCompiler(compiler) {\n  return Boolean(compiler && compiler.prototype && compiler.prototype.visitors)\n}\n","/**\n * @fileOverview\n *\n * This file contains the types for the parser.\n *\n * - Chars\n * - Pairs\n * - Marks\n * - Tokens\n */\n\n// Char\n\nimport { Validation } from '../report'\n\nexport enum CharType {\n  EMPTY = 'empty',\n  SPACE = 'space',\n  LETTERS_HALF = 'letters-half',\n  LETTERS_FULL = 'letters-full',\n  PUNCTUATION_HALF = 'punctuation-half',\n  PUNCTUATION_FULL = 'punctuation-full',\n  UNKNOWN = 'unknown'\n}\n\ntype CharSet = {\n  [setName: string]: string\n}\n\nexport const BRACKET_CHAR_SET: CharSet = {\n  left: '(（',\n  right: ')）'\n}\nexport const QUOTE_CHAR_SET: CharSet = {\n  left: `“‘《〈『「【{`,\n  right: `”’》〉』」】}`,\n  neutral: `'\"`\n}\nexport const SHORTHAND_CHARS = `'’`\nexport const SHORTHAND_PAIR_SET: CharSet = {\n  [`'`]: `'`,\n  [`’`]: `‘`\n}\n\nconst FULL_WIDTH_PAIRS = `“”‘’（）「」『』《》〈〉【】`\n\nexport const isFullWidthPair = (str: string): boolean =>\n  FULL_WIDTH_PAIRS.indexOf(str) >= 0\n\n// Reusable\n\ntype Pair = {\n  startIndex: number\n  startContent: string\n  endIndex: number\n  endContent: string\n}\n\ntype MutablePair = {\n  modifiedStartContent: string\n  modifiedEndContent: string\n}\n\n// Mark\n\n/**\n * Marks are hyper info, including content and wrappers.\n * They are categorized by parsers, not by usage.\n */\nexport enum MarkType {\n  /**\n   * Brackets\n   */\n  BRACKETS = 'brackets',\n  /**\n   * Inline Markdown marks\n   */\n  HYPER = 'hyper',\n  /**\n   * - \\`xxx\\`\n   * - &lt;code&gt;xxx&lt;/code&gt;\n   * - Hexo/VuePress container\n   * - Other html code\n   */\n  RAW = 'raw'\n}\n\nexport enum MarkSideType {\n  LEFT = 'left',\n  RIGHT = 'right'\n}\n\nexport type Mark = Pair & {\n  type: MarkType\n  meta?: string // AST type enum\n}\n\nexport type RawMark = Mark & {\n  code: MarkSideType\n  rightPair?: RawMark\n}\n\nexport type MutableMark = Mark & MutablePair\n\nexport type MutableRawMark = RawMark & MutablePair\n\nexport type MarkMap = {\n  [index: number]: Mark\n}\n\nexport const isRawMark = (mark: Mark): mark is RawMark => {\n  return (mark as RawMark).code !== undefined\n}\n\n// Token type\n\nexport type LettersType = CharType.LETTERS_FULL | CharType.LETTERS_HALF\n\nexport type PunctuationType =\n  | CharType.PUNCTUATION_FULL\n  | CharType.PUNCTUATION_HALF\n\nexport type ContentTokenType = LettersType | PunctuationType\n\n/**\n * TODO: paired html tags should be hyper wrapper\n */\nexport enum HyperTokenType {\n  /**\n   * Brackets\n   */\n  HYPER_WRAPPER_BRACKET = 'wrapper-bracket',\n  /**\n   * Inline Markdown marks\n   */\n  HYPER_WRAPPER = 'wrapper',\n  /**\n   * - \\`xxx\\`\n   * - &lt;code&gt;xxx&lt;/code&gt;\n   */\n  HYPER_CONTENT_CODE = 'hyper-content-code',\n  /**\n   * - Hexo/VuePress container\n   * - Other html code\n   */\n  HYPER_CONTENT = 'hyper-content',\n  /**\n   * Unpaired brackets/quotes\n   */\n  UNMATCHED = 'unmatched',\n  /**\n   * For indeterminate tokens\n   */\n  INDETERMINATED = 'indeterminated'\n}\n\nexport enum GroupTokenType {\n  GROUP = 'group'\n}\n\nexport type SingleTokenType = ContentTokenType | HyperTokenType\n\nexport type TokenType = SingleTokenType | GroupTokenType\n\nexport type NonCodeVisibleTokenType =\n  | ContentTokenType\n  | HyperTokenType.HYPER_WRAPPER_BRACKET\n  | GroupTokenType.GROUP\n\nexport type VisibleTokenType =\n  | NonCodeVisibleTokenType\n  | HyperTokenType.HYPER_CONTENT_CODE\n\nexport type InvisibleTokenType = HyperTokenType.HYPER_WRAPPER\n\nexport const isLettersType = (\n  type: TokenType | CharType\n): type is LettersType => {\n  return type === CharType.LETTERS_FULL || type === CharType.LETTERS_HALF\n}\n\nexport const isPunctuationType = (\n  type: TokenType | CharType\n): type is PunctuationType => {\n  return (\n    type === CharType.PUNCTUATION_FULL || type === CharType.PUNCTUATION_HALF\n  )\n}\n\nexport const isNonCodeVisibleType = (\n  type: TokenType | CharType\n): type is LettersType => {\n  return (\n    isLettersType(type) ||\n    isPunctuationType(type) ||\n    type === HyperTokenType.HYPER_WRAPPER_BRACKET ||\n    type === GroupTokenType.GROUP\n  )\n}\n\nexport const isVisibleType = (\n  type: TokenType | CharType\n): type is VisibleTokenType => {\n  return (\n    isNonCodeVisibleType(type) || type === HyperTokenType.HYPER_CONTENT_CODE\n  )\n}\n\nexport const isInvisibleType = (\n  type: TokenType | CharType\n): type is InvisibleTokenType => {\n  return type === HyperTokenType.HYPER_WRAPPER\n}\n\n// Token\n\ntype CommonToken = {\n  index: number\n  length: number\n\n  content: string\n  spaceAfter: string\n\n  mark?: Mark\n  markSide?: MarkSideType\n}\n\ntype MutableCommonToken = CommonToken & {\n  modifiedContent: string\n  modifiedSpaceAfter: string\n  validations: Validation[]\n}\n\nexport type SingleToken = CommonToken & {\n  type: SingleTokenType\n}\n\nexport type MutableSingleToken = MutableCommonToken & {\n  type: SingleTokenType\n  modifiedType: SingleTokenType\n}\n\nexport type GroupToken = Array<Token> &\n  CommonToken &\n  Pair & {\n    type: GroupTokenType\n    innerSpaceBefore: string\n  }\n\nexport type MutableGroupToken = Array<MutableToken> &\n  MutableCommonToken &\n  Pair &\n  MutablePair & {\n    type: GroupTokenType\n    modifiedType: GroupTokenType\n    innerSpaceBefore: string\n    modifiedInnerSpaceBefore: string\n  }\n\nexport type Token = SingleToken | GroupToken\n\nexport type MutableToken = MutableSingleToken | MutableGroupToken\n","import { CharType } from './types'\n\n/**\n * Check whether the character is full-width or half-width,\n * content or punctuation, or empty, or space, or emoji etc.\n * Refs:\n * - https://jrgraphix.net/research/unicode.php\n * - https://mathiasbynens.be/notes/javascript-unicode\n * - https://stackoverflow.com/a/21113538\n */\nexport const checkCharType = (char: string): CharType => {\n  if (char === '') {\n    return CharType.EMPTY\n  }\n\n  // space\n  if (char.match(/\\s/) != null) {\n    return CharType.SPACE\n  }\n\n  // 0-9\n  if (char.match(/[0-9]/) != null) {\n    return CharType.LETTERS_HALF\n  }\n\n  if (',.;:?!~-+*/\\\\%=&|\"\\'`()[]{}<>@#$^'.indexOf(char) >= 0) {\n    return CharType.PUNCTUATION_HALF\n  }\n\n  if ('，。、；：？！…—～｜·‘’“”《》【】「」（）'.indexOf(char) >= 0) {\n    return CharType.PUNCTUATION_FULL\n  }\n\n  // Basic Latin\n  if (char.match(/[\\u0020-\\u007F]/) != null) {\n    return CharType.LETTERS_HALF\n  }\n  // Latin-1 Supplement\n  if (char.match(/[\\u00A0-\\u00FF]/) != null) {\n    return CharType.LETTERS_HALF\n  }\n  // Latin Extended-A\n  if (char.match(/[\\u0100-\\u017F]/) != null) {\n    return CharType.LETTERS_HALF\n  }\n  // Latin Extended-B\n  if (char.match(/[\\u0180-\\u024F]/) != null) {\n    return CharType.LETTERS_HALF\n  }\n  // Greek and Coptic\n  if (char.match(/[\\u0370-\\u03FF]/) != null) {\n    return CharType.LETTERS_HALF\n  }\n\n  // CJK Unified Ideographs\n  if (char.match(/[\\u4E00-\\u9FFF]/) != null) {\n    return CharType.LETTERS_FULL\n  }\n  // CJK Unified Ideographs Extension A\n  if (char.match(/[\\u3400-\\u4DBF]/) != null) {\n    return CharType.LETTERS_FULL\n  }\n  // CJK Unified Ideographs Extension B\n  if (\n    char.match(/[\\ud840-\\ud868][\\udc00-\\udfff]|\\ud869[\\udc00-\\uded6]/) != null\n  ) {\n    return CharType.LETTERS_FULL\n  }\n  // CJK Unified Ideographs Extension C\n  if (\n    char.match(\n      /\\ud869[\\udf00-\\udfff]|[\\ud86a-\\ud86c][\\udc00-\\udfff]|\\ud86d[\\udc00-\\udf34]/\n    ) != null\n  ) {\n    return CharType.LETTERS_FULL\n  }\n  // CJK Unified Ideographs Extension D\n  if (char.match(/\\ud86d[\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d]/) != null) {\n    return CharType.LETTERS_FULL\n  }\n  // CJK Compatibility Ideographs\n  if (char.match(/[\\uF900-\\uFAFF]/) != null) {\n    return CharType.LETTERS_FULL\n  }\n  // CJK Compatibility Forms\n  if (char.match(/[\\uFE30-\\uFE4F]/) != null) {\n    return CharType.LETTERS_FULL\n  }\n  // CJK Radicals Supplement\n  if (char.match(/[\\u2E80-\\u2EFF]/) != null) {\n    return CharType.LETTERS_FULL\n  }\n  // Private Use Area (part)\n  if (char.match(/[\\uE815-\\uE864]/) != null) {\n    return CharType.LETTERS_FULL\n  }\n  // CJK Unified Ideographs Extension B\n  if (char.match(/[\\u{20000}-\\u{2A6DF}]/u) != null) {\n    return CharType.LETTERS_FULL\n  }\n  // CJK Compatibility Ideographs Supplement\n  if (char.match(/[\\u{2F800}-\\u{2FA1F}]/u) != null) {\n    return CharType.LETTERS_FULL\n  }\n\n  // CJK Symbols and Punctuation\n  if (char.match(/[\\u3000-\\u303F]/) != null) {\n    return CharType.PUNCTUATION_FULL\n  }\n\n  return CharType.UNKNOWN\n}\n","'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n","/* MIT license */\n/* eslint-disable no-mixed-operators */\nconst cssKeywords = require('color-name');\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nconst reverseKeywords = {};\nfor (const key of Object.keys(cssKeywords)) {\n\treverseKeywords[cssKeywords[key]] = key;\n}\n\nconst convert = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\nmodule.exports = convert;\n\n// Hide .channels and .labels properties\nfor (const model of Object.keys(convert)) {\n\tif (!('channels' in convert[model])) {\n\t\tthrow new Error('missing channels property: ' + model);\n\t}\n\n\tif (!('labels' in convert[model])) {\n\t\tthrow new Error('missing channel labels property: ' + model);\n\t}\n\n\tif (convert[model].labels.length !== convert[model].channels) {\n\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t}\n\n\tconst {channels, labels} = convert[model];\n\tdelete convert[model].channels;\n\tdelete convert[model].labels;\n\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\tObject.defineProperty(convert[model], 'labels', {value: labels});\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst min = Math.min(r, g, b);\n\tconst max = Math.max(r, g, b);\n\tconst delta = max - min;\n\tlet h;\n\tlet s;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst l = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tlet rdif;\n\tlet gdif;\n\tlet bdif;\n\tlet h;\n\tlet s;\n\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst v = Math.max(r, g, b);\n\tconst diff = v - Math.min(r, g, b);\n\tconst diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = 0;\n\t\ts = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tconst r = rgb[0];\n\tconst g = rgb[1];\n\tlet b = rgb[2];\n\tconst h = convert.rgb.hsl(rgb)[0];\n\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\n\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\tconst c = (1 - r - k) / (1 - k) || 0;\n\tconst m = (1 - g - k) / (1 - k) || 0;\n\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\nfunction comparativeDistance(x, y) {\n\t/*\n\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t*/\n\treturn (\n\t\t((x[0] - y[0]) ** 2) +\n\t\t((x[1] - y[1]) ** 2) +\n\t\t((x[2] - y[2]) ** 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tconst reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tlet currentClosestDistance = Infinity;\n\tlet currentClosestKeyword;\n\n\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\tconst value = cssKeywords[keyword];\n\n\t\t// Compute comparative distance\n\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t// Check if its less, if so set as closest\n\t\tif (distance < currentClosestDistance) {\n\t\t\tcurrentClosestDistance = distance;\n\t\t\tcurrentClosestKeyword = keyword;\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tlet r = rgb[0] / 255;\n\tlet g = rgb[1] / 255;\n\tlet b = rgb[2] / 255;\n\n\t// Assume sRGB\n\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tconst xyz = convert.rgb.xyz(rgb);\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tconst h = hsl[0] / 360;\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\tlet t2;\n\tlet t3;\n\tlet val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tconst t1 = 2 * l - t2;\n\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tconst h = hsl[0];\n\tlet s = hsl[1] / 100;\n\tlet l = hsl[2] / 100;\n\tlet smin = s;\n\tconst lmin = Math.max(l, 0.01);\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tconst v = (l + s) / 2;\n\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tconst h = hsv[0] / 60;\n\tconst s = hsv[1] / 100;\n\tlet v = hsv[2] / 100;\n\tconst hi = Math.floor(h) % 6;\n\n\tconst f = h - Math.floor(h);\n\tconst p = 255 * v * (1 - s);\n\tconst q = 255 * v * (1 - (s * f));\n\tconst t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tconst h = hsv[0];\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\tconst vmin = Math.max(v, 0.01);\n\tlet sl;\n\tlet l;\n\n\tl = (2 - s) * v;\n\tconst lmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tconst h = hwb[0] / 360;\n\tlet wh = hwb[1] / 100;\n\tlet bl = hwb[2] / 100;\n\tconst ratio = wh + bl;\n\tlet f;\n\n\t// Wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\tconst i = Math.floor(6 * h);\n\tconst v = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\tlet r;\n\tlet g;\n\tlet b;\n\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\tcase 5: r = v;  g = wh; b = n; break;\n\t}\n\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tconst c = cmyk[0] / 100;\n\tconst m = cmyk[1] / 100;\n\tconst y = cmyk[2] / 100;\n\tconst k = cmyk[3] / 100;\n\n\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tconst x = xyz[0] / 100;\n\tconst y = xyz[1] / 100;\n\tconst z = xyz[2] / 100;\n\tlet r;\n\tlet g;\n\tlet b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// Assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet x;\n\tlet y;\n\tlet z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tconst y2 = y ** 3;\n\tconst x2 = x ** 3;\n\tconst z2 = z ** 3;\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet h;\n\n\tconst hr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst c = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tconst l = lch[0];\n\tconst c = lch[1];\n\tconst h = lch[2];\n\n\tconst hr = h / 360 * 2 * Math.PI;\n\tconst a = c * Math.cos(hr);\n\tconst b = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args, saturation = null) {\n\tconst [r, g, b] = args;\n\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tlet ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// Optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tconst r = args[0];\n\tconst g = args[1];\n\tconst b = args[2];\n\n\t// We use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tconst ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tlet color = args % 10;\n\n\t// Handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tconst mult = (~~(args > 50) + 1) * 0.5;\n\tconst r = ((color & 1) * mult) * 255;\n\tconst g = (((color >> 1) & 1) * mult) * 255;\n\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// Handle greyscale\n\tif (args >= 232) {\n\t\tconst c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tlet rem;\n\tconst r = Math.floor(args / 36) / 5 * 255;\n\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tconst b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tlet colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(char => {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tconst integer = parseInt(colorString, 16);\n\tconst r = (integer >> 16) & 0xFF;\n\tconst g = (integer >> 8) & 0xFF;\n\tconst b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst max = Math.max(Math.max(r, g), b);\n\tconst min = Math.min(Math.min(r, g), b);\n\tconst chroma = (max - min);\n\tlet grayscale;\n\tlet hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\n\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\tlet f = 0;\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\n\tconst c = s * v;\n\tlet f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tconst h = hcg[0] / 360;\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tconst pure = [0, 0, 0];\n\tconst hi = (h % 1) * 6;\n\tconst v = hi % 1;\n\tconst w = 1 - v;\n\tlet mg = 0;\n\n\t/* eslint-disable max-statements-per-line */\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\t/* eslint-enable max-statements-per-line */\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst v = c + g * (1.0 - c);\n\tlet f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst l = g * (1.0 - c) + 0.5 * c;\n\tlet s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\tconst v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tconst w = hwb[1] / 100;\n\tconst b = hwb[2] / 100;\n\tconst v = 1 - b;\n\tconst c = v - w;\n\tlet g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hsv = convert.gray.hsl;\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tconst integer = (val << 16) + (val << 8) + val;\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n","const conversions = require('./conversions');\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n","const conversions = require('./conversions');\nconst route = require('./route');\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n","'use strict';\n\nconst wrapAnsi16 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${code + offset}m`;\n};\n\nconst wrapAnsi256 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${38 + offset};5;${code}m`;\n};\n\nconst wrapAnsi16m = (fn, offset) => (...args) => {\n\tconst rgb = fn(...args);\n\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n};\n\nconst ansi2ansi = n => n;\nconst rgb2rgb = (r, g, b) => [r, g, b];\n\nconst setLazyProperty = (object, property, get) => {\n\tObject.defineProperty(object, property, {\n\t\tget: () => {\n\t\t\tconst value = get();\n\n\t\t\tObject.defineProperty(object, property, {\n\t\t\t\tvalue,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\n\t\t\treturn value;\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t});\n};\n\n/** @type {typeof import('color-convert')} */\nlet colorConvert;\nconst makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {\n\tif (colorConvert === undefined) {\n\t\tcolorConvert = require('color-convert');\n\t}\n\n\tconst offset = isBackground ? 10 : 0;\n\tconst styles = {};\n\n\tfor (const [sourceSpace, suite] of Object.entries(colorConvert)) {\n\t\tconst name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;\n\t\tif (sourceSpace === targetSpace) {\n\t\t\tstyles[name] = wrap(identity, offset);\n\t\t} else if (typeof suite === 'object') {\n\t\t\tstyles[name] = wrap(suite[targetSpace], offset);\n\t\t}\n\t}\n\n\treturn styles;\n};\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\n\t\t\t// Bright color\n\t\t\tblackBright: [90, 39],\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Alias bright black as gray (and grey)\n\tstyles.color.gray = styles.color.blackBright;\n\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\tstyles.color.grey = styles.color.blackBright;\n\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tsetLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));\n\tsetLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n","'use strict';\nmodule.exports = {\n\tstdout: false,\n\tstderr: false\n};\n","'use strict';\n\nconst stringReplaceAll = (string, substring, replacer) => {\n\tlet index = string.indexOf(substring);\n\tif (index === -1) {\n\t\treturn string;\n\t}\n\n\tconst substringLength = substring.length;\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\treturnValue += string.substr(endIndex, index - endIndex) + substring + replacer;\n\t\tendIndex = index + substringLength;\n\t\tindex = string.indexOf(substring, endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nconst stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\tconst gotCR = string[index - 1] === '\\r';\n\t\treturnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\\r\\n' : '\\n') + postfix;\n\t\tendIndex = index + 1;\n\t\tindex = string.indexOf('\\n', endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nmodule.exports = {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n};\n","'use strict';\nconst TEMPLATE_REGEX = /(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n\nconst ESCAPES = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\n\nfunction unescape(c) {\n\tconst u = c[0] === 'u';\n\tconst bracket = c[1] === '{';\n\n\tif ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\n\tif (u && bracket) {\n\t\treturn String.fromCodePoint(parseInt(c.slice(2, -1), 16));\n\t}\n\n\treturn ESCAPES.get(c) || c;\n}\n\nfunction parseArguments(name, arguments_) {\n\tconst results = [];\n\tconst chunks = arguments_.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\n\tfor (const chunk of chunks) {\n\t\tconst number = Number(chunk);\n\t\tif (!Number.isNaN(number)) {\n\t\t\tresults.push(number);\n\t\t} else if ((matches = chunk.match(STRING_REGEX))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction parseStyle(style) {\n\tSTYLE_REGEX.lastIndex = 0;\n\n\tconst results = [];\n\tlet matches;\n\n\twhile ((matches = STYLE_REGEX.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction buildStyle(chalk, styles) {\n\tconst enabled = {};\n\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\n\tlet current = chalk;\n\tfor (const [styleName, styles] of Object.entries(enabled)) {\n\t\tif (!Array.isArray(styles)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(styleName in current)) {\n\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t}\n\n\t\tcurrent = styles.length > 0 ? current[styleName](...styles) : current[styleName];\n\t}\n\n\treturn current;\n}\n\nmodule.exports = (chalk, temporary) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\n\t// eslint-disable-next-line max-params\n\ttemporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {\n\t\tif (escapeCharacter) {\n\t\t\tchunk.push(unescape(escapeCharacter));\n\t\t} else if (style) {\n\t\t\tconst string = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));\n\t\t\tstyles.push({inverse, styles: parseStyle(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\n\t\t\tchunks.push(buildStyle(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(character);\n\t\t}\n\t});\n\n\tchunks.push(chunk.join(''));\n\n\tif (styles.length > 0) {\n\t\tconst errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMessage);\n\t}\n\n\treturn chunks.join('');\n};\n","'use strict';\nconst ansiStyles = require('ansi-styles');\nconst {stdout: stdoutColor, stderr: stderrColor} = require('supports-color');\nconst {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n} = require('./util');\n\nconst {isArray} = Array;\n\n// `supportsColor.level` → `ansiStyles.color[name]` mapping\nconst levelMapping = [\n\t'ansi',\n\t'ansi',\n\t'ansi256',\n\t'ansi16m'\n];\n\nconst styles = Object.create(null);\n\nconst applyOptions = (object, options = {}) => {\n\tif (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {\n\t\tthrow new Error('The `level` option should be an integer from 0 to 3');\n\t}\n\n\t// Detect level if not set manually\n\tconst colorLevel = stdoutColor ? stdoutColor.level : 0;\n\tobject.level = options.level === undefined ? colorLevel : options.level;\n};\n\nclass ChalkClass {\n\tconstructor(options) {\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn chalkFactory(options);\n\t}\n}\n\nconst chalkFactory = options => {\n\tconst chalk = {};\n\tapplyOptions(chalk, options);\n\n\tchalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);\n\n\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\tObject.setPrototypeOf(chalk.template, chalk);\n\n\tchalk.template.constructor = () => {\n\t\tthrow new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');\n\t};\n\n\tchalk.template.Instance = ChalkClass;\n\n\treturn chalk.template;\n};\n\nfunction Chalk(options) {\n\treturn chalkFactory(options);\n}\n\nfor (const [styleName, style] of Object.entries(ansiStyles)) {\n\tstyles[styleName] = {\n\t\tget() {\n\t\t\tconst builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);\n\t\t\tObject.defineProperty(this, styleName, {value: builder});\n\t\t\treturn builder;\n\t\t}\n\t};\n}\n\nstyles.visible = {\n\tget() {\n\t\tconst builder = createBuilder(this, this._styler, true);\n\t\tObject.defineProperty(this, 'visible', {value: builder});\n\t\treturn builder;\n\t}\n};\n\nconst usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];\n\nfor (const model of usedModels) {\n\tstyles[model] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nfor (const model of usedModels) {\n\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\tstyles[bgModel] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nconst proto = Object.defineProperties(() => {}, {\n\t...styles,\n\tlevel: {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn this._generator.level;\n\t\t},\n\t\tset(level) {\n\t\t\tthis._generator.level = level;\n\t\t}\n\t}\n});\n\nconst createStyler = (open, close, parent) => {\n\tlet openAll;\n\tlet closeAll;\n\tif (parent === undefined) {\n\t\topenAll = open;\n\t\tcloseAll = close;\n\t} else {\n\t\topenAll = parent.openAll + open;\n\t\tcloseAll = close + parent.closeAll;\n\t}\n\n\treturn {\n\t\topen,\n\t\tclose,\n\t\topenAll,\n\t\tcloseAll,\n\t\tparent\n\t};\n};\n\nconst createBuilder = (self, _styler, _isEmpty) => {\n\tconst builder = (...arguments_) => {\n\t\tif (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {\n\t\t\t// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`\n\t\t\treturn applyStyle(builder, chalkTag(builder, ...arguments_));\n\t\t}\n\n\t\t// Single argument is hot path, implicit coercion is faster than anything\n\t\t// eslint-disable-next-line no-implicit-coercion\n\t\treturn applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));\n\t};\n\n\t// We alter the prototype because we must return a function, but there is\n\t// no way to create a function with a different prototype\n\tObject.setPrototypeOf(builder, proto);\n\n\tbuilder._generator = self;\n\tbuilder._styler = _styler;\n\tbuilder._isEmpty = _isEmpty;\n\n\treturn builder;\n};\n\nconst applyStyle = (self, string) => {\n\tif (self.level <= 0 || !string) {\n\t\treturn self._isEmpty ? '' : string;\n\t}\n\n\tlet styler = self._styler;\n\n\tif (styler === undefined) {\n\t\treturn string;\n\t}\n\n\tconst {openAll, closeAll} = styler;\n\tif (string.indexOf('\\u001B') !== -1) {\n\t\twhile (styler !== undefined) {\n\t\t\t// Replace any instances already present with a re-opening code\n\t\t\t// otherwise only the part of the string until said closing code\n\t\t\t// will be colored, and the rest will simply be 'plain'.\n\t\t\tstring = stringReplaceAll(string, styler.close, styler.open);\n\n\t\t\tstyler = styler.parent;\n\t\t}\n\t}\n\n\t// We can move both next actions out of loop, because remaining actions in loop won't have\n\t// any/visible effect on parts we add here. Close the styling before a linebreak and reopen\n\t// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92\n\tconst lfIndex = string.indexOf('\\n');\n\tif (lfIndex !== -1) {\n\t\tstring = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n\t}\n\n\treturn openAll + string + closeAll;\n};\n\nlet template;\nconst chalkTag = (chalk, ...strings) => {\n\tconst [firstString] = strings;\n\n\tif (!isArray(firstString) || !isArray(firstString.raw)) {\n\t\t// If chalk() was called by itself or with a string,\n\t\t// return the string itself as a string.\n\t\treturn strings.join(' ');\n\t}\n\n\tconst arguments_ = strings.slice(1);\n\tconst parts = [firstString.raw[0]];\n\n\tfor (let i = 1; i < firstString.length; i++) {\n\t\tparts.push(\n\t\t\tString(arguments_[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'),\n\t\t\tString(firstString.raw[i])\n\t\t);\n\t}\n\n\tif (template === undefined) {\n\t\ttemplate = require('./templates');\n\t}\n\n\treturn template(chalk, parts.join(''));\n};\n\nObject.defineProperties(Chalk.prototype, styles);\n\nconst chalk = Chalk(); // eslint-disable-line new-cap\nchalk.supportsColor = stdoutColor;\nchalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap\nchalk.stderr.supportsColor = stderrColor;\n\nmodule.exports = chalk;\n","import chalk from 'chalk'\nimport { CharType, checkCharType } from './parser'\n\nexport const env: {\n  stdout: NodeJS.WritableStream\n  stderr: NodeJS.WritableStream\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  defaultLogger: Console\n} = {\n  stdout: globalThis?.process?.stdout,\n  stderr: globalThis?.process?.stderr,\n  defaultLogger: console\n}\n\nif (globalThis.__DEV__) {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const fs = require('fs')\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const { Console: NativeConsole } = require('console')\n  env.stdout = fs.createWriteStream('./stdout.log', { encoding: 'utf-8' })\n  env.stderr = fs.createWriteStream('./stderr.log', { encoding: 'utf-8' })\n  env.defaultLogger = new NativeConsole(env.stdout, env.stderr)\n}\n\ntype Position = {\n  offset: number\n  row: number\n  column: number\n  line: string\n}\n\nconst getPositionByOffset = (str: string, offset: number): Position => {\n  const rows = str.split('\\n')\n  const rowLengthList = rows.map((substr) => substr.length)\n  const position = {\n    offset,\n    row: 0,\n    column: 0,\n    line: ''\n  }\n  while (position.offset >= 0 && rows.length) {\n    position.row++\n    position.column = position.offset\n    position.line = rows.shift() || ''\n    position.offset -= (rowLengthList.shift() || 0) + 1\n  }\n  return position\n}\n\nexport enum ValidationTarget {\n  CONTENT = 'content',\n  START_CONTENT = 'startContent',\n  END_CONTENT = 'endContent',\n  SPACE_AFTER = 'spaceAfter',\n  INNER_SPACE_BEFORE = 'innerSpaceBefore'\n}\n\nexport type Validation = {\n  // the type and content of message\n  name: string\n  message: string\n\n  // position of the token\n  index: number\n  length: number\n\n  // which part of the token the error comes from\n  target: ValidationTarget\n}\n\nconst adjustedFullWidthPunctuations = `“”‘’`\n\nconst generateMarker = (str: string, index: number): string => {\n  const prefix = str.substring(0, index)\n  let fullWidthCount = 0\n  let halfWidthCount = 0\n  for (let i = 0; i < prefix.length; i++) {\n    const charType = checkCharType(prefix[i])\n    if (\n      charType === CharType.LETTERS_FULL ||\n      (charType === CharType.PUNCTUATION_FULL &&\n        adjustedFullWidthPunctuations.indexOf(prefix[i]) === -1)\n    ) {\n      fullWidthCount++\n    } else if (\n      charType === CharType.LETTERS_HALF ||\n      (charType === CharType.PUNCTUATION_HALF &&\n        adjustedFullWidthPunctuations.indexOf(prefix[i]) !== -1) ||\n      charType === CharType.SPACE\n    ) {\n      halfWidthCount++\n    }\n  }\n  return (\n    ' '.repeat(halfWidthCount) +\n    '　'.repeat(fullWidthCount) +\n    `${chalk.red('^')}`\n  )\n}\n\nexport const reportItem = (\n  file: string | undefined = '',\n  str: string,\n  validations: Validation[],\n  logger = env.defaultLogger\n) => {\n  validations.forEach(({ index, length, target, message }) => {\n    // 0. final index and position\n    const finalIndex =\n      target === 'spaceAfter' || target === 'endContent'\n        ? index + length\n        : index\n    const { row, column, line } = getPositionByOffset(str, finalIndex)\n\n    // 1. headline\n    const fileDisplay = `${chalk.blue.bgWhite(file)}${file ? ':' : ''}`\n    const positionDisplay = `${chalk.yellow(row)}:${chalk.yellow(column)}`\n    const headline = `${fileDisplay}${positionDisplay} - ${message}`\n\n    // 2. display fragment\n    const displayRange = 20\n    const displayStart = column - displayRange < 0 ? 0 : column - displayRange\n    const displayEnd =\n      column + length + displayRange > line.length - 1\n        ? line.length\n        : column + length + displayRange\n    const displayFragment = line\n      .substring(displayStart, displayEnd)\n      .replace(/\\n/g, '\\\\n')\n\n    // 3. marker below\n    const markerBelow = generateMarker(displayFragment, column - displayStart)\n\n    logger.error(`${headline}\\n\\n${displayFragment}\\n${markerBelow}\\n`)\n  })\n}\n\nexport type Result = {\n  // the basic info and availability of the file\n  file?: string\n  disabled: boolean\n\n  // the original content of the file\n  origin: string\n\n  // all the error messages\n  validations: Validation[]\n}\n\nexport const report = (resultList: Result[], logger = env.defaultLogger) => {\n  let errorCount = 0\n  const invalidFiles: string[] = []\n  resultList\n    .filter(({ file, disabled }) => {\n      if (disabled) {\n        if (file) {\n          logger.log(`${chalk.blue.bgWhite(file)}: disabled`)\n        } else {\n          logger.log(`disabled`)\n        }\n        return false\n      }\n      return true\n    })\n    .forEach(({ file, origin, validations }: Result) => {\n      reportItem(file, origin, validations, logger)\n      errorCount += validations.length\n      if (file && validations.length) {\n        invalidFiles.push(file)\n      }\n    })\n  if (errorCount) {\n    const errors: string[] = []\n    errors.push('Invalid files:')\n    errors.push('- ' + invalidFiles.join('\\n- ') + '\\n')\n    errors.push(`Found ${errorCount} ${errorCount > 1 ? 'errors' : 'error'}.`)\n    logger.error(errors.join('\\n'))\n    return 1\n  } else {\n    logger.log(`No error found.`)\n  }\n}\n","export const BRACKET_NOT_CLOSED = '括号未闭合'\nexport const BRACKET_NOT_OPEN = '括号未匹配'\n\nexport const QUOTE_NOT_CLOSED = '引号未闭合'\nexport const QUOTE_NOT_OPEN = '引号未匹配'\n","import { ValidationTarget } from '../report'\nimport { checkCharType } from './char'\nimport {\n  BRACKET_NOT_CLOSED,\n  BRACKET_NOT_OPEN,\n  QUOTE_NOT_CLOSED,\n  QUOTE_NOT_OPEN\n} from './messages'\nimport {\n  CharType,\n  SHORTHAND_CHARS,\n  SHORTHAND_PAIR_SET,\n  BRACKET_CHAR_SET,\n  QUOTE_CHAR_SET,\n  Mark,\n  MarkMap,\n  MarkSideType,\n  MarkType,\n  LettersType,\n  SingleToken,\n  HyperTokenType,\n  GroupToken,\n  GroupTokenType,\n  Token,\n  PunctuationType\n} from './types'\nimport { ParseStatus } from './parse'\n\nexport const handlePunctuation = (\n  i: number,\n  char: string,\n  type: PunctuationType,\n  status: ParseStatus\n): void => {\n  // end the last unfinished token\n  finalizeLastToken(status, i)\n  // check the current token type\n  // - start of a mark: start an unfinished mark\n  // - end of a mark: end the current unfinished mark\n  // - neutral quote: start/end a group by pairing the last unfinished group\n  // - left quote: start a new unfinished group\n  // - right quote: end the current unfinished group\n  // - other punctuation: add and end the current token\n  if (BRACKET_CHAR_SET.left.indexOf(char) >= 0) {\n    // push (save) the current unfinished mark if have\n    initNewMark(status, i, char)\n    // generate a new token and mark it as a mark punctuation by left\n    // and finish the token\n    addBracketToken(status, i, char, MarkSideType.LEFT)\n  } else if (BRACKET_CHAR_SET.right.indexOf(char) >= 0) {\n    if (!status.lastMark || !status.lastMark.startContent) {\n      addUnmatchedToken(status, i, char)\n      addError(status, i, BRACKET_NOT_OPEN)\n    } else {\n      // generate token as a punctuation\n      addBracketToken(status, i, char, MarkSideType.RIGHT)\n      // end the last unfinished mark\n      // and pop the previous one if exists\n      finalizeCurrentMark(status, i, char)\n    }\n  } else if (QUOTE_CHAR_SET.neutral.indexOf(char) >= 0) {\n    // - end the last unfinished group\n    // - start a new group\n    if (status.lastGroup && char === status.lastGroup.startContent) {\n      finalizeCurrentGroup(status, i, char)\n    } else {\n      initNewGroup(status, i, char)\n    }\n  } else if (QUOTE_CHAR_SET.left.indexOf(char) >= 0) {\n    initNewGroup(status, i, char)\n  } else if (QUOTE_CHAR_SET.right.indexOf(char) >= 0) {\n    if (!status.lastGroup || !status.lastGroup.startContent) {\n      addUnmatchedToken(status, i, char)\n      addError(status, i, QUOTE_NOT_OPEN)\n    } else {\n      finalizeCurrentGroup(status, i, char)\n    }\n  } else {\n    addNormalPunctuationToken(status, i, char, type)\n  }\n}\n\nexport const handleContent = (\n  i: number,\n  char: string,\n  type: LettersType,\n  status: ParseStatus\n): void => {\n  // check if type changed and last token unfinished\n  // - create new token in the current group\n  // - append into current unfinished token\n  if (status.lastToken) {\n    if (status.lastToken.type !== type) {\n      finalizeLastToken(status, i)\n      initNewContent(status, i, char, type)\n    } else {\n      appendContent(status, char)\n    }\n  } else {\n    initNewContent(status, i, char, type)\n  }\n}\n\n// status\n\nexport const initNewStatus = (str: string, hyperMarks: Mark[]): ParseStatus => {\n  const tokens = [] as unknown as GroupToken\n  Object.assign(tokens, {\n    type: GroupTokenType.GROUP,\n    index: 0,\n    spaceAfter: '',\n    startIndex: 0,\n    endIndex: str.length - 1,\n    startContent: '',\n    endContent: '',\n    innerSpaceBefore: ''\n  })\n  const status: ParseStatus = {\n    lastToken: undefined,\n    lastGroup: tokens,\n    lastMark: undefined,\n\n    tokens,\n    marks: [...hyperMarks],\n    groups: [],\n\n    markStack: [],\n    groupStack: [],\n\n    errors: []\n  }\n  return status\n}\n\n// finalize token\n\nexport const finalizeLastToken = (status: ParseStatus, index: number): void => {\n  if (status.lastToken) {\n    // the lastToken.index is not the current index anymore\n    status.lastToken.length = index - status.lastToken.index\n    status.lastGroup && status.lastGroup.push(status.lastToken)\n    status.lastToken = undefined\n  }\n}\n\nexport const finalizeCurrentToken = (\n  status: ParseStatus,\n  token: SingleToken\n): void => {\n  status.lastGroup && status.lastGroup.push(token)\n  status.lastToken = undefined\n}\n\n// hyper marks\n\nconst markTypeToTokenType = (type: MarkType): HyperTokenType => {\n  switch (type) {\n    case MarkType.HYPER:\n      return HyperTokenType.HYPER_WRAPPER\n    case MarkType.BRACKETS:\n      return HyperTokenType.HYPER_WRAPPER_BRACKET\n    case MarkType.RAW:\n      return HyperTokenType.INDETERMINATED\n  }\n}\n\nexport const addHyperToken = (\n  status: ParseStatus,\n  index: number,\n  mark: Mark,\n  content: string,\n  markSide: MarkSideType\n) => {\n  const token: SingleToken = {\n    type: markTypeToTokenType(mark.type),\n    index,\n    length: content.length,\n    content: content,\n    spaceAfter: '', // to be finalized\n    mark: mark,\n    markSide\n  }\n  finalizeCurrentToken(status, token)\n}\n\nexport const addHyperContent = (\n  status: ParseStatus,\n  index: number,\n  content: string\n) => {\n  const token: SingleToken = {\n    type: getHyperContentType(content),\n    index,\n    length: content.length,\n    content: content,\n    spaceAfter: '' // to be finalized\n  }\n  finalizeCurrentToken(status, token)\n}\n\n// bracket marks\n\nexport const initNewMark = (\n  status: ParseStatus,\n  index: number,\n  char: string,\n  type: MarkType = MarkType.BRACKETS\n) => {\n  if (status.lastMark) {\n    status.markStack.push(status.lastMark)\n    status.lastMark = undefined\n  }\n  const mark: Mark = {\n    type,\n    startIndex: index,\n    startContent: char,\n    endIndex: -1, // to be finalized\n    endContent: '' // to be finalized\n  }\n  status.marks.push(mark)\n  status.lastMark = mark\n}\n\nexport const addBracketToken = (\n  status: ParseStatus,\n  index: number,\n  char: string,\n  markSide: MarkSideType\n) => {\n  const token: SingleToken = {\n    type: HyperTokenType.HYPER_WRAPPER_BRACKET,\n    index,\n    length: 1,\n    content: char,\n    spaceAfter: '', // to be finalized\n    mark: status.lastMark,\n    markSide\n  }\n  finalizeCurrentToken(status, token)\n}\n\nexport const finalizeCurrentMark = (\n  status: ParseStatus,\n  index: number,\n  char: string\n) => {\n  if (!status.lastMark) {\n    return\n  }\n  status.lastMark.endIndex = index\n  status.lastMark.endContent = char\n  if (status.markStack.length > 0) {\n    status.lastMark = status.markStack.pop()\n  } else {\n    status.lastMark = undefined\n  }\n}\n\n// normal punctuation\n\nconst addNormalPunctuationToken = (\n  status: ParseStatus,\n  index: number,\n  char: string,\n  type: PunctuationType\n) => {\n  const token: SingleToken = {\n    type,\n    index,\n    length: 1,\n    content: char,\n    spaceAfter: '' // to be finalized\n  }\n  finalizeCurrentToken(status, token)\n}\n\nconst addUnmatchedToken = (\n  status: ParseStatus,\n  i: number,\n  char: string\n): void => {\n  const token: SingleToken = {\n    type: HyperTokenType.UNMATCHED,\n    index: i,\n    length: 1,\n    content: char,\n    spaceAfter: ''\n  }\n  finalizeCurrentToken(status, token)\n}\n\n// group\n\nexport const initNewGroup = (\n  status: ParseStatus,\n  index: number,\n  char: string\n) => {\n  status.lastGroup && status.groupStack.push(status.lastGroup)\n  const lastGroup = [] as unknown as GroupToken\n\n  Object.assign(lastGroup, {\n    type: GroupTokenType.GROUP,\n    index,\n    spaceAfter: '', // to be finalized\n    startIndex: index,\n    startContent: char,\n    endIndex: -1, // to be finalized\n    endContent: '', // to be finalized\n    innerSpaceBefore: '' // to be finalized\n  })\n\n  // TODO: previous group in stack\n  status.groupStack[status.groupStack.length - 1].push(lastGroup)\n  status.lastGroup = lastGroup\n  status.groups.push(lastGroup)\n}\n\nexport const finalizeCurrentGroup = (\n  status: ParseStatus,\n  index: number,\n  char: string\n) => {\n  if (status.lastGroup) {\n    // index, length, content\n    status.lastGroup.endIndex = index\n    status.lastGroup.endContent = char\n  }\n  if (status.groupStack.length > 0) {\n    status.lastGroup = status.groupStack.pop()\n  } else {\n    status.lastGroup = undefined\n  }\n}\n\n// content\n\nexport const initNewContent = (\n  status: ParseStatus,\n  index: number,\n  char: string,\n  type: LettersType\n) => {\n  status.lastToken = {\n    type,\n    index,\n    length: 1, // to be finalized\n    content: char, // to be finalized\n    spaceAfter: '' // to be finalized\n  }\n}\n\nexport const appendContent = (status: ParseStatus, char: string) => {\n  if (status.lastToken) {\n    status.lastToken.content += char\n    status.lastToken.length++\n  }\n}\n\n// others\n\n/**\n * Get the length of connecting spaces from a certain index\n */\nexport const getConnectingSpaceLength = (\n  str: string,\n  start: number\n): number => {\n  // not even a space\n  if (checkCharType(str[start]) !== CharType.SPACE) {\n    return 0\n  }\n\n  // find the next non-space char\n  for (let i = start + 1; i < str.length; i++) {\n    const char = str[i]\n    const type = checkCharType(char)\n    if (type !== CharType.SPACE) {\n      return i - start\n    }\n  }\n\n  // space till the end\n  return str.length - start\n}\n\nexport const getPreviousToken = (status: ParseStatus): Token | undefined => {\n  if (status.lastGroup) {\n    return status.lastGroup[status.lastGroup.length - 1]\n  }\n}\n\nexport const getHyperMarkMap = (hyperMarks: Mark[]) => {\n  const hyperMarkMap: MarkMap = {}\n  hyperMarks.forEach((mark) => {\n    hyperMarkMap[mark.startIndex] = mark\n    if (mark.type !== MarkType.RAW) {\n      hyperMarkMap[mark.endIndex] = mark\n    }\n  })\n  return hyperMarkMap\n}\n\nexport const isShorthand = (\n  str: string,\n  status: ParseStatus,\n  index: number,\n  char: string\n): boolean => {\n  if (SHORTHAND_CHARS.indexOf(char) < 0) {\n    return false\n  }\n  if (!status.lastToken || status.lastToken.type !== CharType.LETTERS_HALF) {\n    return false\n  }\n  const nextChar = str[index + 1]\n  const nextType = checkCharType(nextChar)\n  if (nextType === CharType.LETTERS_HALF || nextType === CharType.SPACE) {\n    if (!status.lastGroup) {\n      return true\n    }\n    if (status.lastGroup.startContent !== SHORTHAND_PAIR_SET[char]) {\n      return true\n    }\n  }\n  return false\n}\n\nexport const getHyperContentType = (content: string): HyperTokenType => {\n  if (content.match(/\\n/)) {\n    // Usually it's hexo custom containers.\n    return HyperTokenType.HYPER_CONTENT\n  }\n  if (content.match(/^<code.*>.*<\\/code.*>$/)) {\n    // Usually it's <code>...</code>.\n    return HyperTokenType.HYPER_CONTENT_CODE\n  }\n  if (content.match(/^<.+>$/)) {\n    // Usually it's other HTML tags.\n    return HyperTokenType.HYPER_CONTENT\n  }\n  // Usually it's `...`.\n  return HyperTokenType.HYPER_CONTENT_CODE\n}\n\n// error handling\n\nconst addError = (\n  status: ParseStatus,\n  index: number,\n  message: string\n): void => {\n  status.errors.push({\n    name: '',\n    index,\n    length: 0,\n    message,\n    target: ValidationTarget.CONTENT\n  })\n}\n\nexport const handleErrors = (status: ParseStatus): void => {\n  // record an error if the last mark not fully resolved\n  const lastMark = status.lastMark\n  if (lastMark && lastMark.type === MarkType.BRACKETS && !lastMark.endContent) {\n    addError(status, lastMark.startIndex, BRACKET_NOT_CLOSED)\n  }\n\n  // record an error if `markStack` not fully resolved\n  if (status.markStack.length > 0) {\n    status.markStack.forEach((mark) => {\n      if (mark !== lastMark) {\n        addError(status, mark.startIndex, BRACKET_NOT_CLOSED)\n      }\n    })\n  }\n\n  // record an error if the last group not fully resolved\n  const lastGroup = status.lastGroup\n  if (lastGroup && lastGroup.startContent && !lastGroup.endContent) {\n    addError(status, lastGroup.startIndex, QUOTE_NOT_CLOSED)\n  }\n\n  // record an error if `groupStack` not fully resolved\n  if (status.groupStack.length > 0) {\n    status.groupStack.forEach((group) => {\n      if (group !== lastGroup && group.startContent && !group.endContent) {\n        addError(status, group.startIndex, QUOTE_NOT_CLOSED)\n      }\n    })\n  }\n}\n","import { isLettersType, isPunctuationType } from '.'\nimport { Validation } from '../report'\nimport { checkCharType } from './char'\nimport {\n  CharType,\n  Mark,\n  MutableMark,\n  MarkMap,\n  MarkSideType,\n  MarkType,\n  MutableSingleToken,\n  MutableGroupToken,\n  MutableToken,\n  Token,\n  GroupToken\n} from './types'\nimport {\n  appendContent,\n  addHyperContent,\n  addHyperToken,\n  finalizeLastToken,\n  getConnectingSpaceLength,\n  getHyperMarkMap,\n  getPreviousToken,\n  handleContent,\n  handlePunctuation,\n  initNewStatus,\n  isShorthand,\n  handleErrors\n} from './util'\nimport { Options as RuleOptions } from '../rules/util'\n\nexport type ParseStatus = {\n  lastToken?: Token\n  lastGroup?: GroupToken\n  lastMark?: Mark\n\n  tokens: GroupToken\n  marks: Mark[]\n  groups: GroupToken[]\n\n  markStack: Mark[]\n  groupStack: GroupToken[]\n\n  errors: Validation[]\n}\n\nexport type ParseResult = {\n  tokens: GroupToken\n  groups: GroupToken[]\n  marks: Mark[]\n  errors: Validation[]\n}\n\nexport type MutableParseResult = {\n  tokens: MutableGroupToken\n  groups: MutableGroupToken[]\n  marks: MutableMark[]\n  errors: Validation[]\n}\n\n/**\n * Parse a string into several tokens.\n * - half-width content x {1,n} (English words)\n * - full-width content x {1,n} (Chinese sentenses without punctuations in between)\n * - half-width punctuation\n * - width-width punctuation\n * - punctuation pair as special marks: brackets\n * - punctuation pair as a group: quotes\n * Besides them there are some special tokens\n * - content-hyper from hyperMarks as input\n * For spaces they would be included as one or multiple successive spaces in\n * - afterSpace after a token or\n * - innerSpaceBefore after the left quote of a group\n */\nexport const parse = (str: string, hyperMarks: Mark[] = []): ParseResult => {\n  // init status and hyper marks\n  const status: ParseStatus = initNewStatus(str, hyperMarks)\n  const hyperMarkMap: MarkMap = getHyperMarkMap(hyperMarks)\n\n  // travel every character in the string\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i]\n    const type = checkCharType(char)\n    const hyperMark = hyperMarkMap[i]\n\n    // finally get `status.marks` and `status.lastGroup` as the top-level tokens\n    // - hyper marks: finalize current token -> add mark\n    // - space: end current -> move forward -> record space beside\n    // - punctuation: whether start/end a mark or group, or just add a normal one\n    // - content: whether start a new one or append into the current one\n    if (hyperMark) {\n      // end the last unfinished token\n      finalizeLastToken(status, i)\n      // for hyper mark without startContent\n      delete hyperMarkMap[i]\n      // check the next token\n      // - if the mark type is raw\n      //   - append next token\n      // - else\n      //   - start mark: append token\n      //   - end mark: append token, append mark\n      if (hyperMark.type === MarkType.RAW) {\n        addHyperContent(\n          status,\n          i,\n          str.substring(hyperMark.startIndex, hyperMark.endIndex)\n        )\n        i = hyperMark.endIndex - 1\n      } else {\n        if (i === hyperMark.startIndex) {\n          addHyperToken(\n            status,\n            i,\n            hyperMark,\n            hyperMark.startContent,\n            MarkSideType.LEFT\n          )\n          i += hyperMark.startContent.length - 1\n        } else if (i === hyperMark.endIndex) {\n          addHyperToken(\n            status,\n            i,\n            hyperMark,\n            hyperMark.endContent,\n            MarkSideType.RIGHT\n          )\n          i += hyperMark.endContent.length - 1\n        }\n      }\n    } else if (type === CharType.SPACE) {\n      // end the last unfinished token\n      // jump to the next non-space char\n      // record the last space\n      // - space after a token\n      // - inner space before a group\n      finalizeLastToken(status, i)\n      if (status.lastGroup) {\n        const spaceLength = getConnectingSpaceLength(str, i)\n        const spaces = str.substring(i, i + spaceLength)\n        if (status.lastGroup.length) {\n          const lastToken = getPreviousToken(status)\n          if (lastToken) {\n            lastToken.spaceAfter = spaces\n          }\n        } else {\n          status.lastGroup.innerSpaceBefore = spaces\n        }\n        if (spaceLength - 1 > 0) {\n          i += spaceLength - 1\n        }\n      }\n    } else if (isShorthand(str, status, i, char)) {\n      appendContent(status, char)\n    } else if (isPunctuationType(type)) {\n      handlePunctuation(i, char, type, status)\n    } else if (isLettersType(type)) {\n      handleContent(i, char, type, status)\n    } else if (type === CharType.EMPTY) {\n      // Nothing\n    } else {\n      handleContent(i, char, CharType.LETTERS_HALF, status)\n    }\n  }\n  finalizeLastToken(status, str.length)\n\n  // handle all the unmatched parsing tokens\n  handleErrors(status)\n\n  return {\n    tokens: status.tokens,\n    groups: status.groups,\n    marks: status.marks,\n    errors: status.errors\n  }\n}\n\nconst toMutableToken = (token: Token): MutableToken => {\n  if (Array.isArray(token)) {\n    const mutableToken: MutableGroupToken = token as MutableGroupToken\n    mutableToken.modifiedType = token.type\n    mutableToken.modifiedContent = token.content\n    mutableToken.modifiedSpaceAfter = token.spaceAfter\n    mutableToken.modifiedStartContent = token.startContent\n    mutableToken.modifiedEndContent = token.endContent\n    mutableToken.modifiedInnerSpaceBefore = token.innerSpaceBefore\n    mutableToken.validations = []\n    token.forEach(toMutableToken)\n    return mutableToken\n  } else {\n    const mutableToken: MutableSingleToken = token as MutableSingleToken\n    mutableToken.modifiedType = token.type\n    mutableToken.modifiedContent = token.content\n    mutableToken.modifiedSpaceAfter = token.spaceAfter\n    mutableToken.validations = []\n    return mutableToken\n  }\n}\n\nconst toMutableMark = (mark: Mark): MutableMark => {\n  const mutableMark: MutableMark = mark as MutableMark\n  mutableMark.modifiedStartContent = mark.startContent\n  mutableMark.modifiedEndContent = mark.endContent\n  return mutableMark\n}\n\nexport const toMutableResult = (\n  result: ParseResult,\n  options: RuleOptions = {}\n): MutableParseResult => {\n  if (!options.noSinglePair) {\n    result.errors.length = 0\n  }\n\n  toMutableToken(result.tokens)\n  result.marks.forEach(toMutableMark)\n  return result as MutableParseResult\n}\n","import { MutableGroupToken, GroupToken, MutableToken, Token } from './types'\n\nexport type Handler = (\n  token: MutableToken | Token,\n  index: number,\n  group: MutableGroupToken | GroupToken\n) => void\n\nexport const travel = (\n  group: MutableGroupToken | GroupToken,\n  handler: Handler\n): void => {\n  for (let i = 0; i < group.length; i++) {\n    const token = group[i]\n    handler(token, i, group)\n    if (Array.isArray(token)) {\n      travel(token, handler)\n    }\n  }\n}\n","import unified from 'unified'\nimport markdown from 'remark-parse'\nimport frontmatter from 'remark-frontmatter'\nimport * as Ast from 'mdast'\nimport { Node, Position } from 'unist'\nimport { isRawMark, Mark, MarkSideType, MarkType, RawMark } from '../parser'\nimport { Block, ParsedStatus } from './types'\n\n// Position related\n\ntype NormalizedPosition = {\n  start: number\n  end: number\n}\n\nconst parsePosition = (position?: Position): NormalizedPosition => ({\n  start: position?.start?.offset || 0,\n  end: position?.end?.offset || 0\n})\n\n// AST related\n\nconst isParent = (node: Node): node is Ast.Parent => {\n  return (node as Ast.Parent).children !== undefined\n}\n\ntype BlockType = Ast.Paragraph | Ast.Heading | Ast.TableCell\nconst blockTypes: string[] = ['paragraph', 'heading', 'table-cell']\nconst isBlock = (node: Node): node is BlockType => {\n  return blockTypes.indexOf(node.type) >= 0\n}\n\ntype InlineContentType =\n  | Ast.Emphasis\n  | Ast.Strong\n  | Ast.Delete\n  | Ast.Footnote\n  | Ast.Link\n  | Ast.LinkReference\nconst inlineContentTypes: string[] = [\n  'emphasis',\n  'strong',\n  'delete',\n  'footnote',\n  'link',\n  'linkReference'\n]\nconst isInlineContent = (node: Node): node is InlineContentType => {\n  return inlineContentTypes.indexOf(node.type) >= 0\n}\n\ntype InlineRawType =\n  | Ast.InlineCode\n  | Ast.Break\n  | Ast.Image\n  | Ast.ImageReference\n  | Ast.FootnoteDefinition\n  | Ast.HTML\nconst inlineRawTypes: string[] = [\n  'inlineCode',\n  'break',\n  'image',\n  'imageReference',\n  'footnoteReference',\n  'html'\n]\nconst isInlineRaw = (node: Node): node is InlineRawType => {\n  return inlineRawTypes.indexOf(node.type) >= 0\n}\n\n// Marks related\n\ntype BlockMark = {\n  block: BlockType\n  inlineMarks: InlineMark[]\n  hyperMarks: Mark[]\n  value: string\n}\n\ntype InlineMark = {\n  inline: InlineContentType | InlineRawType\n  raw: boolean\n}\n\nconst travelBlocks = (node: Node, blocks: BlockMark[]): void => {\n  if (isParent(node)) {\n    node.children.forEach((child) => {\n      if (child.type === 'yaml') {\n        return\n      }\n      if (isBlock(child)) {\n        const blockMark: BlockMark = {\n          block: child,\n          inlineMarks: [],\n          hyperMarks: [],\n          value: '' // to be initialzed\n        }\n        blocks.push(blockMark)\n        travelInlines(child, blockMark)\n      } else {\n        travelBlocks(child, blocks)\n      }\n    })\n  }\n}\n\nconst travelInlines = (node: Node, blockMark: BlockMark): void => {\n  if (isParent(node)) {\n    node.children.forEach((child) => {\n      if (isInlineContent(child)) {\n        blockMark.inlineMarks.push({ inline: child, raw: false })\n        travelInlines(child, blockMark)\n      }\n      if (isInlineRaw(child)) {\n        blockMark.inlineMarks.push({ inline: child, raw: true })\n      }\n    })\n  }\n}\n\nconst processBlockMark = (blockMark: BlockMark, str: string): void => {\n  const { block, inlineMarks } = blockMark\n  if (!block.position) {\n    return\n  }\n  const offset = block.position.start.offset || 0\n\n  const marks: Mark[] = []\n  const unresolvedCodeMarks: RawMark[] = []\n\n  // Generate all the marks includes hyper (inline) and raw.\n  inlineMarks.forEach((inlineMark) => {\n    const { inline } = inlineMark\n    if (!inline.position) {\n      return\n    }\n    const startOffset = inline.position.start.offset || 0\n    const endOffset = inline.position.end.offset || 0\n\n    if (isInlineRaw(inline)) {\n      const mark: Mark = {\n        type: MarkType.RAW,\n        // TODO: typeof RawMark.meta\n        meta: inline.type,\n        startIndex: startOffset - offset,\n        endIndex: endOffset - offset,\n        startContent: str.substring(startOffset, endOffset),\n        endContent: ''\n      }\n      // TODO: Ast.InlineCode?\n      if (mark.startContent.match(/<code.*>/)) {\n        const rawMark: RawMark = { ...mark, code: MarkSideType.LEFT }\n        unresolvedCodeMarks.push(rawMark)\n        marks.push(rawMark)\n        return\n      } else if (mark.startContent.match(/<\\/code.*>/)) {\n        const rawMark: RawMark = { ...mark, code: MarkSideType.RIGHT }\n        const leftCode = unresolvedCodeMarks.pop()\n        if (leftCode) {\n          leftCode.rightPair = rawMark\n        }\n        marks.push(rawMark)\n        return\n      }\n      marks.push(mark)\n    } else {\n      const firstChild = inline.children[0]\n      const lastChild = inline.children[inline.children.length - 1]\n      if (!firstChild.position || !lastChild.position) {\n        return\n      }\n      const innerStartOffset = firstChild.position.start.offset || 0\n      const innerEndOffset = lastChild.position.end.offset || 0\n      const mark: Mark = {\n        type: MarkType.HYPER,\n        // TODO: typeof RawMark.meta\n        meta: inline.type,\n        startIndex: startOffset - offset,\n        startContent: str.substring(startOffset, innerStartOffset),\n        endIndex: innerEndOffset - offset,\n        endContent: str.substring(innerEndOffset, endOffset)\n      }\n      marks.push(mark)\n    }\n  })\n\n  blockMark.value = str.substring(\n    block.position.start.offset || 0,\n    block.position.end.offset || 0\n  )\n\n  blockMark.hyperMarks = marks\n    .map((mark) => {\n      if (isRawMark(mark)) {\n        if (mark.code === MarkSideType.RIGHT) {\n          return\n        }\n        if (mark.code === MarkSideType.LEFT) {\n          const { rightPair } = mark\n          mark.startContent = str.substring(\n            mark.startIndex + offset,\n            mark.endIndex + offset\n          )\n          mark.endIndex = rightPair?.endIndex || 0\n          mark.endContent = ''\n          delete mark.rightPair\n        }\n      }\n      return mark\n    })\n    .filter(Boolean) as Mark[]\n}\n\n/**\n  - travel all blocks/lists/tables/rows/cells\n    - content: paragraph/heading/table-cell\n    - no content: thematic break/code/html\n  - for all phrasings:\n    - no text: inline code/break/image/image ref/footnote ref/html\n    - marks: emphasis/strong/delete/footnote/link/link ref\n */\nconst parser = (data: ParsedStatus): ParsedStatus => {\n  const content = data.content\n  const modifiedContent = data.modifiedContent\n  const ignoredByParsers = data.ignoredByParsers\n\n  const blockMarks: BlockMark[] = []\n\n  const tree: Ast.Root = unified()\n    .use(markdown)\n    .use(frontmatter)\n    .parse(modifiedContent) as Ast.Root\n\n  // - travel and record all paragraphs/headings/table-cells into blocks\n  // - for each block, travel and record all\n  // - - 'hyper' marks: emphasis/strong/delete/footnote/link/linkRef and continue\n  // - - 'raw' marks: inlineCode/break/image/imageRef/footnoteRef/html and stop\n  travelBlocks(tree, blockMarks)\n\n  // for each block marks\n  // - get block.start.offset\n  // - for each marks\n  // - - startIndex: mark.start.offset - offset\n  // - - startContent: [mark.start.offset - offset, mark.firstChild.start.offset - offset]\n  // - - endIndex: mark.lastChild.end.offset - offset\n  // - - endContent: [mark.lastChild.end.offset - offset, mark.end.offset]\n  blockMarks.forEach((blockMark) => processBlockMark(blockMark, content))\n  data.blocks = blockMarks.map((b): Block => {\n    const position = parsePosition(b.block.position)\n    ignoredByParsers.forEach(({ index, length, originContent: raw, meta }) => {\n      if (position.start <= index && position.end >= index + length) {\n        if (b.hyperMarks) {\n          b.hyperMarks.push({\n            type: MarkType.RAW,\n            meta,\n            startIndex: index - position.start,\n            startContent: raw,\n            endIndex: index - position.start + length,\n            endContent: ''\n          })\n        }\n      }\n    })\n    return {\n      value: b.value || '',\n      marks: b.hyperMarks || [],\n      ...position\n    }\n  })\n  data.ignoredByParsers = []\n  return data\n}\n\nexport default parser\n","export const CODE_SPACE_OUTSIDE = '此处内联代码的外部需要一个空格'\nexport const CODE_NOSPACE_OUTSIDE = '此处内联代码的外部不需要空格'\n\nexport const MARKDOWN_SPACE_OUTSIDE = '此处 Markdown 标记的空格需要在外部'\nexport const MARKDOWN_NOSPACE_INSIDE = '此处 Markdown 标记的内部不需要空格'\n\nexport const PUNCTUATION_UNIFICATION_TRADITIONAL = '此处标点符号需要统一到繁体'\nexport const PUNCTUATION_UNIFICATION_SIMPLIFIED = '此处标点符号需要统一到简体'\n\nexport const PUNCTUATION_FULL_WIDTH = '此处标点符号需要使用全角'\nexport const PUNCTUATION_HALF_WIDTH = '此处标点符号需要使用半角'\n\nexport const PUNCTUATION_NOSPACE_BEFORE = '此处标点符号前不需要空格'\nexport const PUNCTUATION_NOSPACE_AFTER = '此处标点符号后不需要空格'\nexport const PUNCTUATION_SPACE_AFTER = '此处标点符号后需要一个空格'\n\nexport const BRACKET_NOSPACE_INSIDE = '此处括号的内部不需要空格'\nexport const BRACKET_NOSPACE_OUTSIDE = '此处括号的外部不需要空格'\nexport const BRACKET_SPACE_OUTSIDE = '此处括号的外部需要一个空格'\n\nexport const CONTENT_SPACE_HALF_WIDTH = '此处半角内容之间需要一个空格'\nexport const CONTENT_NOSPACE_FULL_WIDTH = '此处全角内容之间不需要空格'\nexport const CONTENT_SPACE_MIXED_WIDTH = '此处中英文内容之间需要一个空格'\nexport const CONTENT_NOSPACE_MIXED_WIDTH = '此处中英文内容之间需要一个空格'\n\nexport const QUOTE_NOSPACE_INSIDE = '此处引号的内部不需要空格'\nexport const QUOTE_NOSPACE_OUTSIDE = '此处引号的外部不需要空格'\nexport const QUOTE_SPACE_OUTSIDE = '此处引号的外部需要一个空格'\n\nexport const TRIM_SPACE = '此处需要去除外部空格'\n","import { Validation, ValidationTarget } from '../report'\nimport {\n  MarkSideType,\n  MutableGroupToken as GroupToken,\n  MutableToken as Token,\n  HyperTokenType,\n  isNonCodeVisibleType,\n  isInvisibleType,\n  isVisibleType,\n  TokenType,\n  CharType\n} from '../parser'\n\n// options\n\nexport type Options = {\n  // parsing\n  noSinglePair?: boolean\n\n  // punctuation\n  halfWidthPunctuation?: string\n  fullWidthPunctuation?: string\n  adjustedFullWidthPunctuation?: string\n  unifiedPunctuation?: 'traditional' | 'simplified'\n\n  // case: abbrs\n  skipAbbrs?: string[]\n\n  // space around content\n  spaceBetweenHalfWidthLetters?: boolean\n  noSpaceBetweenFullWidthLetters?: boolean\n  spaceBetweenMixedWidthLetters?: boolean\n\n  // space around punctuation\n  noSpaceBeforePunctuation?: boolean\n  spaceAfterHalfWidthPunctuation?: boolean\n  noSpaceAfterFullWidthPunctuation?: boolean\n\n  // space around quote\n  spaceOutsideHalfQuote?: boolean\n  noSpaceOutsideFullQuote?: boolean\n  noSpaceInsideQuote?: boolean\n\n  // space around bracket\n  spaceOutsideHalfBracket?: boolean\n  noSpaceOutsideFullBracket?: boolean\n  noSpaceInsideBracket?: boolean\n\n  // space around code\n  spaceOutsideCode?: boolean\n\n  // space around mark\n  noSpaceInsideWrapper?: boolean\n\n  // trim space\n  trimSpace?: boolean\n\n  // case: number x Chinese unit\n  skipZhUnits?: string\n\n  // custom preset\n  preset?: string\n\n  /**\n   * @deprecated\n   *\n   * Please use `noSpaceInsideWrapper` instead.\n   */\n  noSpaceInsideMark?: boolean\n  /**\n   * @deprecated\n   *\n   * Please use `spaceBetweenHalfWidthLetters` instead.\n   */\n  spaceBetweenHalfWidthContent?: boolean\n  /**\n   * @deprecated\n   *\n   * Please use `noSpaceBetweenFullWidthLetters` instead.\n   */\n  noSpaceBetweenFullWidthContent?: boolean\n  /**\n   * @deprecated\n   *\n   * Please use `spaceBetweenMixedWidthLetters` instead.\n   */\n  spaceBetweenMixedWidthContent?: boolean\n}\n\n// find tokens\n\n/**\n * Find the previous token if exists\n */\nexport const findTokenBefore = (\n  group: GroupToken,\n  token: Token | undefined\n): Token | undefined => {\n  if (!token) {\n    return\n  }\n  const index = group.indexOf(token)\n  if (index < 0) {\n    return\n  }\n  return group[index - 1]\n}\n\n/**\n * Find the next token if exists\n */\nexport const findTokenAfter = (\n  group: GroupToken,\n  token: Token | undefined\n): Token | undefined => {\n  if (!token) {\n    return\n  }\n  const index = group.indexOf(token)\n  if (index < 0) {\n    return\n  }\n  return group[index + 1]\n}\n\n/**\n * Find a certain token before, which:\n * - group, content, punctuation, and bracket will be passed\n * - code, container, and unknown will be failed\n * - hyper mark, html pairs will be skipped\n */\nexport const findNonCodeVisibleTokenBefore = (\n  group: GroupToken,\n  token: Token | undefined\n): Token | undefined => {\n  if (!token) {\n    return\n  }\n  const beforeToken = findTokenBefore(group, token)\n  if (!beforeToken) {\n    return\n  }\n  // hyper mark, html pairs: skip\n  if (isInvisibleType(beforeToken.type) || getHtmlTagSide(beforeToken)) {\n    return findNonCodeVisibleTokenBefore(group, beforeToken)\n  }\n  // content, punctuation, bracket, group: return token\n  if (isNonCodeVisibleType(beforeToken.type)) {\n    return beforeToken\n  }\n  // code, unknown, container: return undefined\n  return\n}\n\n/**\n * Find a certain token after, which:\n * - group, content, punctuation, and bracket will be passed\n * - code, container, and unknown will be failed\n * - hyper mark, html pairs will be skipped\n */\nexport const findNonCodeVisibleTokenAfter = (\n  group: GroupToken,\n  token: Token | undefined\n): Token | undefined => {\n  if (!token) {\n    return\n  }\n  const afterToken = findTokenAfter(group, token)\n  if (!afterToken) {\n    return\n  }\n  // hyper mark, html pairs: skip\n  if (isInvisibleType(afterToken.type) || getHtmlTagSide(afterToken)) {\n    return findNonCodeVisibleTokenAfter(group, afterToken)\n  }\n  // content, punctuation, bracket, group: return token\n  if (isNonCodeVisibleType(afterToken.type)) {\n    return afterToken\n  }\n  // code, unknown, container: return undefined\n  return\n}\n\n/**\n * Find a certain token before, which:\n * - group, content, punctuation, bracket, and code will be passed\n * - container, and unknown will be failed\n * - hyper mark, html pairs will be skipped\n */\nexport const findVisibleTokenBefore = (\n  group: GroupToken,\n  token: Token | undefined\n): Token | undefined => {\n  if (!token) {\n    return\n  }\n  const beforeToken = findTokenBefore(group, token)\n  if (!beforeToken) {\n    return\n  }\n  // hyper mark, html pairs: skip\n  if (isInvisibleType(beforeToken.type) || getHtmlTagSide(beforeToken)) {\n    return findVisibleTokenBefore(group, beforeToken)\n  }\n  // content, punctuation, bracket, group, code: return token\n  if (isVisibleType(beforeToken.type)) {\n    return beforeToken\n  }\n  // unknown, container: return undefined\n  return\n}\n\n/**\n * Find a certain token after, which:\n * - group, content, punctuation, bracket, and code will be passed\n * - container, and unknown will be failed\n * - hyper mark, html pairs will be skipped\n */\nexport const findVisibleTokenAfter = (\n  group: GroupToken,\n  token: Token | undefined\n): Token | undefined => {\n  if (!token) {\n    return\n  }\n  const afterToken = findTokenAfter(group, token)\n  if (!afterToken) {\n    return\n  }\n  // hyper mark, html pairs: skip\n  if (isInvisibleType(afterToken.type) || getHtmlTagSide(afterToken)) {\n    return findVisibleTokenAfter(group, afterToken)\n  }\n  // content, punctuation, bracket, group, code: return token\n  if (isVisibleType(afterToken.type)) {\n    return afterToken\n  }\n  // unknown, container: return undefined\n  return\n}\n\n// hyper mark seq\n\nconst isHtmlTag = (token: Token): boolean => {\n  if (token.type !== HyperTokenType.HYPER_CONTENT) {\n    return false\n  }\n  return !!token.content.match(/^<.+>$/)\n}\n\nconst getHtmlTagSide = (token: Token): MarkSideType | undefined => {\n  if (!isHtmlTag(token)) {\n    return\n  }\n  if (token.content.match(/^<code.*>.*<\\/code.*>$/)) {\n    return\n  }\n  if (token.content.match(/^<[^/].+\\/\\s*>$/)) {\n    return\n  }\n  if (token.content.match(/^<[^/].+>$/)) {\n    return MarkSideType.LEFT\n  }\n  if (token.content.match(/^<\\/.+>$/)) {\n    return MarkSideType.RIGHT\n  }\n}\n\nexport const isWrapper = (token: Token): boolean => {\n  return token.type === HyperTokenType.HYPER_WRAPPER || !!getHtmlTagSide(token)\n}\n\nexport const getWrapperSide = (token: Token): MarkSideType | undefined => {\n  if (token.type === HyperTokenType.HYPER_WRAPPER) {\n    return token.markSide\n  }\n  return getHtmlTagSide(token)\n}\n\nconst spreadHyperMarkSeq = (\n  group: GroupToken,\n  token: Token,\n  seq: Token[],\n  isBackward: boolean\n): void => {\n  if (isBackward) {\n    const tokenBefore = findTokenBefore(group, token)\n    if (tokenBefore && isWrapper(tokenBefore)) {\n      seq.unshift(tokenBefore)\n      spreadHyperMarkSeq(group, tokenBefore, seq, isBackward)\n    }\n  } else {\n    const tokenAfter = findTokenAfter(group, token)\n    if (tokenAfter && isWrapper(tokenAfter)) {\n      seq.push(tokenAfter)\n      spreadHyperMarkSeq(group, tokenAfter, seq, isBackward)\n    }\n  }\n}\n\nexport const findConnectedWrappers = (\n  group: GroupToken,\n  token: Token\n): Token[] => {\n  const seq: Token[] = [token]\n  spreadHyperMarkSeq(group, token, seq, false)\n  spreadHyperMarkSeq(group, token, seq, true)\n  return seq\n}\n\nconst findSpaceHostInHyperMarkSeq = (\n  group: GroupToken,\n  hyperMarkSeq: Token[]\n): Token | undefined => {\n  // Return nothing if the seq is empty\n  if (!hyperMarkSeq.length) {\n    return\n  }\n\n  const firstMark = hyperMarkSeq[0]\n  const lastMark = hyperMarkSeq[hyperMarkSeq.length - 1]\n  const firstMarkSide = getWrapperSide(firstMark)\n  const lastMarkSide = getWrapperSide(lastMark)\n\n  const tokenBefore = findTokenBefore(group, firstMark)\n  if (!tokenBefore) {\n    return\n  }\n\n  // Return nothing if any token is not a mark.\n  if (!firstMarkSide || !lastMarkSide) {\n    return\n  }\n\n  // If first and last mark have the same side, then return:\n  // - token before first mark if they are the left side\n  // - last mark if they are the right side\n  if (firstMarkSide === lastMarkSide) {\n    if (firstMarkSide === MarkSideType.LEFT) {\n      return tokenBefore\n    }\n    return lastMark\n  }\n\n  // If first mark is the left side and last mark is the right side,\n  // that usually means multiple marks partially overlapped.\n  // This situation is abnormal but technically exists.\n  // We'd better do nothing and leave this issue to human.\n  if (firstMarkSide === MarkSideType.LEFT) {\n    return\n  }\n\n  // If first mark is the right side and last mark is the left side,\n  // that usually means multiple marks closely near eath other.\n  // We'd better find the gap outside the both sides of marks.\n  let target: Token | undefined = tokenBefore\n  while (target && target !== lastMark) {\n    const nextToken = findTokenAfter(group, target)\n    if (nextToken && getWrapperSide(nextToken) === MarkSideType.LEFT) {\n      return target\n    }\n    target = nextToken\n  }\n  return tokenBefore\n}\n\nexport const findWrappersBetween = (\n  group: GroupToken,\n  before: Token | undefined,\n  after: Token | undefined\n): {\n  spaceHost?: Token\n  wrappers: Token[]\n  tokens: Token[]\n} => {\n  if (!before || !after) {\n    return {\n      spaceHost: undefined,\n      wrappers: [],\n      tokens: []\n    }\n  }\n\n  const firstMark = findTokenAfter(group, before)\n  const firstVisible = findVisibleTokenAfter(group, before)\n  if (!firstMark || firstVisible !== after) {\n    return {\n      spaceHost: undefined,\n      wrappers: [],\n      tokens: []\n    }\n  }\n  if (firstMark === after) {\n    return {\n      spaceHost: before,\n      wrappers: [],\n      tokens: [before]\n    }\n  }\n\n  const markSeq = findConnectedWrappers(group, firstMark)\n  const spaceHost = findSpaceHostInHyperMarkSeq(group, markSeq)\n\n  return {\n    spaceHost,\n    wrappers: markSeq,\n    tokens: [before, ...markSeq]\n  }\n}\n\n// special cases\n\nexport const isHalfWidthPunctuationWithoutSpaceAround = (\n  group: GroupToken,\n  token: Token\n): boolean => {\n  const tokenBefore = findTokenBefore(group, token)\n  const tokenAfter = findTokenAfter(group, token)\n\n  if (\n    token.type === CharType.PUNCTUATION_HALF &&\n    tokenBefore &&\n    tokenBefore.type === CharType.LETTERS_HALF &&\n    tokenAfter &&\n    tokenAfter.type === CharType.LETTERS_HALF\n  ) {\n    return !tokenBefore.spaceAfter && !token.spaceAfter\n  }\n\n  return false\n}\n\nexport const isSuccessiveHalfWidthPunctuation = (\n  group: GroupToken,\n  token: Token\n): boolean => {\n  if (token.type === CharType.PUNCTUATION_HALF) {\n    const tokenBefore = findTokenBefore(group, token)\n    const tokenAfter = findTokenAfter(group, token)\n    if (\n      (tokenBefore &&\n        tokenBefore.type === CharType.PUNCTUATION_HALF &&\n        !tokenBefore.spaceAfter) ||\n      (tokenAfter &&\n        tokenAfter.type === CharType.PUNCTUATION_HALF &&\n        !token.spaceAfter)\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\n// validations helpers\n\nconst createValidation = (\n  token: Token,\n  target: ValidationTarget,\n  message: string,\n  name: string\n): Validation => {\n  const validation: Validation = {\n    index: token.index,\n    length: token.length,\n    target,\n    name,\n    message\n  }\n  if (target === ValidationTarget.START_CONTENT) {\n    validation.index = (token as GroupToken).startIndex\n    validation.length = 0\n  } else if (target === ValidationTarget.END_CONTENT) {\n    validation.index = (token as GroupToken).endIndex\n    validation.length = 0\n  } else if (target === ValidationTarget.INNER_SPACE_BEFORE) {\n    validation.index = (token as GroupToken).startIndex\n    validation.length = (token as GroupToken).startContent.length\n  }\n  return validation\n}\n\nexport const setValidationOnTarget = (\n  token: Token,\n  target: ValidationTarget,\n  message: string,\n  name: string\n): void => {\n  const validation = createValidation(token, target, message, name)\n  removeValidationOnTarget(token, target)\n  token.validations.push(validation)\n}\n\nexport const hasValidationOnTarget = (\n  token: Token,\n  target: ValidationTarget\n): boolean => {\n  return token.validations.some((validation) => validation.target === target)\n}\n\nexport const removeValidationOnTarget = (\n  token: Token,\n  target: ValidationTarget\n): void => {\n  token.validations = token.validations.filter(\n    (validation) => validation.target !== target\n  )\n}\n\n// validation checkers\n\ntype Checker = (token: Token, value: string, message: string) => void\n\nconst genChecker = (\n  key: keyof Token | keyof GroupToken,\n  target: ValidationTarget\n): Checker => {\n  return (token: Token, value: string, message: string) => {\n    if (token[key] !== value) {\n      token[key] = value\n      setValidationOnTarget(token, target, message, '')\n    }\n  }\n}\n\nexport const checkSpaceAfter: Checker = genChecker(\n  'modifiedSpaceAfter',\n  ValidationTarget.SPACE_AFTER\n)\n\nexport const checkStartContent: Checker = genChecker(\n  'modifiedStartContent',\n  ValidationTarget.START_CONTENT\n)\n\nexport const checkEndContent: Checker = genChecker(\n  'modifiedEndContent',\n  ValidationTarget.END_CONTENT\n)\n\nexport const checkInnerSpaceBefore: Checker = genChecker(\n  'modifiedInnerSpaceBefore',\n  ValidationTarget.INNER_SPACE_BEFORE\n)\n\nexport const checkContent = (\n  token: Token,\n  value: string,\n  type: TokenType,\n  message: string\n): void => {\n  if (token.modifiedContent === value) {\n    return\n  }\n  token.modifiedContent = value\n  token.modifiedType = type\n  setValidationOnTarget(token, ValidationTarget.CONTENT, message, '')\n}\n","/**\n * @fileoverview\n *\n * This rule is triming spaces of the whole string.\n *\n * Options\n * - trimSpace: boolean | undefined\n */\n\nimport { Handler, MutableGroupToken, MutableToken } from '../parser'\nimport { TRIM_SPACE } from './messages'\nimport {\n  checkInnerSpaceBefore,\n  checkSpaceAfter,\n  findVisibleTokenBefore,\n  findConnectedWrappers,\n  isWrapper,\n  Options\n} from './util'\n\nconst generateHandler = (options: Options): Handler => {\n  const trimSpaceOption = options?.trimSpace\n\n  return (token: MutableToken, index: number, group: MutableGroupToken) => {\n    if (!trimSpaceOption) {\n      return\n    }\n\n    // make sure it's the whole string\n    if (!group.startContent && index === 0) {\n      // remove inner space before\n      if (group.modifiedInnerSpaceBefore) {\n        checkInnerSpaceBefore(group, '', TRIM_SPACE)\n      }\n\n      // remove all spaces after beginning marks\n      if (isWrapper(token)) {\n        findConnectedWrappers(group, token).forEach((x) =>\n          checkSpaceAfter(x, '', TRIM_SPACE)\n        )\n      }\n\n      // get last visible content token -> remove all spaces after\n      const lastToken = group[group.length - 1]\n      if (lastToken) {\n        // 1. last token is a mark -> find last visible content token\n        // 2. last token is visible content\n        if (isWrapper(lastToken)) {\n          const lastContentToken = findVisibleTokenBefore(group, token)\n          if (lastContentToken) {\n            findConnectedWrappers(group, lastToken).forEach((x) =>\n              checkSpaceAfter(x, '', TRIM_SPACE)\n            )\n            checkSpaceAfter(lastContentToken, '', TRIM_SPACE)\n          }\n        } else {\n          checkSpaceAfter(lastToken, '', TRIM_SPACE)\n        }\n      }\n    }\n  }\n}\n\nexport const defaultConfig: Options = {\n  trimSpace: true\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule will format each punctuation into the right width options.\n *\n * Options:\n * - halfWidthPunctuation: string = `()`\n * - fullWidthPunctuation: string = `，。：；？！“”‘’`\n * - adjustedFullWidthPunctuation: string = `“”‘’`\n *\n * Details:\n * - skip half-width punctuations between half-width content without space\n * - skip successive multiple half-width punctuations\n */\n\nimport {\n  CharType,\n  GroupTokenType,\n  Handler,\n  isPunctuationType,\n  MutableGroupToken,\n  MutableToken,\n  HyperTokenType\n} from '../parser'\nimport { PUNCTUATION_FULL_WIDTH, PUNCTUATION_HALF_WIDTH } from './messages'\nimport {\n  checkContent,\n  checkEndContent,\n  checkStartContent,\n  isHalfWidthPunctuationWithoutSpaceAround,\n  isSuccessiveHalfWidthPunctuation,\n  Options\n} from './util'\n\ntype WidthPairList = Array<[halfWidth: string, fullWidth: string]>\ntype WidthSidePairList = Array<\n  [halfWidth: string, fullWidthLeftSide: string, fullWidthRightSide: string]\n>\ntype AlterMap = Record<string, string>\ntype AlterPairMap = Record<string, [leftSide: string, rightSide: string]>\n\nconst widthPairList: WidthPairList = [\n  [`(`, `（`],\n  [`)`, `）`],\n  [`,`, `，`],\n  [`.`, `。`],\n  [`;`, `；`],\n  [`:`, `：`],\n  [`?`, `？`],\n  [`!`, `！`]\n]\nconst widthSidePairList: WidthSidePairList = [\n  [`\"`, `“`, `”`],\n  [`'`, `‘`, `’`]\n]\n\nconst defaultHalfWidthOption = `()`\nconst defaultFullWidthOption = `，。：；？！“”‘’`\nconst defaultAdjustedFullWidthOption = `“”‘’`\n\nconst checkAdjusted = (token: MutableToken, adjusted: string): void => {\n  if (adjusted.indexOf(token.modifiedContent) >= 0) {\n    token.modifiedType = CharType.PUNCTUATION_HALF\n  }\n}\n\nconst parseOptions = (\n  options: Options\n): {\n  halfWidthMap: AlterMap\n  fullWidthMap: AlterMap\n  fullWidthPairMap: AlterPairMap\n  adjusted: string\n} => {\n  const halfWidthOption = options?.halfWidthPunctuation || ''\n  const fullWidthOption = options?.fullWidthPunctuation || ''\n  const adjustedFullWidthOption = options?.adjustedFullWidthPunctuation || ''\n\n  const halfWidthMap: AlterMap = {}\n  const fullWidthMap: AlterMap = {}\n  const fullWidthPairMap: AlterPairMap = {}\n\n  widthPairList.forEach(([halfWidth, fullWidth]) => {\n    if (halfWidthOption.indexOf(halfWidth) >= 0) {\n      halfWidthMap[fullWidth] = halfWidth\n    }\n    if (fullWidthOption.indexOf(fullWidth) >= 0) {\n      fullWidthMap[halfWidth] = fullWidth\n    }\n  })\n  widthSidePairList.forEach(([half, left, right]) => {\n    if (halfWidthOption.indexOf(half) >= 0) {\n      halfWidthMap[left] = half\n      halfWidthMap[right] = half\n    }\n    if (\n      fullWidthOption.indexOf(left) >= 0 ||\n      fullWidthOption.indexOf(right) >= 0\n    ) {\n      fullWidthPairMap[half] = [left, right]\n    }\n  })\n  return {\n    halfWidthMap,\n    fullWidthMap,\n    fullWidthPairMap,\n    adjusted: adjustedFullWidthOption\n  }\n}\n\nconst generateHandler = (options: Options): Handler => {\n  const { halfWidthMap, fullWidthMap, fullWidthPairMap, adjusted } =\n    parseOptions(options)\n\n  const handleHyperSpaceOption: Handler = (\n    token: MutableToken,\n    _,\n    group: MutableGroupToken\n  ) => {\n    // skip non-punctuation/quote/bracket situations\n    if (\n      !isPunctuationType(token.type) &&\n      token.type !== HyperTokenType.HYPER_WRAPPER_BRACKET &&\n      token.type !== GroupTokenType.GROUP\n    ) {\n      return\n    }\n\n    // skip half-width punctuations between half-width content without space\n    if (isHalfWidthPunctuationWithoutSpaceAround(group, token)) {\n      return\n    }\n\n    // skip successive multiple half-width punctuations\n    if (isSuccessiveHalfWidthPunctuation(group, token)) {\n      return\n    }\n\n    // 1. normal punctuations in the alter width map\n    // 2. brackets in the alter width map\n    if (\n      isPunctuationType(token.type) ||\n      token.type === HyperTokenType.HYPER_WRAPPER_BRACKET\n    ) {\n      const content = token.modifiedContent\n      if (fullWidthMap[content]) {\n        checkContent(\n          token,\n          fullWidthMap[content],\n          CharType.PUNCTUATION_FULL,\n          PUNCTUATION_FULL_WIDTH\n        )\n        checkAdjusted(token, adjusted)\n      } else if (halfWidthMap[content]) {\n        checkContent(\n          token,\n          halfWidthMap[content],\n          CharType.PUNCTUATION_HALF,\n          PUNCTUATION_HALF_WIDTH\n        )\n      }\n      return\n    }\n\n    // 3. quotes in the alter pair map\n    const startContent = (token as MutableGroupToken).modifiedStartContent\n    const endContent = (token as MutableGroupToken).modifiedEndContent\n    if (fullWidthPairMap[startContent]) {\n      checkStartContent(\n        token,\n        fullWidthPairMap[startContent][0],\n        PUNCTUATION_FULL_WIDTH\n      )\n    } else if (halfWidthMap[startContent]) {\n      checkStartContent(\n        token,\n        halfWidthMap[startContent][0],\n        PUNCTUATION_HALF_WIDTH\n      )\n    }\n    if (fullWidthPairMap[endContent]) {\n      checkEndContent(\n        token,\n        fullWidthPairMap[endContent][1],\n        PUNCTUATION_FULL_WIDTH\n      )\n    } else if (halfWidthMap[endContent]) {\n      checkEndContent(\n        token,\n        halfWidthMap[endContent][1],\n        PUNCTUATION_HALF_WIDTH\n      )\n    }\n  }\n  return handleHyperSpaceOption\n}\n\nexport const defaultConfig: Options = {\n  halfWidthPunctuation: defaultHalfWidthOption,\n  fullWidthPunctuation: defaultFullWidthOption,\n  adjustedFullWidthPunctuation: defaultAdjustedFullWidthOption\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule will unify similar punctuations into the same one.\n * Usually, it's just about Chinese quotes.\n *\n * Options:\n * - unifiedPunctuation: \"simplified\" (default) | \"traditional\" | undefined\n */\n\nimport { GroupTokenType, Handler, MutableToken } from '../parser'\nimport {\n  PUNCTUATION_UNIFICATION_SIMPLIFIED,\n  PUNCTUATION_UNIFICATION_TRADITIONAL\n} from './messages'\nimport { checkEndContent, checkStartContent, Options } from './util'\n\ntype UnifiedOptions = 'traditional' | 'simplified'\n\nenum QuoteType {\n  LEFT,\n  LEFT_EMBEDDED,\n  RIGHT_EMBEDDED,\n  RIGHT\n}\n\nconst replaceMap: Record<UnifiedOptions, Record<QuoteType, string>> = {\n  simplified: {\n    [QuoteType.LEFT]: `“`,\n    [QuoteType.LEFT_EMBEDDED]: `‘`,\n    [QuoteType.RIGHT_EMBEDDED]: `’`,\n    [QuoteType.RIGHT]: `”`\n  },\n  traditional: {\n    [QuoteType.LEFT]: `「`,\n    [QuoteType.LEFT_EMBEDDED]: `『`,\n    [QuoteType.RIGHT_EMBEDDED]: `』`,\n    [QuoteType.RIGHT]: `」`\n  }\n}\n\nconst valueToKey = (\n  obj: Record<QuoteType, string>\n): Record<string, QuoteType> => {\n  const result: Record<string, QuoteType> = {}\n  for (const key in obj) {\n    const value: string = obj[key]\n    result[value] = key as unknown as QuoteType\n  }\n  return result\n}\n\nconst checkChar = (\n  content: string,\n  objectMap: Record<string, QuoteType>,\n  unifiedMap: Record<QuoteType, string>\n): string => {\n  const key = objectMap[content]\n  if (key) {\n    return unifiedMap[key]\n  }\n  return content\n}\n\nconst generateHandler = (options: Options): Handler => {\n  const unifiedOption = options?.unifiedPunctuation\n\n  if (!unifiedOption) {\n    return () => {\n      // do nothing\n    }\n  }\n\n  const message =\n    unifiedOption === 'simplified'\n      ? PUNCTUATION_UNIFICATION_SIMPLIFIED\n      : PUNCTUATION_UNIFICATION_TRADITIONAL\n  const unifiedMap = replaceMap[unifiedOption]\n  const objectMap = valueToKey(\n    unifiedOption === 'simplified'\n      ? replaceMap.traditional\n      : replaceMap.simplified\n  )\n\n  const handlerPunctuationUnified = (token: MutableToken) => {\n    if (token.type !== GroupTokenType.GROUP) {\n      return\n    }\n    const modifiedStartContent = checkChar(\n      token.modifiedStartContent,\n      objectMap,\n      unifiedMap\n    )\n    const modifiedEndContent = checkChar(\n      token.modifiedEndContent,\n      objectMap,\n      unifiedMap\n    )\n    checkStartContent(token, modifiedStartContent, message)\n    checkEndContent(token, modifiedEndContent, message)\n  }\n\n  return handlerPunctuationUnified\n}\n\nexport const defaultConfig: Options = {\n  unifiedPunctuation: 'simplified'\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule is used to revert changes of abbreviations.\n *\n * Details:\n * - the point is rever the trailing dot\n */\n\nimport { CharType, Handler, MutableGroupToken, MutableToken } from '../parser'\nimport { ValidationTarget } from '../report'\nimport {\n  findTokenAfter,\n  findTokenBefore,\n  Options,\n  removeValidationOnTarget\n} from './util'\n\nconst defaultSkippedAbbrs = [\n  'Mr.',\n  'Mrs.',\n  'Dr.',\n  'Jr.',\n  'Sr.',\n  'vs.',\n  'etc.',\n  'i.e.',\n  'e.g.',\n  'a.k.a.'\n]\n\nconst reverseAbbrsIntoChars = (abbrs: string[]): string[][] => {\n  return abbrs.map((str) => str.split('.').reverse().slice(1))\n}\n\nconst matchAbbr = (\n  token: MutableToken,\n  group: MutableGroupToken,\n  reversedAbbrChars: string[][]\n): boolean => {\n  // find previous token\n  const tokenBefore = findTokenBefore(group, token)\n  if (tokenBefore && !tokenBefore.spaceAfter) {\n    // get the next matching abbr chars by removing the last char and filtering\n    const matchedAbbrChars = reversedAbbrChars\n      .filter(\n        (abbr) => abbr[0].toLowerCase() === tokenBefore.content.toLowerCase()\n      )\n      .map((abbr) => abbr.slice(1))\n\n    // keep matching until any abbr chars fully matched\n    // then return true\n    if (matchedAbbrChars.length) {\n      const lastMatched = matchedAbbrChars[matchedAbbrChars.length - 1]\n      if (lastMatched.length) {\n        const tokenBeforeBefore = findTokenBefore(group, tokenBefore)\n        if (\n          tokenBeforeBefore &&\n          !tokenBeforeBefore.spaceAfter &&\n          tokenBeforeBefore.content === '.'\n        ) {\n          const result = matchAbbr(tokenBeforeBefore, group, matchedAbbrChars)\n          if (result) {\n            return true\n          }\n        }\n      } else {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nconst generateHandler = (options: Options): Handler => {\n  const reversedAbbrChars = reverseAbbrsIntoChars(options.skipAbbrs || [])\n\n  return (token: MutableToken, index: number, group: MutableGroupToken) => {\n    // skip non-dot tokens\n    if (token.content !== '.') {\n      return\n    }\n\n    // make sure it's the ending dot of the abbr\n    const tokenAfter = findTokenAfter(group, token)\n    if (\n      tokenAfter &&\n      tokenAfter.type === CharType.LETTERS_HALF &&\n      !token.spaceAfter\n    ) {\n      return\n    }\n\n    // keep the dot if the previous tokens match any abbr\n    if (matchAbbr(token, group, reversedAbbrChars)) {\n      token.modifiedContent = '.'\n      token.modifiedType = token.type\n      removeValidationOnTarget(token, ValidationTarget.CONTENT)\n    }\n  }\n}\n\nexport const defaultConfig: Options = {\n  skipAbbrs: defaultSkippedAbbrs\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule is to ensure all the existing spaces should be outside hyper\n * marks like *, _, [, ], etc.\n *\n * Options:\n * - noSpaceInsideMark: boolean | undefined\n *\n * For example:\n * - `x _ ** yyy ** _ z` should be `x _**yyy**_ z`\n *\n * Details:\n * - left-mark x left-mark: `x _ **yyy**_ z`\n *                             ^^^\n * - right-mark x right-mark: `x _**yyy** _ z`\n *                                      ^^^\n * - left-mark x non-mark: `x _** yyy**_ z`\n *                              ^^^\n * - non-mark x right-mark: `x _**yyy **_ z`\n *                                 ^^^\n */\n\nimport {\n  Options,\n  checkSpaceAfter,\n  findTokenAfter,\n  isWrapper,\n  getWrapperSide\n} from './util'\nimport {\n  Handler,\n  MarkSideType,\n  MutableGroupToken,\n  MutableToken\n} from '../parser'\nimport { MARKDOWN_NOSPACE_INSIDE } from './messages'\n\nconst generateHandler = (options: Options): Handler => {\n  const noSpaceInsideMarkOption = options?.noSpaceInsideWrapper\n\n  return (token: MutableToken, _, group: MutableGroupToken) => {\n    // skip if there is no options\n    if (!noSpaceInsideMarkOption) {\n      return\n    }\n\n    // skip non-after-token situations\n    const tokenAfter = findTokenAfter(group, token)\n    if (!tokenAfter) {\n      return\n    }\n\n    // skip non-mark situations\n    if (!isWrapper(token) && !isWrapper(tokenAfter)) {\n      return\n    }\n\n    // 1. left x left, right x right\n    // 2. left x non-mark\n    // 3. non-mark x right\n    const markSideBefore = getWrapperSide(token)\n    const markSideAfter = getWrapperSide(tokenAfter)\n    if (markSideBefore === markSideAfter) {\n      checkSpaceAfter(token, '', MARKDOWN_NOSPACE_INSIDE)\n    } else if (markSideBefore === MarkSideType.LEFT && !isWrapper(tokenAfter)) {\n      checkSpaceAfter(token, '', MARKDOWN_NOSPACE_INSIDE)\n    } else if (markSideAfter === MarkSideType.RIGHT && !isWrapper(token)) {\n      checkSpaceAfter(token, '', MARKDOWN_NOSPACE_INSIDE)\n    }\n  }\n}\n\nexport const defaultConfig: Options = {\n  noSpaceInsideMark: true\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule will decide whether to keep a space outside inline code with\n * content like:\n * - xxx `foo` xxx\n * - xxx <code>foo</code> xxx\n * in markdown/html.\n *\n * Options:\n * - spaceOutsideCode: boolean | undefined\n *   - `true`: keep one space outside (default)\n *   - `false`: no space outside\n *   - `undefined`: do nothing, just keep the original format\n *\n * Details:\n * - code x code\n * - content x code\n * - code x content\n */\n\nimport {\n  Options,\n  checkSpaceAfter,\n  findVisibleTokenAfter,\n  findVisibleTokenBefore,\n  findWrappersBetween\n} from './util'\nimport {\n  Handler,\n  isLettersType,\n  MutableGroupToken,\n  MutableToken,\n  HyperTokenType\n} from '../parser'\nimport { CODE_NOSPACE_OUTSIDE, CODE_SPACE_OUTSIDE } from './messages'\n\nconst generateHandler = (options: Options): Handler => {\n  const needSpaceOption = options?.spaceOutsideCode\n  const spaceAfter = needSpaceOption ? ' ' : ''\n  const message = needSpaceOption ? CODE_SPACE_OUTSIDE : CODE_NOSPACE_OUTSIDE\n  const handleHyperSpaceOption: Handler = (\n    token: MutableToken,\n    _,\n    group: MutableGroupToken\n  ) => {\n    // skip if there is no options\n    if (typeof needSpaceOption === 'undefined') {\n      return\n    }\n\n    // skip non-code tokens\n    if (token.type !== HyperTokenType.HYPER_CONTENT_CODE) {\n      return\n    }\n\n    // skip non-after-token situations\n    const contentTokenBefore = findVisibleTokenBefore(group, token)\n    const contentTokenAfter = findVisibleTokenAfter(group, token)\n    const { spaceHost: beforeSpaceHost } = findWrappersBetween(\n      group,\n      contentTokenBefore,\n      token\n    )\n    const { spaceHost: afterSpaceHost } = findWrappersBetween(\n      group,\n      token,\n      contentTokenAfter\n    )\n\n    // content x code\n    if (contentTokenBefore && isLettersType(contentTokenBefore.type)) {\n      beforeSpaceHost && checkSpaceAfter(beforeSpaceHost, spaceAfter, message)\n    }\n    // code x content or code x code\n    if (\n      contentTokenAfter &&\n      (isLettersType(contentTokenAfter.type) ||\n        contentTokenAfter.type === HyperTokenType.HYPER_CONTENT_CODE)\n    ) {\n      afterSpaceHost && checkSpaceAfter(afterSpaceHost, spaceAfter, message)\n    }\n  }\n  return handleHyperSpaceOption\n}\n\nexport const defaultConfig: Options = {\n  spaceOutsideCode: true\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule is used to check whether there should be a space between\n * content.\n *\n * Options:\n * - spaceBetweenHalfWidthContent: boolean | undefined\n *   - `true`: ensure one space between half-width content (default)\n *   - `false` or `undefined`: do nothing, just keep the original format\n * - noSpaceBetweenFullWidthContent: boolean | undefined\n *   - `true`: remove the space between full-width content (default)\n *   - `false` or `undefined`: do nothing, just keep the original format\n * - spaceBetweenMixedWidthContent: boolean | undefined\n *   - `true`: keep one space between width-mixed content (default)\n *   - `false`: no space between width-mixed content\n *   - `undefined`: do nothing, just keep the original format\n *\n * Examples (betweenMixedWidthContent = true):\n * - *a*啊 -> *a* 啊\n * - *a *啊 -> *a* 啊\n * - *啊*a -> *啊* a\n * - *啊 *a -> *啊* a\n *\n * Examples (betweenMixedWidthContent = false):\n * - *a* 啊 -> *a*啊\n * - *a *啊 -> *a*啊\n * - *啊* a -> *啊*a\n * - *啊 *a -> *啊*a\n */\n\nimport {\n  CharType,\n  Handler,\n  isLettersType,\n  MutableGroupToken,\n  MutableToken\n} from '../parser'\nimport {\n  checkSpaceAfter,\n  findVisibleTokenAfter,\n  findWrappersBetween,\n  Options\n} from './util'\nimport {\n  CONTENT_NOSPACE_FULL_WIDTH,\n  CONTENT_NOSPACE_MIXED_WIDTH,\n  CONTENT_SPACE_HALF_WIDTH,\n  CONTENT_SPACE_MIXED_WIDTH\n} from './messages'\n\nconst generateHandler = (options: Options): Handler => {\n  const onlyOneBetweenHalfWidthContentOption =\n    options?.spaceBetweenHalfWidthLetters\n  const noBetweenFullWidthContentOption =\n    options?.noSpaceBetweenFullWidthLetters\n  const betweenMixedWidthContentOption = options?.spaceBetweenMixedWidthLetters\n\n  return (token: MutableToken, _: number, group: MutableGroupToken) => {\n    // skip non-content tokens\n    if (!isLettersType(token.type)) {\n      return\n    }\n\n    // skip non-content after-tokens\n    const contentTokenAfter = findVisibleTokenAfter(group, token)\n    if (!contentTokenAfter || !isLettersType(contentTokenAfter.type)) {\n      return\n    }\n\n    // find the space host\n    const { spaceHost, tokens } = findWrappersBetween(\n      group,\n      token,\n      contentTokenAfter\n    )\n\n    // skip if the space host is not found\n    if (!spaceHost) {\n      return\n    }\n\n    // 1. half x half, full x full\n    // 2. half x full, full x half\n    if (contentTokenAfter.type === token.type) {\n      // skip without custom option\n      if (token.type === CharType.LETTERS_HALF) {\n        if (!onlyOneBetweenHalfWidthContentOption) {\n          return\n        }\n        // skip if half-content x marks x half-content\n        if (\n          tokens.length > 1 &&\n          tokens.filter((token) => token.spaceAfter).length === 0\n        ) {\n          return\n        }\n      } else {\n        if (!noBetweenFullWidthContentOption) {\n          return\n        }\n      }\n\n      const spaceAfter = token.type === CharType.LETTERS_HALF ? ' ' : ''\n      const message =\n        token.type === CharType.LETTERS_HALF\n          ? CONTENT_SPACE_HALF_WIDTH\n          : CONTENT_NOSPACE_FULL_WIDTH\n\n      checkSpaceAfter(spaceHost, spaceAfter, message)\n    } else {\n      // skip without custom option\n      if (typeof betweenMixedWidthContentOption === 'undefined') {\n        return\n      }\n\n      const spaceAfter = betweenMixedWidthContentOption ? ' ' : ''\n      const message = betweenMixedWidthContentOption\n        ? CONTENT_SPACE_MIXED_WIDTH\n        : CONTENT_NOSPACE_MIXED_WIDTH\n\n      checkSpaceAfter(spaceHost, spaceAfter, message)\n    }\n  }\n}\n\nexport const defaultConfig: Options = {\n  spaceBetweenHalfWidthContent: true,\n  noSpaceBetweenFullWidthContent: true,\n  spaceBetweenMixedWidthContent: true\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule is checking spaces besides normal punctuations.\n * Usually, for full-width punctuations, we don't need any spaces around.\n * For half-width punctuations, we need a space after that.\n *\n * Options\n * - noSpaceBeforePunctuation: boolean | undefined\n *   - `true`: remove spaces before a half-width punctuation (default)\n *   - `false` or `undefined`: do nothing, just keep the original format\n * - spaceAfterHalfWidthPunctuation: boolean | undefined\n *   - `true`: ensure one space after a half-width punctuation (default)\n *   - `false` or `undefined`: do nothing, just keep the original format\n * - noSpaceAfterFullWidthPunctuation: boolean | undefined\n *   - `true`: remove spaces around a full-width punctuation (default)\n *   - `false` or `undefined`: do nothing, just keep the original format\n *\n * Details:\n * - noSpaceBeforePunctuation:\n *   content/right-quote/right-bracket/code x punctuation\n * - spaceAfterHalfWidthPunctuation:\n *   half x content/left-quote/left-bracket/code\n * - noSpaceAfterFullWidthPunctuation:\n *   full x content/left-quote/left-bracket/code\n *\n * - skip half-width punctuations between half-width content without space\n * - skip successive multiple half-width punctuations\n */\n\nimport {\n  CharType,\n  GroupTokenType,\n  Handler,\n  isLettersType,\n  isPunctuationType,\n  MarkSideType,\n  MutableGroupToken,\n  MutableToken,\n  HyperTokenType\n} from '../parser'\nimport {\n  checkSpaceAfter,\n  findVisibleTokenAfter,\n  findVisibleTokenBefore,\n  findWrappersBetween,\n  isHalfWidthPunctuationWithoutSpaceAround,\n  isSuccessiveHalfWidthPunctuation,\n  Options\n} from './util'\nimport {\n  PUNCTUATION_NOSPACE_AFTER,\n  PUNCTUATION_NOSPACE_BEFORE,\n  PUNCTUATION_SPACE_AFTER\n} from './messages'\n\nconst normalPunctuationList = `,.;:?!，、。；：？！`.split('')\nconst isNormalPunctuation = (char: string): boolean =>\n  normalPunctuationList.indexOf(char) >= 0\n\nconst generateHandler = (options: Options): Handler => {\n  const noBeforePunctuationOption = options?.noSpaceBeforePunctuation\n  const oneAfterHalfWidthPunctuationOption =\n    options?.spaceAfterHalfWidthPunctuation\n  const noAfterFullWidthPunctuationOption =\n    options?.noSpaceAfterFullWidthPunctuation\n\n  return (token: MutableToken, _: number, group: MutableGroupToken) => {\n    // skip non-punctuation tokens and non-normal punctuations\n    if (!isPunctuationType(token.type)) {\n      return\n    }\n    if (!isNormalPunctuation(token.content)) {\n      return\n    }\n\n    // skip half-width punctuations between half-width content without space\n    if (isHalfWidthPunctuationWithoutSpaceAround(group, token)) {\n      return\n    }\n\n    // skip successive multiple half-width punctuations\n    if (isSuccessiveHalfWidthPunctuation(group, token)) {\n      return\n    }\n\n    // 1. content/right-quote/right-bracket/code x punctuation\n    if (noBeforePunctuationOption) {\n      const contentTokenBefore = findVisibleTokenBefore(group, token)\n      if (\n        contentTokenBefore &&\n        // content\n        (isLettersType(contentTokenBefore.type) ||\n          // right-quote\n          contentTokenBefore.type === GroupTokenType.GROUP ||\n          // right-bracket\n          (contentTokenBefore.type === HyperTokenType.HYPER_WRAPPER_BRACKET &&\n            contentTokenBefore.markSide === MarkSideType.RIGHT) ||\n          // code\n          contentTokenBefore.type === HyperTokenType.HYPER_CONTENT_CODE)\n      ) {\n        const { spaceHost } = findWrappersBetween(\n          group,\n          contentTokenBefore,\n          token\n        )\n\n        if (spaceHost) {\n          checkSpaceAfter(spaceHost, '', PUNCTUATION_NOSPACE_BEFORE)\n        }\n      }\n    }\n\n    // 2. half/full x content/left-quote/left-bracket/code\n    if (\n      (token.modifiedType === CharType.PUNCTUATION_FULL &&\n        noAfterFullWidthPunctuationOption) ||\n      (token.modifiedType === CharType.PUNCTUATION_HALF &&\n        oneAfterHalfWidthPunctuationOption)\n    ) {\n      const spaceAfter =\n        token.modifiedType === CharType.PUNCTUATION_HALF ? ' ' : ''\n      const message =\n        token.modifiedType === CharType.PUNCTUATION_HALF\n          ? PUNCTUATION_SPACE_AFTER\n          : PUNCTUATION_NOSPACE_AFTER\n\n      const contentTokenAfter = findVisibleTokenAfter(group, token)\n      if (\n        contentTokenAfter &&\n        // content\n        (isLettersType(contentTokenAfter.type) ||\n          // left-quote\n          contentTokenAfter.type === GroupTokenType.GROUP ||\n          // left-bracket\n          (contentTokenAfter.type === HyperTokenType.HYPER_WRAPPER_BRACKET &&\n            contentTokenAfter.markSide === MarkSideType.LEFT) ||\n          // code\n          contentTokenAfter.type === HyperTokenType.HYPER_CONTENT_CODE)\n      ) {\n        const { spaceHost } = findWrappersBetween(\n          group,\n          token,\n          contentTokenAfter\n        )\n\n        if (spaceHost) {\n          checkSpaceAfter(spaceHost, spaceAfter, message)\n        }\n      }\n    }\n  }\n}\n\nexport const defaultConfig: Options = {\n  noSpaceBeforePunctuation: true,\n  spaceAfterHalfWidthPunctuation: true,\n  noSpaceAfterFullWidthPunctuation: true\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule is checking spaces besides quotes.\n *\n * Options\n * - noSpaceInsideQuote: boolean | undefined\n * - spaceOutsideHalfQuote: boolean | undefined\n * - noSpaceOutsideFullQuote: boolean | undefined\n *\n * Details:\n * - noSpaceInsideQuote:\n *   - left-quote x right-quote\n *   - content/punctuation/right-quote/right-bracket/code/unknown/container x right-quote\n *   - left-quote x content/punctuation/left-quote/left-bracket/code/unknown/container\n * - spaceOutsideHalfQuote:\n *   - right-half-quote x left-half-quote\n *   - content/code x left-half-quote\n *   - right-half-quote x content/code\n * - noSpaceOutsideFullQuote:\n *   - right-full-quote x left-full-quote\n *   - content/code x left-full-quote\n *   - right-full-quote x content/code\n */\n\nimport {\n  GroupTokenType,\n  Handler,\n  isLettersType,\n  isFullWidthPair,\n  MarkSideType,\n  MutableGroupToken,\n  MutableToken,\n  HyperTokenType\n} from '../parser'\nimport {\n  checkInnerSpaceBefore,\n  checkSpaceAfter,\n  findWrappersBetween,\n  findNonCodeVisibleTokenAfter,\n  findNonCodeVisibleTokenBefore,\n  Options\n} from './util'\nimport {\n  QUOTE_NOSPACE_INSIDE,\n  QUOTE_NOSPACE_OUTSIDE,\n  QUOTE_SPACE_OUTSIDE\n} from './messages'\n\nconst isFullWidth = (char: string, adjusted: string): boolean => {\n  return isFullWidthPair(char) && adjusted.indexOf(char) === -1\n}\n\nconst generateHandler = (options: Options): Handler => {\n  const noSpaceInsideQuoteOption = options.noSpaceInsideQuote\n  const spaceOutsideHalfQuoteOption = options.spaceOutsideHalfQuote\n  const noSpaceOutsideFullQuoteOption = options.noSpaceOutsideFullQuote\n  const adjustedFullWidthOption = options.adjustedFullWidthPunctuation || ''\n\n  return (token: MutableToken, _: number, group: MutableGroupToken) => {\n    // skip non-group tokens\n    if (token.type !== GroupTokenType.GROUP) {\n      return\n    }\n\n    // 1. no space inside quote\n    if (noSpaceInsideQuoteOption) {\n      // 1.1 left-quote x content/punctuation/left-quote/left-bracket/code/unknown/container\n      const firstInsdieToken = token[0]\n      if (\n        firstInsdieToken &&\n        firstInsdieToken.markSide !== MarkSideType.RIGHT\n      ) {\n        checkInnerSpaceBefore(token, '', QUOTE_NOSPACE_INSIDE)\n      }\n\n      // 1.2 content/punctuation/right-quote/right-bracket/code/unknown/container x right-quote\n      const lastInsideToken = token[token.length - 1]\n      if (lastInsideToken && lastInsideToken.markSide !== MarkSideType.LEFT) {\n        checkSpaceAfter(lastInsideToken, '', QUOTE_NOSPACE_INSIDE)\n      }\n\n      // 1.3 left-quote x right-quote\n      if (!firstInsdieToken) {\n        checkInnerSpaceBefore(token, '', QUOTE_NOSPACE_INSIDE)\n      }\n    }\n\n    // 2. space outside half/full quote\n    if (\n      typeof spaceOutsideHalfQuoteOption !== 'undefined' ||\n      noSpaceOutsideFullQuoteOption\n    ) {\n      // 2.1 right-quote x left-quote\n      const contentTokenAfter = findNonCodeVisibleTokenAfter(group, token)\n      if (\n        contentTokenAfter &&\n        contentTokenAfter.type === GroupTokenType.GROUP\n      ) {\n        const { spaceHost } = findWrappersBetween(\n          group,\n          token,\n          contentTokenAfter\n        )\n        if (spaceHost) {\n          const fullWidth =\n            isFullWidth(token.modifiedEndContent, adjustedFullWidthOption) ||\n            isFullWidth(\n              contentTokenAfter.modifiedStartContent,\n              adjustedFullWidthOption\n            )\n          // 2.1.1 right-full-quote x left-full-quote\n          // 2.1.2 right-half-quote x left-half-quote\n          if (fullWidth) {\n            if (noSpaceOutsideFullQuoteOption) {\n              checkSpaceAfter(spaceHost, '', QUOTE_SPACE_OUTSIDE)\n            }\n          } else {\n            if (typeof spaceOutsideHalfQuoteOption !== 'undefined') {\n              const spaceAfter = spaceOutsideHalfQuoteOption ? ' ' : ''\n              const message = spaceOutsideHalfQuoteOption\n                ? QUOTE_SPACE_OUTSIDE\n                : QUOTE_NOSPACE_OUTSIDE\n              checkSpaceAfter(spaceHost, spaceAfter, message)\n            }\n          }\n        }\n      }\n\n      // 2.2 content/code x left-quote\n      const contentTokenBefore = findNonCodeVisibleTokenBefore(group, token)\n      if (\n        contentTokenBefore &&\n        (isLettersType(contentTokenBefore.type) ||\n          contentTokenBefore.type === HyperTokenType.HYPER_CONTENT_CODE)\n      ) {\n        const { spaceHost } = findWrappersBetween(\n          group,\n          contentTokenBefore,\n          token\n        )\n        if (spaceHost) {\n          const fullWidth = isFullWidth(\n            token.modifiedStartContent,\n            adjustedFullWidthOption\n          )\n\n          // 2.2.1 content/code x left-full-quote\n          // 2.2.2 content/code x left-half-quote\n          if (fullWidth) {\n            if (noSpaceOutsideFullQuoteOption) {\n              checkSpaceAfter(spaceHost, '', QUOTE_NOSPACE_OUTSIDE)\n            }\n          } else {\n            if (typeof spaceOutsideHalfQuoteOption !== 'undefined') {\n              const spaceAfter = spaceOutsideHalfQuoteOption ? ' ' : ''\n              const message = spaceOutsideHalfQuoteOption\n                ? QUOTE_SPACE_OUTSIDE\n                : QUOTE_NOSPACE_OUTSIDE\n              checkSpaceAfter(spaceHost, spaceAfter, message)\n            }\n          }\n        }\n      }\n\n      // 2.3 right-quote x content/code\n      if (\n        contentTokenAfter &&\n        (isLettersType(contentTokenAfter.type) ||\n          contentTokenAfter.type === HyperTokenType.HYPER_CONTENT_CODE)\n      ) {\n        const { spaceHost } = findWrappersBetween(\n          group,\n          token,\n          contentTokenAfter\n        )\n        if (spaceHost) {\n          const fullWidth = isFullWidth(\n            token.modifiedEndContent,\n            adjustedFullWidthOption\n          )\n\n          // 2.3.1 right-full-quote x content/code\n          // 2.3.2 right-half-quote x content/code\n          if (fullWidth) {\n            if (noSpaceOutsideFullQuoteOption) {\n              checkSpaceAfter(spaceHost, '', QUOTE_NOSPACE_OUTSIDE)\n            }\n          } else {\n            if (typeof spaceOutsideHalfQuoteOption !== 'undefined') {\n              const spaceAfter = spaceOutsideHalfQuoteOption ? ' ' : ''\n              const message = spaceOutsideHalfQuoteOption\n                ? QUOTE_SPACE_OUTSIDE\n                : QUOTE_NOSPACE_OUTSIDE\n              checkSpaceAfter(spaceHost, spaceAfter, message)\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nexport const defaultConfig: Options = {\n  spaceOutsideHalfQuote: true,\n  noSpaceInsideQuote: true,\n  noSpaceOutsideFullQuote: true\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule is checking spaces besides brackets.\n *\n * Options\n * - noSpaceInsideBracket: boolean | undefined\n * - spaceOutsideHalfBracket: boolean | undefined\n * - nospaceOutsideFullBracket: boolean | undefined\n *\n * Details:\n * - noSpaceInsideBracket:\n *   - left-bracket x anything\n *   - non-left-bracket x right-bracket\n * - spaceOutsideHalfBracket:\n *   - right-half-bracket x left-half-bracket\n *   - right-half-bracket x content/left-quote/code\n *   - content/right-quote/code x left-half-bracket\n * - noSpaceOutsideFullBracket:\n *   - right-full-bracket x left-full-bracket\n *   - right-full-bracket x content/left-quote/code\n *   - content/right-quote/code x left-full-bracket\n */\n\nimport {\n  CharType,\n  GroupTokenType,\n  Handler,\n  isLettersType,\n  isFullWidthPair,\n  MarkSideType,\n  MutableGroupToken,\n  MutableSingleToken,\n  MutableToken,\n  HyperTokenType\n} from '../parser'\nimport {\n  checkSpaceAfter,\n  findVisibleTokenAfter,\n  findVisibleTokenBefore,\n  findWrappersBetween,\n  findTokenAfter,\n  findTokenBefore,\n  Options\n} from './util'\nimport {\n  BRACKET_NOSPACE_INSIDE,\n  BRACKET_NOSPACE_OUTSIDE,\n  BRACKET_SPACE_OUTSIDE\n} from './messages'\n\nconst isFullWidth = (char: string, adjusted: string): boolean => {\n  return isFullWidthPair(char) && adjusted.indexOf(char) === -1\n}\n\nconst shouldSkip = (\n  before: MutableToken | undefined,\n  beforeTokenSeq: MutableToken[],\n  token: MutableSingleToken,\n  afterTokenSeq: MutableToken[],\n  after: MutableToken | undefined\n): boolean => {\n  if (!before || !after) {\n    return false\n  }\n  if (\n    isFullWidthPair(token.content) ||\n    isFullWidthPair(token.modifiedContent)\n  ) {\n    return false\n  }\n  if (\n    beforeTokenSeq.filter((x) => x.spaceAfter).length ||\n    afterTokenSeq.filter((x) => x.spaceAfter).length\n  ) {\n    return false\n  }\n  return (\n    // x(x\n    //  ^\n    (before.type === CharType.LETTERS_HALF ||\n      // x()\n      //  ^\n      (before.content === '(' && token.content === ')')) &&\n    // x)x\n    //  ^\n    (after.type === CharType.LETTERS_HALF ||\n      // ()x\n      //  ^\n      (token.content === '(' && after.content === ')'))\n  )\n}\n\nconst generateHandler = (options: Options): Handler => {\n  const noInsideBracketOption = options.noSpaceInsideBracket\n  const spaceOutsideHalfBracketOption = options.spaceOutsideHalfBracket\n  const noSpaceOutsideFullBracketOption = options.noSpaceOutsideFullBracket\n  const adjustedFullWidthOption = options.adjustedFullWidthPunctuation || ''\n\n  return (token: MutableToken, _: number, group: MutableGroupToken) => {\n    // skip non-bracket tokens\n    if (token.type !== HyperTokenType.HYPER_WRAPPER_BRACKET) {\n      return\n    }\n\n    // 1. no space inside bracket\n    if (noInsideBracketOption) {\n      if (token.markSide === MarkSideType.LEFT) {\n        // no space after\n        const tokenAfter = findTokenAfter(group, token)\n        if (tokenAfter) {\n          checkSpaceAfter(token, '', BRACKET_NOSPACE_INSIDE)\n        }\n      } else {\n        // no space before\n        const tokenBefore = findTokenBefore(group, token)\n        if (\n          tokenBefore &&\n          // dedupe\n          tokenBefore.markSide !== MarkSideType.LEFT\n        ) {\n          checkSpaceAfter(tokenBefore, '', BRACKET_NOSPACE_INSIDE)\n        }\n      }\n    }\n\n    // skip bracket between half-width content without spaces\n    // or empty brackets beside half-width content without spaces\n    const contentTokenBefore = findVisibleTokenBefore(group, token)\n    const contentTokenAfter = findVisibleTokenAfter(group, token)\n    const { spaceHost: beforeSpaceHost, tokens: beforeTokenSeq } =\n      findWrappersBetween(group, contentTokenBefore, token)\n    const { spaceHost: afterSpaceHost, tokens: afterTokenSeq } =\n      findWrappersBetween(group, token, contentTokenAfter)\n    if (\n      shouldSkip(\n        contentTokenBefore,\n        beforeTokenSeq,\n        token,\n        afterTokenSeq,\n        contentTokenAfter\n      )\n    ) {\n      return\n    }\n\n    // 2. spaces outside half/full bracket\n    if (\n      typeof spaceOutsideHalfBracketOption !== 'undefined' ||\n      noSpaceOutsideFullBracketOption\n    ) {\n      const fullWidth = isFullWidth(\n        token.modifiedContent,\n        adjustedFullWidthOption\n      )\n\n      // 2.1 right-bracket x left-bracket\n      if (contentTokenAfter) {\n        if (\n          token.markSide === MarkSideType.RIGHT &&\n          contentTokenAfter.markSide === MarkSideType.LEFT\n        ) {\n          if (afterSpaceHost) {\n            const hasFullWidth =\n              fullWidth ||\n              isFullWidth(\n                contentTokenAfter.modifiedContent,\n                adjustedFullWidthOption\n              )\n\n            // 2.1.1 any-full-bracket\n            // 2.1.2 right-half-bracket x left-half-bracket\n            if (hasFullWidth) {\n              if (noSpaceOutsideFullBracketOption) {\n                checkSpaceAfter(token, '', BRACKET_NOSPACE_OUTSIDE)\n              }\n            } else {\n              // skip no spaces between\n              if (afterTokenSeq.filter((x) => x.spaceAfter).length > 0) {\n                if (typeof spaceOutsideHalfBracketOption !== 'undefined') {\n                  const spaceAfter = spaceOutsideHalfBracketOption ? ' ' : ''\n                  const message = spaceOutsideHalfBracketOption\n                    ? BRACKET_SPACE_OUTSIDE\n                    : BRACKET_NOSPACE_OUTSIDE\n                  checkSpaceAfter(token, spaceAfter, message)\n                }\n              }\n            }\n          }\n        }\n      }\n\n      // 2.2 content/right-quote/code x left-bracket\n      // 2.3 right-racket x content/left-quote/code\n      if (token.markSide === MarkSideType.LEFT) {\n        if (\n          contentTokenBefore &&\n          (isLettersType(contentTokenBefore.type) ||\n            contentTokenBefore.type === GroupTokenType.GROUP ||\n            contentTokenBefore.type === HyperTokenType.HYPER_CONTENT_CODE)\n        ) {\n          if (beforeSpaceHost) {\n            // 2.2.1 content/right-quote/code x left-full-bracket\n            // 2.2.2 content/right-quote/code x left-half-bracket\n            if (\n              fullWidth ||\n              (contentTokenBefore.type === GroupTokenType.GROUP &&\n                isFullWidth(\n                  contentTokenBefore.modifiedEndContent,\n                  adjustedFullWidthOption\n                ))\n            ) {\n              if (noSpaceOutsideFullBracketOption) {\n                checkSpaceAfter(beforeSpaceHost, '', BRACKET_NOSPACE_OUTSIDE)\n              }\n            } else {\n              if (typeof spaceOutsideHalfBracketOption !== 'undefined') {\n                const spaceAfter = spaceOutsideHalfBracketOption ? ' ' : ''\n                const message = spaceOutsideHalfBracketOption\n                  ? BRACKET_SPACE_OUTSIDE\n                  : BRACKET_NOSPACE_OUTSIDE\n                checkSpaceAfter(beforeSpaceHost, spaceAfter, message)\n              }\n            }\n          }\n        }\n      } else {\n        if (\n          contentTokenAfter &&\n          (isLettersType(contentTokenAfter.type) ||\n            contentTokenAfter.type === GroupTokenType.GROUP ||\n            contentTokenAfter.type === HyperTokenType.HYPER_CONTENT_CODE)\n        ) {\n          if (afterSpaceHost) {\n            // 2.3.1 right-full-bracket x content/left-quote/code\n            // 2.4.2 right-half-bracket x content/left-quote/code\n            if (\n              fullWidth ||\n              (contentTokenAfter.type === GroupTokenType.GROUP &&\n                isFullWidth(\n                  contentTokenAfter.modifiedStartContent,\n                  adjustedFullWidthOption\n                ))\n            ) {\n              if (noSpaceOutsideFullBracketOption) {\n                checkSpaceAfter(afterSpaceHost, '', BRACKET_NOSPACE_OUTSIDE)\n              }\n            } else {\n              if (typeof spaceOutsideHalfBracketOption !== 'undefined') {\n                const spaceAfter = spaceOutsideHalfBracketOption ? ' ' : ''\n                const message = spaceOutsideHalfBracketOption\n                  ? BRACKET_SPACE_OUTSIDE\n                  : BRACKET_NOSPACE_OUTSIDE\n                checkSpaceAfter(afterSpaceHost, spaceAfter, message)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nexport const defaultConfig: Options = {\n  spaceOutsideHalfBracket: true,\n  noSpaceInsideBracket: true\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule is used to revert changes of spaceAfter with linebreaks.\n * And it's compulsory.\n *\n * TODO: better blockquote and indentation handling in markdown\n */\n\nimport { Handler, MutableToken } from '../parser'\nimport { ValidationTarget } from '../report'\nimport { Options, removeValidationOnTarget } from './util'\n\nconst generateHandler = (options: Options): Handler => {\n  // do nothing\n  options\n\n  return (token: MutableToken) => {\n    if (token.spaceAfter && token.spaceAfter.match(/\\n/)) {\n      removeValidationOnTarget(token, ValidationTarget.SPACE_AFTER)\n      token.modifiedSpaceAfter = token.spaceAfter\n    }\n  }\n}\n\nexport const defaultConfig: Options = {}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule is used to revert changes of spaceAfter between numbers and\n * Chinese units.\n */\n\nimport {\n  CharType,\n  checkCharType,\n  Handler,\n  MutableGroupToken,\n  MutableToken\n} from '../parser'\nimport { ValidationTarget } from '../report'\nimport {\n  findWrappersBetween,\n  findNonCodeVisibleTokenAfter,\n  findNonCodeVisibleTokenBefore,\n  Options,\n  removeValidationOnTarget\n} from './util'\n\nconst defaultSkippedZhUnits = `年月日天号时分秒`\n\nconst generateHandler = (options: Options): Handler => {\n  const skippedZhUnits = options?.skipZhUnits || ''\n  const matcherStr = skippedZhUnits\n    .split('')\n    .filter((x) => checkCharType(x) === CharType.LETTERS_FULL)\n    .join('')\n  const unitMatcher = new RegExp(`^[${matcherStr}]`)\n\n  return (token: MutableToken, _: number, group: MutableGroupToken) => {\n    // make sure the content is a number\n    if (token.type === CharType.LETTERS_HALF && token.content.match(/^\\d+$/)) {\n      // make sure the content after is a Chinese unit\n      const tokenAfter = findNonCodeVisibleTokenAfter(group, token)\n      if (tokenAfter && tokenAfter.content.match(unitMatcher)) {\n        // make sure there is no space between originally\n        const { spaceHost: spaceHostAfter, tokens: tokenSeqAfter } =\n          findWrappersBetween(group, token, tokenAfter)\n        const hasSpaceAfterOriginally = tokenSeqAfter.some((x) => x.spaceAfter)\n        if (hasSpaceAfterOriginally) {\n          return\n        }\n\n        // if any token before\n        const tokenBefore = findNonCodeVisibleTokenBefore(group, token)\n        if (tokenBefore) {\n          // make sure there is no space between originally\n          const { spaceHost: spaceHostBefore, tokens: tokenSeqBefore } =\n            findWrappersBetween(group, tokenBefore, token)\n          const hasSpaceBeforeOriginally = tokenSeqBefore.some(\n            (x) => x.spaceAfter\n          )\n          if (hasSpaceBeforeOriginally) {\n            return\n          }\n\n          // revert non-space before\n          if (spaceHostBefore) {\n            spaceHostBefore.modifiedSpaceAfter = ''\n            removeValidationOnTarget(\n              spaceHostBefore,\n              ValidationTarget.SPACE_AFTER\n            )\n          }\n        }\n\n        // revert non-space after\n        if (spaceHostAfter) {\n          spaceHostAfter.modifiedSpaceAfter = ''\n          removeValidationOnTarget(spaceHostAfter, ValidationTarget.SPACE_AFTER)\n        }\n      }\n    }\n  }\n}\n\nexport const defaultConfig: Options = {\n  skipZhUnits: defaultSkippedZhUnits\n}\n\nexport default generateHandler\n","/**\n * @fileoverview\n *\n * This rule is used to revert changes of HTML entities.\n *\n * Details:\n * - to match `&<half-width-content>;`\n */\n\nimport { CharType, Handler, MutableGroupToken, MutableToken } from '../parser'\nimport { ValidationTarget } from '../report'\nimport {\n  findWrappersBetween,\n  findNonCodeVisibleTokenAfter,\n  findTokenAfter,\n  Options,\n  removeValidationOnTarget\n} from './util'\n\nconst generateHandler = (options: Options): Handler => {\n  options\n\n  return (token: MutableToken, _: number, group: MutableGroupToken) => {\n    // skip non-& tokens\n    if (token.content !== '&') {\n      return\n    }\n\n    // skip non-half-width-content tokens\n    const tokenAfter = findTokenAfter(group, token)\n    if (\n      !tokenAfter ||\n      tokenAfter.type !== CharType.LETTERS_HALF ||\n      token.spaceAfter\n    ) {\n      return\n    }\n\n    // skip non-semicolon tokens\n    const thirdToken = findTokenAfter(group, tokenAfter)\n    if (!thirdToken || thirdToken.content !== ';' || tokenAfter.spaceAfter) {\n      return\n    }\n\n    // revert &\n    token.modifiedContent = token.content\n    token.modifiedType = token.type\n    token.modifiedSpaceAfter = token.spaceAfter\n    removeValidationOnTarget(token, ValidationTarget.CONTENT)\n    removeValidationOnTarget(token, ValidationTarget.SPACE_AFTER)\n\n    // revert half-width content\n    tokenAfter.modifiedContent = tokenAfter.content\n    tokenAfter.modifiedType = tokenAfter.type\n    tokenAfter.modifiedSpaceAfter = tokenAfter.spaceAfter\n    removeValidationOnTarget(tokenAfter, ValidationTarget.CONTENT)\n    removeValidationOnTarget(tokenAfter, ValidationTarget.SPACE_AFTER)\n\n    // revert ;\n    thirdToken.modifiedContent = thirdToken.content\n    thirdToken.modifiedType = thirdToken.type\n    removeValidationOnTarget(thirdToken, ValidationTarget.CONTENT)\n    removeValidationOnTarget(thirdToken, ValidationTarget.SPACE_AFTER)\n\n    const nextToken = findNonCodeVisibleTokenAfter(group, thirdToken)\n    if (nextToken) {\n      const { spaceHost } = findWrappersBetween(group, thirdToken, nextToken)\n      if (spaceHost) {\n        spaceHost.modifiedSpaceAfter = spaceHost.spaceAfter\n        removeValidationOnTarget(spaceHost, ValidationTarget.SPACE_AFTER)\n      }\n    }\n  }\n}\n\nexport const defaultConfig: Options = {}\n\nexport default generateHandler\n","import { Handler } from '../parser'\nimport { Options } from './util'\n\nimport genSpaceTrimGenerateHandler from './space-trim'\n\nimport genPunctuationWidthHandler from './punctuation-width'\nimport genPunctuationUnificationHandler from './punctuation-unification'\n\nimport genAbbrsHandler from './case-abbrs'\n\nimport genSpaceOfWrapperHandler from './space-wrapper'\nimport genSpaceOfCodeHandler from './space-code'\nimport genSpaceOfLettersHandler from './space-letters'\nimport genSpaceOfPunctuationHandler from './space-punctuation'\nimport genSpaceOfQuoteHandler from './space-quote'\nimport genSpaceOfBracketHandler from './space-bracket'\n\nimport genLinebreakHandler from './case-linebreak'\nimport genZhUnitsHandler from './case-zh-units'\nimport genHtmlEntityHandler from './case-html-entity'\n\nconst generateHandlers = (options: Options): Handler[] => {\n  return [\n    genSpaceTrimGenerateHandler(options),\n\n    genPunctuationWidthHandler(options),\n    genPunctuationUnificationHandler(options),\n\n    genAbbrsHandler(options),\n\n    genSpaceOfWrapperHandler(options),\n    genSpaceOfCodeHandler(options),\n    genSpaceOfLettersHandler(options),\n    genSpaceOfPunctuationHandler(options),\n    genSpaceOfQuoteHandler(options),\n    genSpaceOfBracketHandler(options),\n    genLinebreakHandler(options),\n\n    genZhUnitsHandler(options),\n    genHtmlEntityHandler(options)\n  ]\n}\n\nexport const defaultConfig: Options = {\n  noSinglePair: true,\n  halfWidthPunctuation: `()`,\n  fullWidthPunctuation: `，。：；？！“”‘’`,\n  adjustedFullWidthPunctuation: `“”‘’`,\n  unifiedPunctuation: 'simplified',\n  spaceBetweenHalfWidthLetters: true,\n  noSpaceBetweenFullWidthLetters: true,\n  spaceBetweenMixedWidthLetters: true,\n  noSpaceBeforePunctuation: true,\n  spaceAfterHalfWidthPunctuation: true,\n  noSpaceAfterFullWidthPunctuation: true,\n  spaceOutsideHalfQuote: true,\n  noSpaceOutsideFullQuote: true,\n  noSpaceInsideQuote: true,\n  spaceOutsideHalfBracket: true,\n  noSpaceOutsideFullBracket: true,\n  noSpaceInsideBracket: true,\n  spaceOutsideCode: true,\n  noSpaceInsideWrapper: true,\n  trimSpace: true,\n  skipZhUnits: `年月日天号时分秒`,\n  skipAbbrs: [\n    'Mr.',\n    'Mrs.',\n    'Dr.',\n    'Jr.',\n    'Sr.',\n    'vs.',\n    'etc.',\n    'i.e.',\n    'e.g.',\n    'a.k.a.'\n  ]\n}\n\nexport default generateHandlers\n","import { ParsedStatus } from './hypers/types'\nimport { IgnoredCase } from './ignore'\nimport { Options as RuleOptions } from './rules/util'\n\nexport type Options = {\n  logger?: Console\n  rules?: RuleOptions\n  hyperParse?:\n    | (string | ((status: ParsedStatus) => ParsedStatus))[]\n    | ((status: ParsedStatus) => ParsedStatus)\n  ignoredCases?: IgnoredCase[]\n}\n\nexport type NormalizedOptions = {\n  logger: Console\n  rules: RuleOptions\n  hyperParse: Array<(status: ParsedStatus) => ParsedStatus>\n  ignoredCases: IgnoredCase[]\n}\n\nimport ignore, { parseIngoredCase } from './hypers/ignore'\nimport hexo from './hypers/hexo'\nimport vuepress from './hypers/vuepress'\nimport md from './hypers/md'\n\nimport { defaultConfig as defaultRules } from './rules'\n\nimport { env } from './report'\nimport { Config } from './rc'\n\nconst hyperParseInfo = [\n  { name: 'ignore', value: ignore },\n  { name: 'hexo', value: hexo },\n  { name: 'vuepress', value: vuepress },\n  { name: 'markdown', value: md }\n]\n\nconst arrToMap = <T>(\n  arr: { name: string; value: T }[]\n): { [name: string]: T } =>\n  arr.reduce((current, { name, value }) => {\n    current[name] = value\n    return current\n  }, {})\n\nconst hyperParseMap =\n  arrToMap<(status: ParsedStatus) => ParsedStatus>(hyperParseInfo)\n\nconst matchCallArray = <T>(calls: unknown[], map: { [name: string]: T }): T[] =>\n  calls\n    .map((call) => {\n      switch (typeof call) {\n        case 'function':\n          return call\n        case 'string':\n          return map[call]\n        default:\n          return null\n      }\n    })\n    .filter(Boolean) as T[]\n\nconst DEPRECATED_OPTIONS = {\n  noSpaceInsideMark: 'noSpaceInsideWrapper',\n  spaceBetweenHalfWidthContent: 'spaceBetweenHalfWidthLetters',\n  noSpaceBetweenFullWidthContent: 'noSpaceBetweenFullWidthLetters',\n  spaceBetweenMixedWidthContent: 'spaceBetweenMixedWidthLetters'\n}\n\nconst deprecateOptions = (ruleOption: RuleOptions, logger: Console): void => {\n  for (const oldKey in DEPRECATED_OPTIONS) {\n    const newKey = DEPRECATED_OPTIONS[oldKey]\n    if (ruleOption[oldKey]) {\n      logger.warn(`[deprecate] ${oldKey} is deprecated, use ${newKey} instead`)\n      ruleOption[newKey] = ruleOption[newKey] ?? ruleOption[oldKey]\n      delete ruleOption[oldKey]\n    }\n  }\n}\n\nexport const normalizeOptions = (options: Options): NormalizedOptions => {\n  const logger = options.logger ?? env.defaultLogger\n\n  const rules = options.rules ?? {}\n  const preset = rules.preset === 'default' ? defaultRules : {}\n  deprecateOptions(rules, logger)\n\n  let hyperParse: Array<string | ((status: ParsedStatus) => ParsedStatus)>\n\n  if (typeof options.hyperParse === 'function') {\n    hyperParse = [options.hyperParse]\n  } else {\n    hyperParse = options.hyperParse || hyperParseInfo.map((item) => item.name)\n  }\n\n  const normoalizedOptions: NormalizedOptions = {\n    logger,\n    ignoredCases: options.ignoredCases || [],\n    rules: { ...preset, ...rules },\n    hyperParse: matchCallArray<(status: ParsedStatus) => ParsedStatus>(\n      hyperParse,\n      hyperParseMap\n    )\n  }\n\n  return normoalizedOptions\n}\n\nexport const normalizeConfig = (\n  config: Config,\n  logger: Console = env.defaultLogger\n): NormalizedOptions => {\n  const options: NormalizedOptions = {\n    logger,\n    rules: {},\n    hyperParse: [],\n    ignoredCases: []\n  }\n  let hyperParse: string[] = []\n\n  // preset\n  if (config.preset === 'default') {\n    options.rules = { ...defaultRules }\n    hyperParse = hyperParseInfo.map((item) => item.name)\n  }\n\n  // rules\n  if (config.rules) {\n    options.rules = { ...options.rules, ...config.rules }\n  }\n\n  // hyper parsers\n  if (Array.isArray(config.hyperParsers)) {\n    hyperParse = config.hyperParsers\n  }\n  hyperParse.forEach((x) => {\n    if (!hyperParseMap[x]) {\n      logger.log(`The hyper parser ${x} is invalid.`)\n      return\n    }\n    options.hyperParse.push(hyperParseMap[x])\n  })\n\n  // ignored cases\n  if (config.ignores) {\n    config.ignores.forEach((x) => {\n      const ignoredCase = parseIngoredCase(x)\n      if (ignoredCase) {\n        options.ignoredCases.push(ignoredCase)\n      } else {\n        logger.log(`The format of ignore case: \"${x}\" is invalid.`)\n      }\n    })\n  }\n\n  return options\n}\n","import { env } from './report'\n\n// Ref: https://github.com/WICG/ScrollToTextFragment\nexport type IgnoredCase = {\n  prefix?: string\n  textStart: string\n  textEnd?: string\n  suffix?: string\n}\n\nexport type IgnoredMark = {\n  start: number\n  end: number\n}\n\n/**\n * @param  {string}        str\n * @param  {IgnoredCase[]} ignoredCases string which should be skipped\n * @return {IgnoredMark[]}\n */\nconst findIgnoredMarks = (\n  str: string,\n  ignoredCases: IgnoredCase[] = [],\n  logger: Console = env.defaultLogger\n): IgnoredMark[] => {\n  const marks: IgnoredMark[] = []\n  ignoredCases.forEach(({ prefix, textStart, textEnd, suffix }): void => {\n    const start = (prefix || '') + textStart\n    const end = (textEnd || '') + (suffix || '')\n    const startOffset = prefix ? prefix.length : 0\n    const endOffset = suffix ? suffix.length : 0\n\n    const findNextMatch = (currentIndex: number): void => {\n      const startIndex = str.substring(currentIndex).indexOf(start)\n      if (startIndex === -1) {\n        return\n      }\n\n      const possibleStart = currentIndex + startIndex + startOffset\n      const nextPossibleCurrentIndex = possibleStart + textStart.length\n\n      if (!end) {\n        if (globalThis.__DEV__) {\n          logger.log(\n            `ignore: ${str.substring(possibleStart, nextPossibleCurrentIndex)}`\n          )\n        }\n        marks.push({\n          start: possibleStart,\n          end: nextPossibleCurrentIndex\n        })\n        findNextMatch(nextPossibleCurrentIndex)\n      } else {\n        const endIndex = str.substring(nextPossibleCurrentIndex).indexOf(end)\n        const possibleEnd =\n          nextPossibleCurrentIndex + endIndex + (textEnd || '').length\n\n        if (endIndex === -1) {\n          return\n        } else {\n          if (globalThis.__DEV__) {\n            logger.log(`ignore: ${str.substring(possibleStart, possibleEnd)}`)\n          }\n          marks.push({\n            start: possibleStart,\n            end: possibleEnd\n          })\n          findNextMatch(possibleEnd + endOffset)\n        }\n      }\n    }\n\n    findNextMatch(0)\n  })\n  return marks.sort((a, b) => a.start - b.start)\n}\n\nexport default findIgnoredMarks\n","import { IgnoredMark } from './ignore'\nimport { Validation, ValidationTarget } from './report'\nimport {\n  MutableGroupToken as GroupToken,\n  MutableToken as Token\n} from './parser'\n\nconst isInRange = (start: number, end: number, mark: IgnoredMark) => {\n  return start <= mark.end && end >= mark.start\n}\n\ntype IgnoredFlags = Record<ValidationTarget, boolean>\n\nconst isIgnored = (token: Token, marks: IgnoredMark[] = []): IgnoredFlags => {\n  const result: IgnoredFlags = {\n    [ValidationTarget.CONTENT]: false,\n    [ValidationTarget.SPACE_AFTER]: false,\n    [ValidationTarget.START_CONTENT]: false,\n    [ValidationTarget.END_CONTENT]: false,\n    [ValidationTarget.INNER_SPACE_BEFORE]: false,\n  }\n\n  // - group: startContent, innerSpaceBefore, endContent, spaceAfter\n  // - single: raw, spaceAfter\n  marks.forEach((mark) => {\n    if (Array.isArray(token)) {\n      const {\n        index,\n        startContent,\n        innerSpaceBefore,\n        endIndex = 0,\n        endContent,\n        spaceAfter\n      } = token\n      if (isInRange(index, index + (startContent || '').length, mark)) {\n        result[ValidationTarget.SPACE_AFTER] = true\n      }\n      if (\n        isInRange(\n          index + (startContent || '').length,\n          index + (startContent || '').length + (innerSpaceBefore || '').length,\n          mark\n        )\n      ) {\n        result[ValidationTarget.INNER_SPACE_BEFORE] = true\n      }\n      if (isInRange(endIndex, endIndex + (endContent || '').length, mark)) {\n        result[ValidationTarget.END_CONTENT] = true\n      }\n      if (\n        isInRange(\n          endIndex + (endContent || '').length,\n          endIndex + (endContent || '').length + (spaceAfter || '').length,\n          mark\n        )\n      ) {\n        result[ValidationTarget.SPACE_AFTER] = true\n      }\n    } else {\n      const { index, content, spaceAfter } = token\n      if (isInRange(index, index + (content || '').length, mark)) {\n        result[ValidationTarget.CONTENT] = true\n      }\n      if (\n        isInRange(\n          index + (content || '').length,\n          index + (content || '').length + (spaceAfter || '').length,\n          mark\n        )\n      ) {\n        result[ValidationTarget.SPACE_AFTER] = true\n      }\n    }\n  })\n  return result\n}\n\nconst recordValidations = (\n  token: Token,\n  offset = 0,\n  ignoredFlags: IgnoredFlags,\n  validations: Validation[] = []\n): void => {\n  token.validations.forEach((v) => {\n    if (!ignoredFlags[v.target]) {\n      validations.push({ ...v, index: v.index + offset })\n    }\n  })\n}\n\n/**\n * Join tokens back into string\n * @param tokens the target group token, the index is relative to the block it belongs to\n * @param offset the index of the block, relative to the file it belongs to\n * @param ignoredMarks the ignored marks, the index is relative to the block it belongs to\n * @param validations the validation list result\n * @param isChild whether the group token is a child token of the block\n */\nconst join = (\n  tokens: GroupToken,\n  offset = 0,\n  ignoredMarks: IgnoredMark[] = [],\n  validations: Validation[] = [],\n  isChild?: boolean\n): string => {\n  const ignoredFlags = isIgnored(tokens, ignoredMarks)\n  if (!isChild) {\n    recordValidations(tokens, offset, ignoredFlags, validations)\n  }\n  return [\n    ignoredFlags[ValidationTarget.START_CONTENT] ? tokens.startContent : tokens.modifiedStartContent,\n    ignoredFlags[ValidationTarget.INNER_SPACE_BEFORE]\n      ? tokens.innerSpaceBefore\n      : tokens.modifiedInnerSpaceBefore,\n    ...tokens.map((token) => {\n      const subIgnoredFlags = isIgnored(token, ignoredMarks)\n      recordValidations(token, offset, subIgnoredFlags, validations)\n      if (!Array.isArray(token)) {\n        return [\n          subIgnoredFlags[ValidationTarget.CONTENT] ? token.content : token.modifiedContent,\n          subIgnoredFlags[ValidationTarget.SPACE_AFTER]\n            ? token.spaceAfter\n            : token.modifiedSpaceAfter\n        ]\n          .filter(Boolean)\n          .join('')\n        }\n      return join(token, offset, ignoredMarks, validations, true)\n    }),\n    ignoredFlags[ValidationTarget.END_CONTENT] ? tokens.endContent : tokens.modifiedEndContent,\n    ignoredFlags[ValidationTarget.SPACE_AFTER] ? tokens.spaceAfter : tokens.modifiedSpaceAfter\n  ]\n    .filter(Boolean)\n    .join('')\n}\n\nexport default join\n","import { Block } from './hypers/types'\n\ntype Piece = Block & {\n  nonBlock?: boolean\n}\n\nconst replaceBlocks = (str: string, blocks: Block[]): string => {\n  if (blocks.length === 0) {\n    return str\n  }\n  const pieces = blocks.reduce((pieces: Piece[], block, index) => {\n    const { start, end } = block\n    const lastPiece = pieces[pieces.length - 1]\n    const nextStart = lastPiece ? lastPiece.end : 0\n\n    // non-block piece before the current block.\n    if (nextStart < start) {\n      const nonBlockPiece = {\n        nonBlock: true,\n        start: nextStart,\n        end: start\n      } as Piece\n      nonBlockPiece.value = str.substring(\n        nonBlockPiece.start,\n        nonBlockPiece.end\n      )\n      pieces.push(nonBlockPiece)\n    }\n\n    // The current block piece.\n    pieces.push(block)\n\n    // Tailing non-block piece.\n    if (index === blocks.length - 1 && end !== str.length) {\n      const nonBlockPiece = {\n        nonBlock: true,\n        start: end,\n        end: str.length\n      } as Piece\n      nonBlockPiece.value = str.substring(\n        nonBlockPiece.start,\n        nonBlockPiece.end\n      )\n      pieces.push(nonBlockPiece)\n    }\n    return pieces\n  }, [])\n\n  return pieces.map(({ value }) => value).join('')\n}\n\nexport default replaceBlocks\n","import { Block, ParsedStatus } from './hypers/types'\nimport { Validation } from './report'\nimport { NormalizedOptions, Options } from './options'\nimport { Config } from './rc'\n\nimport { normalizeOptions, normalizeConfig } from './options'\nimport { parse, toMutableResult, travel } from './parser'\nimport generateHandlers from './rules'\nimport findIgnoredMarks from './ignore'\nimport join from './join'\nimport replaceBlocks from './replace-block'\n\nexport { Options } from './options'\n\nexport type Result = {\n  file?: string\n  disabled?: boolean\n  origin: string\n  result: string\n  validations: Validation[]\n}\n\nexport const run = (str: string, options: Options = {}): Result => {\n  const normalizedOptions = normalizeOptions(options)\n  return lint(str, normalizedOptions)\n}\n\nexport const runWithConfig = (str: string, config: Config): Result => {\n  const normalizedOptions = normalizeConfig(config)\n  return lint(str, normalizedOptions)\n}\n\nconst lint = (str: string, normalizedOptions: NormalizedOptions): Result => {\n  // return if the file is totally ignored\n  const disabledMatcher = /<!--\\s*zhlint\\s*disabled\\s*-->/g\n  if (str.match(disabledMatcher)) {\n    return { origin: str, result: str, validations: [], disabled: true }\n  }\n\n  const { logger, ignoredCases, rules, hyperParse } = normalizedOptions\n\n  // init status\n  // str -> ignoredByRules, ignoredByParsers\n  // blocks -> marks, ignoredMarks\n  const status: ParsedStatus = {\n    content: str,\n    modifiedContent: str,\n    ignoredByRules: ignoredCases,\n    ignoredByParsers: [],\n    blocks: [\n      {\n        value: str,\n        marks: [],\n        start: 0,\n        end: str.length - 1\n      }\n    ]\n  }\n\n  const parserErrors: Validation[] = []\n  const ruleErrors: Validation[] = []\n\n  // Run all the hyper parsers\n  const parsedStatus = hyperParse.reduce(\n    (current, parse) => parse(current),\n    status\n  )\n\n  // 1. Parse each block without ignoredByParsers\n  // 2. Parse all ignoredByRules into marks for each block\n  // 3. Run all rule processes for each block\n  // 4. Join all tokens with ignoredMarks and all errors for each block\n  // 5. Replace each block back to the string\n  const ruleHandlers = generateHandlers(rules)\n  const modifiedBlocks: Block[] = parsedStatus.blocks.map(\n    ({ value, marks, start, end }) => {\n      let lastValue = value\n      if (globalThis.__DEV__) {\n        logger.log('[Original block value]')\n        logger.log(lastValue)\n      }\n      const result = toMutableResult(parse(value, marks), rules)\n      parserErrors.push(...result.errors)\n      const ignoredMarks = findIgnoredMarks(\n        value,\n        status.ignoredByRules,\n        logger\n      )\n\n      ruleHandlers.forEach((rule) => {\n        travel(result.tokens, rule)\n        if (globalThis.__DEV__) {\n          const currentValue = join(result.tokens, start, ignoredMarks, [])\n          if (lastValue !== currentValue) {\n            logger.log(`[After process by ${rule.name}]`)\n            logger.log(currentValue)\n          }\n          lastValue = currentValue\n        }\n      })\n\n      lastValue = join(result.tokens, start, ignoredMarks, ruleErrors)\n      if (globalThis.__DEV__) {\n        logger.log('[Eventual block value]')\n        logger.log(lastValue + '\\n')\n      }\n      return {\n        start,\n        end,\n        value: lastValue\n      } as Block\n    }\n  )\n\n  return {\n    origin: str,\n    result: replaceBlocks(str, modifiedBlocks),\n    validations: [...parserErrors, ...ruleErrors]\n  }\n}\n\nexport default run\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","'use strict';\n\nvar empty = null;\n\nmodule.exports = empty;\n//# sourceMappingURL=empty.js.map\n","import { Options } from '../options'\n\nimport { resolve } from 'path'\nimport { existsSync, readFileSync } from 'fs'\n\nimport { env } from '../report'\n\ntype PathResult = {\n  config: string | undefined\n  ignore: string | undefined\n}\n\nconst resolvePath = (\n  dir: string,\n  config: string,\n  ignore: string,\n  logger: Console = env.defaultLogger\n): PathResult => {\n  const result: PathResult = {\n    config: undefined,\n    ignore: undefined\n  }\n  dir = resolve(dir ?? '.')\n  if (!existsSync(dir)) {\n    logger.log(`\"${dir}\" does not exist.`)\n    return result\n  }\n  config = resolve(dir, config ?? '.zhlintrc')\n  if (existsSync(config)) {\n    result.config = config\n  } else {\n    logger.log(\n      `Config file \"${config}\" does not exist. Will proceed as default.`\n    )\n  }\n  ignore = resolve(dir, ignore ?? '.zhlintignore')\n  if (existsSync(ignore)) {\n    result.ignore = ignore\n  } else {\n    logger.log(\n      `Global ignored cases file \"${ignore}\" does not exist. Will proceed as none.`\n    )\n  }\n  return result\n}\n\nexport type Config = {\n  preset?: string\n  rules?: Options['rules']\n  hyperParsers?: string[]\n  ignores?: string[]\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst readJSONSync = (filepath: string): any => {\n  const output = readFileSync(filepath, { encoding: 'utf8' })\n  return JSON.parse(output)\n}\n\nconst resolveConfig = (\n  normalizedConfigPath: string | undefined,\n  normalizedIgnorePath: string | undefined,\n  logger: Console = env.defaultLogger\n): Config => {\n  const result: Config = {\n    preset: 'default'\n  }\n  if (normalizedConfigPath) {\n    try {\n      const config: Config = readJSONSync(normalizedConfigPath)\n      if (typeof config.preset === 'string') {\n        result.preset = config.preset\n      }\n      if (typeof config.rules === 'object') {\n        result.rules = config.rules\n      }\n      if (Array.isArray(config.hyperParsers)) {\n        result.hyperParsers = config.hyperParsers\n      }\n      if (Array.isArray(config.ignores)) {\n        result.ignores = config.ignores\n      }\n    } catch (error) {\n      logger.log(\n        `Failed to read \"${normalizedConfigPath}\": ${(error as Error).message}`\n      )\n    }\n  }\n  if (normalizedIgnorePath) {\n    try {\n      const ignores = readFileSync(normalizedIgnorePath, { encoding: 'utf8' })\n      ignores\n        .split(/\\n/)\n        .map((x) => x.trim())\n        .forEach((x) => {\n          if (!x) {\n            return\n          }\n          if (!result.ignores) {\n            result.ignores = []\n          }\n          if (result.ignores.indexOf(x) === -1) {\n            result.ignores.push(x)\n          }\n        })\n    } catch (error) {\n      logger.log(\n        `Failed to read \"${normalizedIgnorePath}\": ${(error as Error).message}`\n      )\n    }\n  }\n  return result\n}\n\nexport const readRc = (\n  dir: string,\n  config: string,\n  ignore: string,\n  logger: Console = env.defaultLogger\n): Config => {\n  const { config: normalizedConfigPath, ignore: normalizedIgnorePath } =\n    resolvePath(dir, config, ignore, logger)\n  return resolveConfig(normalizedConfigPath, normalizedIgnorePath, logger)\n}\n"],"names":["parser","matcher","isArray","extend","bail","own","stringify","require$$0","VMessage","proto","join","assertPath","normalize","require$$1","require$$2","VFile","vfile","slice","wrap","trough","require$$3","require$$4","keys","inherits_browserModule","xtend","unherit","factory","vfileLocation","backslash","decimal","hexadecimal","alphabetical","alphanumerical","semicolon","decodeEntity","require$$5","defaults","tab","lineFeed","space","lessThan","equalsTo","numberSign","lowercaseX","parse","decode","tokenizer","escapes","convert","visitParents","CONTINUE","SKIP","EXIT","visit","removePosition","whitespace","fromCode","re","repeat","trimTrailingLines","trim","tabSize","tilde","graveAccent","interrupt","greaterThan","asterisk","dash","underscore","indentation","getIndent","exclamationMark","dot","rightParenthesis","collapseWhiteSpace","leftSquareBracket","rightSquareBracket","caret","colon","quotationMark","apostrophe","leftParenthesis","_escape","locate","tag","atSign","slash","mailto","url","protocols","link","strong","emphasis","_delete","fence","codeInline","_break","unescape","Parser","require$$6","require$$7","require$$8","require$$9","require$$10","require$$11","require$$12","require$$13","require$$14","require$$15","require$$16","require$$17","require$$18","require$$19","require$$20","require$$21","require$$22","require$$23","require$$24","require$$25","require$$26","require$$27","require$$28","require$$29","require$$30","require$$31","require$$32","require$$33","fault","create","matters","compile","conversions","route","colorConvert","chalk","unified","markdown","frontmatter","generateHandler","isFullWidth","genSpaceTrimGenerateHandler","genPunctuationWidthHandler","genPunctuationUnificationHandler","genAbbrsHandler","genSpaceOfWrapperHandler","genSpaceOfCodeHandler","genSpaceOfLettersHandler","genSpaceOfPunctuationHandler","genSpaceOfQuoteHandler","genSpaceOfBracketHandler","genLinebreakHandler","genZhUnitsHandler","genHtmlEntityHandler","ignore","hexo","vuepress","md","defaultRules","resolve","existsSync","readFileSync"],"mappings":"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"}