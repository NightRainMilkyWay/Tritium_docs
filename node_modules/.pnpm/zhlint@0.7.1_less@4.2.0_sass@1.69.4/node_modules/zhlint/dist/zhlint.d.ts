export declare type Block = {
    value: string
    marks: Mark[]
    start: number
    end: number
}

declare enum CharType {
    EMPTY = 'empty',
    SPACE = 'space',
    LETTERS_HALF = 'letters-half',
    LETTERS_FULL = 'letters-full',
    PUNCTUATION_HALF = 'punctuation-half',
    PUNCTUATION_FULL = 'punctuation-full',
    UNKNOWN = 'unknown'
}

declare type CommonToken = {
    index: number
    length: number

    content: string
    spaceAfter: string

    mark?: Mark
    markSide?: MarkSideType
}

declare type Config = {
    preset?: string
    rules?: Options['rules']
    hyperParsers?: string[]
    ignores?: string[]
}

declare type ContentTokenType = LettersType | PunctuationType

export declare type GroupToken = Array<Token> &
CommonToken &
Pair & {
    type: GroupTokenType
    innerSpaceBefore: string
}

export declare enum GroupTokenType {
    GROUP = 'group'
}

export declare type Handler = (
token: MutableToken | Token,
index: number,
group: MutableGroupToken | GroupToken
) => void

/**
 * TODO: paired html tags should be hyper wrapper
 */
declare enum HyperTokenType {
    /**
     * Brackets
     */
    HYPER_WRAPPER_BRACKET = 'wrapper-bracket',
    /**
     * Inline Markdown marks
     */
    HYPER_WRAPPER = 'wrapper',
    /**
     * - \`xxx\`
     * - &lt;code&gt;xxx&lt;/code&gt;
     */
    HYPER_CONTENT_CODE = 'hyper-content-code',
    /**
     * - Hexo/VuePress container
     * - Other html code
     */
    HYPER_CONTENT = 'hyper-content',
    /**
     * Unpaired brackets/quotes
     */
    UNMATCHED = 'unmatched',
    /**
     * For indeterminate tokens
     */
    INDETERMINATED = 'indeterminated'
}

export declare type IgnoredCase = {
    prefix?: string
    textStart: string
    textEnd?: string
    suffix?: string
}

declare type LettersType = CharType.LETTERS_FULL | CharType.LETTERS_HALF

export declare type Mark = Pair & {
    type: MarkType
    meta?: string // AST type enum
}

declare enum MarkSideType {
    LEFT = 'left',
    RIGHT = 'right'
}

/**
 * Marks are hyper info, including content and wrappers.
 * They are categorized by parsers, not by usage.
 */
export declare enum MarkType {
    /**
     * Brackets
     */
    BRACKETS = 'brackets',
    /**
     * Inline Markdown marks
     */
    HYPER = 'hyper',
    /**
     * - \`xxx\`
     * - &lt;code&gt;xxx&lt;/code&gt;
     * - Hexo/VuePress container
     * - Other html code
     */
    RAW = 'raw'
}

declare type MutableCommonToken = CommonToken & {
    modifiedContent: string
    modifiedSpaceAfter: string
    validations: Validation[]
}

declare type MutableGroupToken = Array<MutableToken> &
MutableCommonToken &
Pair &
MutablePair & {
    type: GroupTokenType
    modifiedType: GroupTokenType
    innerSpaceBefore: string
    modifiedInnerSpaceBefore: string
}

declare type MutablePair = {
    modifiedStartContent: string
    modifiedEndContent: string
}

declare type MutableSingleToken = MutableCommonToken & {
    type: SingleTokenType
    modifiedType: SingleTokenType
}

declare type MutableToken = MutableSingleToken | MutableGroupToken

export declare type Options = {
    logger?: Console
    rules?: Options_2
    hyperParse?:
    | (string | ((status: ParsedStatus) => ParsedStatus))[]
    | ((status: ParsedStatus) => ParsedStatus)
    ignoredCases?: IgnoredCase[]
}

declare type Options_2 = {
    // parsing
    noSinglePair?: boolean

    // punctuation
    halfWidthPunctuation?: string
    fullWidthPunctuation?: string
    adjustedFullWidthPunctuation?: string
    unifiedPunctuation?: 'traditional' | 'simplified'

    // case: abbrs
    skipAbbrs?: string[]

    // space around content
    spaceBetweenHalfWidthLetters?: boolean
    noSpaceBetweenFullWidthLetters?: boolean
    spaceBetweenMixedWidthLetters?: boolean

    // space around punctuation
    noSpaceBeforePunctuation?: boolean
    spaceAfterHalfWidthPunctuation?: boolean
    noSpaceAfterFullWidthPunctuation?: boolean

    // space around quote
    spaceOutsideHalfQuote?: boolean
    noSpaceOutsideFullQuote?: boolean
    noSpaceInsideQuote?: boolean

    // space around bracket
    spaceOutsideHalfBracket?: boolean
    noSpaceOutsideFullBracket?: boolean
    noSpaceInsideBracket?: boolean

    // space around code
    spaceOutsideCode?: boolean

    // space around mark
    noSpaceInsideWrapper?: boolean

    // trim space
    trimSpace?: boolean

    // case: number x Chinese unit
    skipZhUnits?: string

    // custom preset
    preset?: string

    /**
     * @deprecated
     *
     * Please use `noSpaceInsideWrapper` instead.
     */
    noSpaceInsideMark?: boolean
    /**
     * @deprecated
     *
     * Please use `spaceBetweenHalfWidthLetters` instead.
     */
    spaceBetweenHalfWidthContent?: boolean
    /**
     * @deprecated
     *
     * Please use `noSpaceBetweenFullWidthLetters` instead.
     */
    noSpaceBetweenFullWidthContent?: boolean
    /**
     * @deprecated
     *
     * Please use `spaceBetweenMixedWidthLetters` instead.
     */
    spaceBetweenMixedWidthContent?: boolean
}

declare type Pair = {
    startIndex: number
    startContent: string
    endIndex: number
    endContent: string
}

export declare type ParsedStatus = {
    content: string
    modifiedContent: string
    ignoredByRules: IgnoredCase[]
    ignoredByParsers: ParserIgnoredCase[]
    blocks: Block[]
}

export declare type ParserIgnoredCase = {
    name: string
    meta: string
    index: number
    length: number
    originContent: string
}

declare type PunctuationType =
| CharType.PUNCTUATION_FULL
| CharType.PUNCTUATION_HALF

export declare const readRc: (
dir: string,
config: string,
ignore: string,
logger?: Console
) => Config;

export declare const report: (resultList: Result[], logger?: Console) => number;

export declare type Result = {
    file?: string
    disabled?: boolean
    origin: string
    result: string
    validations: Validation[]
}

export declare const run: (str: string, options?: Options) => Result;

export declare const runWithConfig: (str: string, config: Config) => Result;

export declare type SingleToken = CommonToken & {
    type: SingleTokenType
}

export declare type SingleTokenType = ContentTokenType | HyperTokenType

export declare type Token = SingleToken | GroupToken

export declare type Validation = {
    // the type and content of message
    name: string
    message: string

    // position of the token
    index: number
    length: number

    // which part of the token the error comes from
    target: ValidationTarget
}

export declare enum ValidationTarget {
    CONTENT = 'content',
    START_CONTENT = 'startContent',
    END_CONTENT = 'endContent',
    SPACE_AFTER = 'spaceAfter',
    INNER_SPACE_BEFORE = 'innerSpaceBefore'
}

export { }
